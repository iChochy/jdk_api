<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc (build 1.6.0-beta2) on Mon Mar 19 18:36:49 CST 2007 -->
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
<TITLE>
GroupLayout (Java Platform SE 6)
</TITLE>

<META NAME="date" CONTENT="2007-03-19">

<LINK REL ="stylesheet" TYPE="text/css" HREF="../../stylesheet.css" TITLE="Style">

<SCRIPT type="text/javascript">
function windowTitle()
{
    if (location.href.indexOf('is-external=true') == -1) {
        parent.document.title="GroupLayout (Java Platform SE 6)";
    }
}
</SCRIPT>
<NOSCRIPT>
</NOSCRIPT>

</HEAD>

<BODY BGCOLOR="white" onload="windowTitle();">
<HR>


<!-- ========= START OF TOP NAVBAR ======= -->
<A NAME="navbar_top"><!-- --></A>
<A HREF="#skip-navbar_top" title="跳过导航链接"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>概述</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>软件包</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>类</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/GroupLayout.html"><FONT CLASS="NavBarFont1"><B>使用</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>树</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>已过时</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>索引</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../help-doc.html"><FONT CLASS="NavBarFont1"><B>帮助</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
<b>Java<sup><font size=-2>TM</font></sup>&nbsp;Platform<br>Standard&nbsp;Ed. 6</b></EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../javax/swing/GrayFilter.html" title="javax.swing 中的类"><B>上一个类</B></A>&nbsp;
&nbsp;<A HREF="../../javax/swing/GroupLayout.Alignment.html" title="javax.swing 中的枚举"><B>下一个类</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../index.html?javax/swing/GroupLayout.html" target="_top"><B>框架</B></A>  &nbsp;
&nbsp;<A HREF="GroupLayout.html" target="_top"><B>无框架</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../allclasses-noframe.html"><B>所有类</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../allclasses-noframe.html"><B>所有类</B></A>
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  摘要：&nbsp;<A HREF="#nested_class_summary">嵌套</A>&nbsp;|&nbsp;<A HREF="#field_summary">字段</A>&nbsp;|&nbsp;<A HREF="#constructor_summary">构造方法</A>&nbsp;|&nbsp;<A HREF="#method_summary">方法</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
详细信息：&nbsp;<A HREF="#field_detail">字段</A>&nbsp;|&nbsp;<A HREF="#constructor_detail">构造方法</A>&nbsp;|&nbsp;<A HREF="#method_detail">方法</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_top"></A>
<!-- ========= END OF TOP NAVBAR ========= -->

<HR>
<!-- ======== START OF CLASS DATA ======== -->
<H2>
<FONT SIZE="-1">
javax.swing</FONT>
<BR>
类 GroupLayout</H2>
<PRE>
<A HREF="../../java/lang/Object.html" title="java.lang 中的类">java.lang.Object</A>
  <IMG SRC="../../resources/inherit.gif" ALT="继承者 "><B>javax.swing.GroupLayout</B>
</PRE>
<DL>
<DT><B>所有已实现的接口：</B> <DD><A HREF="../../java/awt/LayoutManager.html" title="java.awt 中的接口">LayoutManager</A>, <A HREF="../../java/awt/LayoutManager2.html" title="java.awt 中的接口">LayoutManager2</A></DD>
</DL>
<HR>
<DL>
<DT><PRE>public class <B>GroupLayout</B><DT>extends <A HREF="../../java/lang/Object.html" title="java.lang 中的类">Object</A><DT>implements <A HREF="../../java/awt/LayoutManager2.html" title="java.awt 中的接口">LayoutManager2</A></DL>
</PRE>

<P>
<code>GroupLayout</code> 是一个 <code>LayoutManager</code>，它将组件按层次分组，以决定它们在 <code>Container</code> 中的位置。<code>GroupLayout</code> 主要供生成器使用，但也可以手工编码。分组由 <A HREF="../../javax/swing/GroupLayout.Group.html" title="javax.swing 中的类"><CODE>Group</CODE></A> 类的实例来完成。<code>GroupLayout</code> 支持两种组。串行组 (sequential group) 按顺序一个接一个地放置其子元素。并行组 (parallel group) 能够以四种方式对齐其子元素。
 <p>
每个组可以包含任意数量的元素，其中元素有 <code>Group</code>、<code>Component</code> 或间隙 (gap)。间隙可被视为一个具有最小大小、首选大小和最大大小的不可见组件。此外，<code>GroupLayout</code> 还支持其值取自 <code>LayoutStyle</code> 的首选间隙。
 <p>
元素类似于一个弹簧。每个元素都有一个范围，由最小大小、首选大小和最大大小指定。间隙的范围由开发人员指定，或者由 <code>LayoutStyle</code> 确定。<code>Component</code> 的范围通过 <code>Component</code> 的 <code>getMinimumSize</code>、<code>getPreferredSize</code> 和 <code>getMaximumSize</code> 方法确定。此外，添加 <code>Component</code> 时，可以指定使用一个特定范围，而不使用该组件的范围。<code>Group</code> 的范围由组的类型确定。<code>ParallelGroup</code> 的范围是其元素范围的最大值。<code>SequentialGroup</code> 的范围是其元素范围的总和。
 <p>
<code>GroupLayout</code> 将每个轴 (axis) 单独对待。也就是说，存在一个表示水平轴的组和一个表示垂直轴的组。水平组负责确定沿水平轴的最小大小、首选大小和最大大小，并设置所包含组件的 x 和宽度。垂直组负责确定沿垂直轴的最小大小、首选大小和最大大小，并设置所包含组件的 y 和高度。每个 <code>Component</code> 都必须同时存在于水平组和垂直组中，否则，在布局过程中或者在请求最小大小、首选大小或最大大小时，将抛出 <code>IllegalStateException</code>。
 <p>
下图显示了一个沿水平轴的串行组。该串行组包含三个组件。沿垂直轴使用了一个并行组。 
 <p align="center">
 <img src="doc-files/groupLayout.1.gif">
 <p>
为了强调要单独对待每个轴，该图显示了沿每个轴的每个组和元素的范围。每个组件的范围已被投射到轴上，两个组分别呈现为蓝色（水平）和红色（垂直）。为了便于理解，串行组中的每个元素之间都有一个间隙。
 <p>
沿水平轴的串行组呈现为蓝色实线。注意，串行组是它所包含的子元素的总和。
 <p>
沿垂直轴，并行组是每个组件高度的最大值。由于三个组件的高度都相同，所以并行组具有相同的高度。
 <p>
下图显示了与上图中相同的三个组件，但并行组沿水平轴，串行组沿垂直轴。
 <p>
 <p align="center">
 <img src="doc-files/groupLayout.2.gif">
 <p>
由于 <code>c1</code> 在三个组件中最大，所以并行组的大小被确定为 <code>c1</code>。由于 <code>c2</code> 和 <code>c3</code> 小于 <code>c1</code>，所以将根据为组件指定的对齐方式（如果已指定）或并行组的默认对齐方式将它们对齐。在该图中，<code>c2</code> 和 <code>c3</code> 是使用 <code>LEADING</code> 的对齐方式创建的。如果组件的方向是从右到左，那么 <code>c2</code> 和 <code>c3</code> 的位置将在相反的一侧对齐（沿右侧对齐）。
 <p>
下图显示了沿水平和垂直两个轴的串行组。
 <p align="center">
 <img src="doc-files/groupLayout.3.gif">
 <p>
<code>GroupLayout</code> 提供在 <code>Component</code> 之间插入间隙的能力。间隙的大小由 <code>LayoutStyle</code> 的实例确定。可以使用 <code>setAutoCreateGaps</code> 方法进行此操作。类似地，可以使用 <code>setAutoCreateContainerGaps</code> 方法在触到父容器边缘的组件和容器之间插入间隙。
 <p>
以下代码构建了一个面板，该面板由两列构成，第一列中有两个标签，第二列中有两个文本字段：
 <pre>
JComponent panel = ...;
GroupLayout layout = new GroupLayout(panel);
panel.setLayout(layout);
 
// Turn on automatically adding gaps between components
layout.setAutoCreateGaps(true);
 
// Turn on automatically creating gaps between components that touch
// the edge of the container and the container.
layout.setAutoCreateContainerGaps(true);
 
// Create a sequential group for the horizontal axis.
 
GroupLayout.SequentialGroup hGroup = layout.createSequentialGroup();
 
// The sequential group in turn contains two parallel groups.
// One parallel group contains the labels, the other the text fields.
// Putting the labels in a parallel group along the horizontal axis
// positions them at the same x location.
   //
// Variable indentation is used to reinforce the level of grouping.
hGroup.addGroup(layout.createParallelGroup().
addComponent(label1).addComponent(label2));
hGroup.addGroup(layout.createParallelGroup().
addComponent(tf1).addComponent(tf2));
layout.setHorizontalGroup(hGroup);
   
// Create a sequential group for the vertical axis.
GroupLayout.SequentialGroup vGroup = layout.createSequentialGroup();
 
// The sequential group contains two parallel groups that align
// the contents along the baseline.The first parallel group contains
// the first label and text field, and the second parallel group contains
// the second label and text field.By using a sequential group
// the labels and text fields are positioned vertically after one another.
vGroup.addGroup(layout.createParallelGroup(Alignment.BASELINE).
addComponent(label1).addComponent(tf1));
vGroup.addGroup(layout.createParallelGroup(Alignment.BASELINE).
addComponent(label2).addComponent(tf2));
layout.setVerticalGroup(vGroup);
 </pre>
 <p>
运行代码时，将出现下面的窗口。
 <p align="center">
 <img src="doc-files/groupLayout.example.png">
 <p>
此布局由以下部分组成。
<ul><li>水平轴由一个包含两个并行组的串行组组成。第一个并行组包含标签，第二个并行组包含文本字段。
<li>垂直轴由一个包含两个并行组的串行组组成。并行组被配置为沿基线对齐其组件。第一个并行组包含第一个标签和第一个文本字段，第二个并行组包含第二个标签和第二个文本字段。
 </ul>
在这段代码中，要注意几个问题：
 <ul>
<li>不需要显式地将组件添加到容器；通过使用 <code>Group</code> 的一个 <code>add</code> 方法间接完成此操作。
<li>各种 <code>add</code> 方法返回调用者。这使得调用能很方便地进行链接。例如，<code>group.addComponent(label1).addComponent(label2);</code> 等效于 <code>group.addComponent(label1); group.addComponent(label2);</code>。
<li><code>Group</code> 没有公共构造方法；请使用 <code>GroupLayout</code> 的创建方法替代。
 </ul>
<P>

<P>
<DL>
<DT><B>从以下版本开始：</B></DT>
  <DD>1.6</DD>
</DL>
<HR>

<P>
<!-- ======== NESTED CLASS SUMMARY ======== -->

<A NAME="nested_class_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>嵌套类摘要</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;class</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/GroupLayout.Alignment.html" title="javax.swing 中的枚举">GroupLayout.Alignment</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>ParallelGroup</code> 能够对齐其子元素的可能方式的枚举。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;class</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/GroupLayout.Group.html" title="javax.swing 中的类">GroupLayout.Group</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>Group</code> 为 <code>GroupLayout</code> 所支持的以下两种操作提供基础：一个接一个地布置组件（<A HREF="../../javax/swing/GroupLayout.SequentialGroup.html" title="javax.swing 中的类"><CODE>SequentialGroup</CODE></A>）或对齐组件（<A HREF="../../javax/swing/GroupLayout.ParallelGroup.html" title="javax.swing 中的类"><CODE>ParallelGroup</CODE></A>）。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;class</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/GroupLayout.ParallelGroup.html" title="javax.swing 中的类">GroupLayout.ParallelGroup</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一个 <code>Group</code>，它对齐其子元素并确定其大小。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;class</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/GroupLayout.SequentialGroup.html" title="javax.swing 中的类">GroupLayout.SequentialGroup</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一个 <code>Group</code>，它按顺序一个接一个地确定其元素的位置和大小。</TD>
</TR>
</TABLE>
&nbsp;<!-- =========== FIELD SUMMARY =========== -->

<A NAME="field_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>字段摘要</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/GroupLayout.html#DEFAULT_SIZE">DEFAULT_SIZE</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;指示组件或间隙的大小应该用于特定的范围值。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/GroupLayout.html#PREFERRED_SIZE">PREFERRED_SIZE</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;指示组件或间隙的首选大小应该用于特定的范围值。</TD>
</TR>
</TABLE>
&nbsp;
<!-- ======== CONSTRUCTOR SUMMARY ======== -->

<A NAME="constructor_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>构造方法摘要</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../javax/swing/GroupLayout.html#GroupLayout(java.awt.Container)">GroupLayout</A></B>(<A HREF="../../java/awt/Container.html" title="java.awt 中的类">Container</A>&nbsp;host)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;为指定的 <code>Container</code> 创建 <code>GroupLayout</code>。</TD>
</TR>
</TABLE>
&nbsp;
<!-- ========== METHOD SUMMARY =========== -->

<A NAME="method_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>方法摘要</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/GroupLayout.html#addLayoutComponent(java.awt.Component, java.lang.Object)">addLayoutComponent</A></B>(<A HREF="../../java/awt/Component.html" title="java.awt 中的类">Component</A>&nbsp;component,
                   <A HREF="../../java/lang/Object.html" title="java.lang 中的类">Object</A>&nbsp;constraints)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;已将 <code>Component</code> 添加到父容器的通知。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/GroupLayout.html#addLayoutComponent(java.lang.String, java.awt.Component)">addLayoutComponent</A></B>(<A HREF="../../java/lang/String.html" title="java.lang 中的类">String</A>&nbsp;name,
                   <A HREF="../../java/awt/Component.html" title="java.awt 中的类">Component</A>&nbsp;component)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;已将 <code>Component</code> 添加到父容器的通知。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../javax/swing/GroupLayout.ParallelGroup.html" title="javax.swing 中的类">GroupLayout.ParallelGroup</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/GroupLayout.html#createBaselineGroup(boolean, boolean)">createBaselineGroup</A></B>(boolean&nbsp;resizable,
                    boolean&nbsp;anchorBaselineToTop)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;创建并返回一个沿基线对齐其元素的 <code>ParallelGroup</code>。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../javax/swing/GroupLayout.ParallelGroup.html" title="javax.swing 中的类">GroupLayout.ParallelGroup</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/GroupLayout.html#createParallelGroup()">createParallelGroup</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;使用 <code>Alignment.LEADING</code> 的对齐方式创建并返回一个 <code>ParallelGroup</code>。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../javax/swing/GroupLayout.ParallelGroup.html" title="javax.swing 中的类">GroupLayout.ParallelGroup</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/GroupLayout.html#createParallelGroup(javax.swing.GroupLayout.Alignment)">createParallelGroup</A></B>(<A HREF="../../javax/swing/GroupLayout.Alignment.html" title="javax.swing 中的枚举">GroupLayout.Alignment</A>&nbsp;alignment)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;使用指定的对齐方式创建并返回一个 <code>ParallelGroup</code>。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../javax/swing/GroupLayout.ParallelGroup.html" title="javax.swing 中的类">GroupLayout.ParallelGroup</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/GroupLayout.html#createParallelGroup(javax.swing.GroupLayout.Alignment, boolean)">createParallelGroup</A></B>(<A HREF="../../javax/swing/GroupLayout.Alignment.html" title="javax.swing 中的枚举">GroupLayout.Alignment</A>&nbsp;alignment,
                    boolean&nbsp;resizable)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;使用指定的对齐方式和调整大小行为创建并返回一个 <code>ParallelGroup</code>。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../javax/swing/GroupLayout.SequentialGroup.html" title="javax.swing 中的类">GroupLayout.SequentialGroup</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/GroupLayout.html#createSequentialGroup()">createSequentialGroup</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;创建并返回一个 <code>SequentialGroup</code>。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/GroupLayout.html#getAutoCreateContainerGaps()">getAutoCreateContainerGaps</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果自动创建容器与触到容器边框的组件之间的间隙，则返回 <code>true</code>。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/GroupLayout.html#getAutoCreateGaps()">getAutoCreateGaps</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果自动创建组件之间的间隙，则返回 <code>true</code>。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/GroupLayout.html#getHonorsVisibility()">getHonorsVisibility</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;返回确定组件的大小和位置时是否要考虑组件的可见性。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;float</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/GroupLayout.html#getLayoutAlignmentX(java.awt.Container)">getLayoutAlignmentX</A></B>(<A HREF="../../java/awt/Container.html" title="java.awt 中的类">Container</A>&nbsp;parent)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;返回沿 x 轴的对齐方式。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;float</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/GroupLayout.html#getLayoutAlignmentY(java.awt.Container)">getLayoutAlignmentY</A></B>(<A HREF="../../java/awt/Container.html" title="java.awt 中的类">Container</A>&nbsp;parent)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;返回沿 y 轴的对齐方式。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../javax/swing/LayoutStyle.html" title="javax.swing 中的类">LayoutStyle</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/GroupLayout.html#getLayoutStyle()">getLayoutStyle</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;返回 <code>LayoutStyle</code>，用于计算组件之间的首选间隙。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/GroupLayout.html#invalidateLayout(java.awt.Container)">invalidateLayout</A></B>(<A HREF="../../java/awt/Container.html" title="java.awt 中的类">Container</A>&nbsp;parent)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;使布局失效，指示如果布局管理器缓存了信息，则应该将其丢弃。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/GroupLayout.html#layoutContainer(java.awt.Container)">layoutContainer</A></B>(<A HREF="../../java/awt/Container.html" title="java.awt 中的类">Container</A>&nbsp;parent)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;布置指定的容器。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/GroupLayout.html#linkSize(java.awt.Component...)">linkSize</A></B>(<A HREF="../../java/awt/Component.html" title="java.awt 中的类">Component</A>...&nbsp;components)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;将指定组件强制调整为具有相同的大小，而不管其首选大小、最小大小或最大大小如何。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/GroupLayout.html#linkSize(int, java.awt.Component...)">linkSize</A></B>(int&nbsp;axis,
         <A HREF="../../java/awt/Component.html" title="java.awt 中的类">Component</A>...&nbsp;components)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;将指定组件强制调整为沿指定轴具有相同的大小，而不管其首选大小、最小大小或最大大小如何。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/awt/Dimension.html" title="java.awt 中的类">Dimension</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/GroupLayout.html#maximumLayoutSize(java.awt.Container)">maximumLayoutSize</A></B>(<A HREF="../../java/awt/Container.html" title="java.awt 中的类">Container</A>&nbsp;parent)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;返回指定容器的最大大小。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/awt/Dimension.html" title="java.awt 中的类">Dimension</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/GroupLayout.html#minimumLayoutSize(java.awt.Container)">minimumLayoutSize</A></B>(<A HREF="../../java/awt/Container.html" title="java.awt 中的类">Container</A>&nbsp;parent)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;返回指定容器的最小大小。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/awt/Dimension.html" title="java.awt 中的类">Dimension</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/GroupLayout.html#preferredLayoutSize(java.awt.Container)">preferredLayoutSize</A></B>(<A HREF="../../java/awt/Container.html" title="java.awt 中的类">Container</A>&nbsp;parent)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;返回指定容器的首选大小。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/GroupLayout.html#removeLayoutComponent(java.awt.Component)">removeLayoutComponent</A></B>(<A HREF="../../java/awt/Component.html" title="java.awt 中的类">Component</A>&nbsp;component)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;已从父容器中移除 <code>Component</code> 的通知。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/GroupLayout.html#replace(java.awt.Component, java.awt.Component)">replace</A></B>(<A HREF="../../java/awt/Component.html" title="java.awt 中的类">Component</A>&nbsp;existingComponent,
        <A HREF="../../java/awt/Component.html" title="java.awt 中的类">Component</A>&nbsp;newComponent)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;使用新的组件替代现有组件。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/GroupLayout.html#setAutoCreateContainerGaps(boolean)">setAutoCreateContainerGaps</A></B>(boolean&nbsp;autoCreateContainerPadding)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;设置是否应该自动创建容器与触到容器边框的组件之间的间隙。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/GroupLayout.html#setAutoCreateGaps(boolean)">setAutoCreateGaps</A></B>(boolean&nbsp;autoCreatePadding)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;设置是否将自动创建组件之间的间隙。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/GroupLayout.html#setHonorsVisibility(boolean)">setHonorsVisibility</A></B>(boolean&nbsp;honorsVisibility)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;设置确定组件的大小和位置时是否要考虑组件的可见性。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/GroupLayout.html#setHonorsVisibility(java.awt.Component, java.lang.Boolean)">setHonorsVisibility</A></B>(<A HREF="../../java/awt/Component.html" title="java.awt 中的类">Component</A>&nbsp;component,
                    <A HREF="../../java/lang/Boolean.html" title="java.lang 中的类">Boolean</A>&nbsp;honorsVisibility)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;设置确定组件的大小和位置时是否要考虑组件的可见性。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/GroupLayout.html#setHorizontalGroup(javax.swing.GroupLayout.Group)">setHorizontalGroup</A></B>(<A HREF="../../javax/swing/GroupLayout.Group.html" title="javax.swing 中的类">GroupLayout.Group</A>&nbsp;group)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;设置沿水平轴确定组件位置和大小的 <code>Group</code>。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/GroupLayout.html#setLayoutStyle(javax.swing.LayoutStyle)">setLayoutStyle</A></B>(<A HREF="../../javax/swing/LayoutStyle.html" title="javax.swing 中的类">LayoutStyle</A>&nbsp;layoutStyle)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;设置用于计算组件之间首选间隙的 <code>LayoutStyle</code>。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/GroupLayout.html#setVerticalGroup(javax.swing.GroupLayout.Group)">setVerticalGroup</A></B>(<A HREF="../../javax/swing/GroupLayout.Group.html" title="javax.swing 中的类">GroupLayout.Group</A>&nbsp;group)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;设置沿垂直轴确定组件位置和大小的 <code>Group</code>。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/lang/String.html" title="java.lang 中的类">String</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/GroupLayout.html#toString()">toString</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;返回此 <code>GroupLayout</code> 的字符串表示形式。</TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_java.lang.Object"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>从类 java.lang.<A HREF="../../java/lang/Object.html" title="java.lang 中的类">Object</A> 继承的方法</B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><A HREF="../../java/lang/Object.html#clone()">clone</A>, <A HREF="../../java/lang/Object.html#equals(java.lang.Object)">equals</A>, <A HREF="../../java/lang/Object.html#finalize()">finalize</A>, <A HREF="../../java/lang/Object.html#getClass()">getClass</A>, <A HREF="../../java/lang/Object.html#hashCode()">hashCode</A>, <A HREF="../../java/lang/Object.html#notify()">notify</A>, <A HREF="../../java/lang/Object.html#notifyAll()">notifyAll</A>, <A HREF="../../java/lang/Object.html#wait()">wait</A>, <A HREF="../../java/lang/Object.html#wait(long)">wait</A>, <A HREF="../../java/lang/Object.html#wait(long, int)">wait</A></CODE></TD>
</TR>
</TABLE>
&nbsp;
<P>

<!-- ============ FIELD DETAIL =========== -->

<A NAME="field_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>字段详细信息</B></FONT></TH>
</TR>
</TABLE>

<A NAME="DEFAULT_SIZE"><!-- --></A><H3>
DEFAULT_SIZE</H3>
<PRE>
public static final int <B>DEFAULT_SIZE</B></PRE>
<DL>
<DD>指示组件或间隙的大小应该用于特定的范围值。
<P>
<DL>
<DT><B>另请参见：</B><DD><A HREF="../../javax/swing/GroupLayout.Group.html" title="javax.swing 中的类"><CODE>GroupLayout.Group</CODE></A>, 
<A HREF="../../constant-values.html#javax.swing.GroupLayout.DEFAULT_SIZE">常量字段值</A></DL>
</DL>
<HR>

<A NAME="PREFERRED_SIZE"><!-- --></A><H3>
PREFERRED_SIZE</H3>
<PRE>
public static final int <B>PREFERRED_SIZE</B></PRE>
<DL>
<DD>指示组件或间隙的首选大小应该用于特定的范围值。
<P>
<DL>
<DT><B>另请参见：</B><DD><A HREF="../../javax/swing/GroupLayout.Group.html" title="javax.swing 中的类"><CODE>GroupLayout.Group</CODE></A>, 
<A HREF="../../constant-values.html#javax.swing.GroupLayout.PREFERRED_SIZE">常量字段值</A></DL>
</DL>

<!-- ========= CONSTRUCTOR DETAIL ======== -->

<A NAME="constructor_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>构造方法详细信息</B></FONT></TH>
</TR>
</TABLE>

<A NAME="GroupLayout(java.awt.Container)"><!-- --></A><H3>
GroupLayout</H3>
<PRE>
public <B>GroupLayout</B>(<A HREF="../../java/awt/Container.html" title="java.awt 中的类">Container</A>&nbsp;host)</PRE>
<DL>
<DD>为指定的 <code>Container</code> 创建 <code>GroupLayout</code>。
<P>
<DL>
<DT><B>参数：</B><DD><CODE>host</CODE> - <code>Container</code>，创建的 <code>GroupLayout</code> 将作为其 <code>LayoutManager</code>
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../java/lang/IllegalArgumentException.html" title="java.lang 中的类">IllegalArgumentException</A></CODE> - 如果 host 为 <code>null</code></DL>
</DL>

<!-- ============ METHOD DETAIL ========== -->

<A NAME="method_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>方法详细信息</B></FONT></TH>
</TR>
</TABLE>

<A NAME="setHonorsVisibility(boolean)"><!-- --></A><H3>
setHonorsVisibility</H3>
<PRE>
public void <B>setHonorsVisibility</B>(boolean&nbsp;honorsVisibility)</PRE>
<DL>
<DD>设置确定组件的大小和位置时是否要考虑组件的可见性。<code>true</code> 值指示非可见组件不应该被视为布局的一部分。<code>false</code> 值指示组件应该被确定位置和大小，而不管其可见性如何。
 <p>
当组件的可见性是动态调整的并且不想更改周围的组件及其大小时，<code>false</code> 值很有用。
 <p>
指定的值用于没有指定明确可见性的组件。
 <p>
默认值为 <code>true</code>。
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>参数：</B><DD><CODE>honorsVisibility</CODE> - 确定组件的大小和位置时是否要考虑组件的可见性<DT><B>另请参见：</B><DD><A HREF="../../javax/swing/GroupLayout.html#setHonorsVisibility(java.awt.Component, java.lang.Boolean)"><CODE>setHonorsVisibility(Component,Boolean)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="getHonorsVisibility()"><!-- --></A><H3>
getHonorsVisibility</H3>
<PRE>
public boolean <B>getHonorsVisibility</B>()</PRE>
<DL>
<DD>返回确定组件的大小和位置时是否要考虑组件的可见性。
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>返回：</B><DD>确定组件的大小和位置时是否要考虑组件的可见性</DL>
</DD>
</DL>
<HR>

<A NAME="setHonorsVisibility(java.awt.Component, java.lang.Boolean)"><!-- --></A><H3>
setHonorsVisibility</H3>
<PRE>
public void <B>setHonorsVisibility</B>(<A HREF="../../java/awt/Component.html" title="java.awt 中的类">Component</A>&nbsp;component,
                                <A HREF="../../java/lang/Boolean.html" title="java.lang 中的类">Boolean</A>&nbsp;honorsVisibility)</PRE>
<DL>
<DD>设置确定组件的大小和位置时是否要考虑组件的可见性。<code>Boolean.TRUE</code> 值指示如果 <code>component</code> 不可见，则它不应该被视为布局的一部分。<code>false</code> 值指示 <code>component</code> 应该被确定位置和大小，而不管其可见性如何。<code>null</code> 值指示应该使用由单参数方法 <code>setHonorsVisibility</code> 指定的值。
 <p>
如果 <code>component</code> 不是此 <code>GroupLayout</code> 管理的 <code>Container</code> 的子组件，则它将被添加到 <code>Container</code>。
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>参数：</B><DD><CODE>component</CODE> - 组件<DD><CODE>honorsVisibility</CODE> - 确定大小和位置时是否要考虑 <code>component</code> 的可见性
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../java/lang/IllegalArgumentException.html" title="java.lang 中的类">IllegalArgumentException</A></CODE> - 如果 <code>component</code> 为 <code>null</code><DT><B>另请参见：</B><DD><A HREF="../../javax/swing/GroupLayout.html#setHonorsVisibility(java.awt.Component, java.lang.Boolean)"><CODE>setHonorsVisibility(Component,Boolean)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="setAutoCreateGaps(boolean)"><!-- --></A><H3>
setAutoCreateGaps</H3>
<PRE>
public void <B>setAutoCreateGaps</B>(boolean&nbsp;autoCreatePadding)</PRE>
<DL>
<DD>设置是否将自动创建组件之间的间隙。例如，如果设为 <code>true</code> 并且向 <code>SequentialGroup</code> 添加了两个组件，则将自动创建这两个组件之间的间隙。默认值为 <code>false</code>。
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>参数：</B><DD><CODE>autoCreatePadding</CODE> - 是否自动创建组件之间的间隙</DL>
</DD>
</DL>
<HR>

<A NAME="getAutoCreateGaps()"><!-- --></A><H3>
getAutoCreateGaps</H3>
<PRE>
public boolean <B>getAutoCreateGaps</B>()</PRE>
<DL>
<DD>如果自动创建组件之间的间隙，则返回 <code>true</code>。
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>返回：</B><DD>如果自动创建组件之间的间隙，则返回 <code>true</code></DL>
</DD>
</DL>
<HR>

<A NAME="setAutoCreateContainerGaps(boolean)"><!-- --></A><H3>
setAutoCreateContainerGaps</H3>
<PRE>
public void <B>setAutoCreateContainerGaps</B>(boolean&nbsp;autoCreateContainerPadding)</PRE>
<DL>
<DD>设置是否应该自动创建容器与触到容器边框的组件之间的间隙。默认值为 <code>false</code>。
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>参数：</B><DD><CODE>autoCreateContainerPadding</CODE> - 是否应该自动创建容器与触到容器边框的组件之间的间隙</DL>
</DD>
</DL>
<HR>

<A NAME="getAutoCreateContainerGaps()"><!-- --></A><H3>
getAutoCreateContainerGaps</H3>
<PRE>
public boolean <B>getAutoCreateContainerGaps</B>()</PRE>
<DL>
<DD>如果自动创建容器与触到容器边框的组件之间的间隙，则返回 <code>true</code>。
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>返回：</B><DD>如果自动创建容器与触到容器边框的组件之间的间隙，则返回 <code>true</code></DL>
</DD>
</DL>
<HR>

<A NAME="setHorizontalGroup(javax.swing.GroupLayout.Group)"><!-- --></A><H3>
setHorizontalGroup</H3>
<PRE>
public void <B>setHorizontalGroup</B>(<A HREF="../../javax/swing/GroupLayout.Group.html" title="javax.swing 中的类">GroupLayout.Group</A>&nbsp;group)</PRE>
<DL>
<DD>设置沿水平轴确定组件位置和大小的 <code>Group</code>。
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>参数：</B><DD><CODE>group</CODE> - 沿水平轴确定组件位置和大小的 <code>Group</code>
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../java/lang/IllegalArgumentException.html" title="java.lang 中的类">IllegalArgumentException</A></CODE> - 如果 group 为 <code>null</code></DL>
</DD>
</DL>
<HR>

<A NAME="setVerticalGroup(javax.swing.GroupLayout.Group)"><!-- --></A><H3>
setVerticalGroup</H3>
<PRE>
public void <B>setVerticalGroup</B>(<A HREF="../../javax/swing/GroupLayout.Group.html" title="javax.swing 中的类">GroupLayout.Group</A>&nbsp;group)</PRE>
<DL>
<DD>设置沿垂直轴确定组件位置和大小的 <code>Group</code>。
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>参数：</B><DD><CODE>group</CODE> - 沿垂直轴确定组件位置和大小的 <code>Group</code>
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../java/lang/IllegalArgumentException.html" title="java.lang 中的类">IllegalArgumentException</A></CODE> - 如果 group 为 <code>null</code></DL>
</DD>
</DL>
<HR>

<A NAME="createSequentialGroup()"><!-- --></A><H3>
createSequentialGroup</H3>
<PRE>
public <A HREF="../../javax/swing/GroupLayout.SequentialGroup.html" title="javax.swing 中的类">GroupLayout.SequentialGroup</A> <B>createSequentialGroup</B>()</PRE>
<DL>
<DD>创建并返回一个 <code>SequentialGroup</code>。
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>返回：</B><DD>一个新的 <code>SequentialGroup</code></DL>
</DD>
</DL>
<HR>

<A NAME="createParallelGroup()"><!-- --></A><H3>
createParallelGroup</H3>
<PRE>
public <A HREF="../../javax/swing/GroupLayout.ParallelGroup.html" title="javax.swing 中的类">GroupLayout.ParallelGroup</A> <B>createParallelGroup</B>()</PRE>
<DL>
<DD>使用 <code>Alignment.LEADING</code> 的对齐方式创建并返回一个 <code>ParallelGroup</code>。此方法是更常用的 <code>createParallelGroup(Alignment)</code> 方法的覆盖方法。
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>返回：</B><DD>一个新的 <code>ParallelGroup</code><DT><B>另请参见：</B><DD><A HREF="../../javax/swing/GroupLayout.html#createParallelGroup(javax.swing.GroupLayout.Alignment)"><CODE>createParallelGroup(Alignment)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="createParallelGroup(javax.swing.GroupLayout.Alignment)"><!-- --></A><H3>
createParallelGroup</H3>
<PRE>
public <A HREF="../../javax/swing/GroupLayout.ParallelGroup.html" title="javax.swing 中的类">GroupLayout.ParallelGroup</A> <B>createParallelGroup</B>(<A HREF="../../javax/swing/GroupLayout.Alignment.html" title="javax.swing 中的枚举">GroupLayout.Alignment</A>&nbsp;alignment)</PRE>
<DL>
<DD>使用指定的对齐方式创建并返回一个 <code>ParallelGroup</code>。此方法是更常用的 <code>createParallelGroup(Alignment,boolean)</code> 方法（其中第二个参数为 <code>true</code>）的覆盖方法。
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>参数：</B><DD><CODE>alignment</CODE> - 组元素的对齐方式
<DT><B>返回：</B><DD>一个新的 <code>ParallelGroup</code>
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../java/lang/IllegalArgumentException.html" title="java.lang 中的类">IllegalArgumentException</A></CODE> - 如果 <code>alignment</code> 为 <code>null</code><DT><B>另请参见：</B><DD><A HREF="../../javax/swing/GroupLayout.html#createBaselineGroup(boolean, boolean)"><CODE>createBaselineGroup(boolean, boolean)</CODE></A>, 
<A HREF="../../javax/swing/GroupLayout.ParallelGroup.html" title="javax.swing 中的类"><CODE>GroupLayout.ParallelGroup</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="createParallelGroup(javax.swing.GroupLayout.Alignment, boolean)"><!-- --></A><H3>
createParallelGroup</H3>
<PRE>
public <A HREF="../../javax/swing/GroupLayout.ParallelGroup.html" title="javax.swing 中的类">GroupLayout.ParallelGroup</A> <B>createParallelGroup</B>(<A HREF="../../javax/swing/GroupLayout.Alignment.html" title="javax.swing 中的枚举">GroupLayout.Alignment</A>&nbsp;alignment,
                                                     boolean&nbsp;resizable)</PRE>
<DL>
<DD>使用指定的对齐方式和调整大小行为创建并返回一个 <code>ParallelGroup</code>。<code>alignment</code> 参数指定如何确定没有将组填满的子元素的位置。例如，如果对齐方式为 <code>TRAILING</code> 的 <code>ParallelGroup</code> 被给定为 100，而一个子元素只需要 50，则将该子元素放置在位置 50（组件方向从左到右）。
 <p>
只有在沿垂直轴使用时基线对齐方式才有用。使用沿水平轴的基线对齐方式创建的 <code>ParallelGroup</code> 被视为 <code>LEADING</code>。
 <p>
有关基线组行为的详细信息，请参阅 <A HREF="../../javax/swing/GroupLayout.ParallelGroup.html" title="javax.swing 中的类"><CODE>ParallelGroup</CODE></A>。
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>参数：</B><DD><CODE>alignment</CODE> - 组元素的对齐方式<DD><CODE>resizable</CODE> - 如果组是可调整大小的，则返回 <code>true</code>；如果组是不可调整大小的，则首选大小用于组的最小大小和最大大小。
<DT><B>返回：</B><DD>一个新的 <code>ParallelGroup</code>
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../java/lang/IllegalArgumentException.html" title="java.lang 中的类">IllegalArgumentException</A></CODE> - 如果 <code>alignment</code> 为 <code>null</code><DT><B>另请参见：</B><DD><A HREF="../../javax/swing/GroupLayout.html#createBaselineGroup(boolean, boolean)"><CODE>createBaselineGroup(boolean, boolean)</CODE></A>, 
<A HREF="../../javax/swing/GroupLayout.ParallelGroup.html" title="javax.swing 中的类"><CODE>GroupLayout.ParallelGroup</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="createBaselineGroup(boolean, boolean)"><!-- --></A><H3>
createBaselineGroup</H3>
<PRE>
public <A HREF="../../javax/swing/GroupLayout.ParallelGroup.html" title="javax.swing 中的类">GroupLayout.ParallelGroup</A> <B>createBaselineGroup</B>(boolean&nbsp;resizable,
                                                     boolean&nbsp;anchorBaselineToTop)</PRE>
<DL>
<DD>创建并返回一个沿基线对齐其元素的 <code>ParallelGroup</code>。
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>参数：</B><DD><CODE>resizable</CODE> - 组是否是可调整大小的<DD><CODE>anchorBaselineToTop</CODE> - 基线是固定在组的顶部还是底部<DT><B>另请参见：</B><DD><A HREF="../../javax/swing/GroupLayout.html#createBaselineGroup(boolean, boolean)"><CODE>createBaselineGroup(boolean, boolean)</CODE></A>, 
<A HREF="../../javax/swing/GroupLayout.ParallelGroup.html" title="javax.swing 中的类"><CODE>GroupLayout.ParallelGroup</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="linkSize(java.awt.Component...)"><!-- --></A><H3>
linkSize</H3>
<PRE>
public void <B>linkSize</B>(<A HREF="../../java/awt/Component.html" title="java.awt 中的类">Component</A>...&nbsp;components)</PRE>
<DL>
<DD>将指定组件强制调整为具有相同的大小，而不管其首选大小、最小大小或最大大小如何。将所有链接组件首选大小中的最大值赋予链接的组件。例如，如果将首选宽度分别为 10 和 20 的两个组件链接起来，则两个组件的宽度都将变为 20。
 <p>
可以多次使用此方法来将任意数量的组件强制调整为具有相同的大小。
 <p>
链接的 Component 是不可调整大小的。
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>参数：</B><DD><CODE>components</CODE> - 要具有相同大小的 <code>Component</code>
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../java/lang/IllegalArgumentException.html" title="java.lang 中的类">IllegalArgumentException</A></CODE> - 如果 <code>components</code> 为 <code>null</code> 或包含 <code>null</code><DT><B>另请参见：</B><DD><A HREF="../../javax/swing/GroupLayout.html#linkSize(int, java.awt.Component...)"><CODE>linkSize(int,Component[])</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="linkSize(int, java.awt.Component...)"><!-- --></A><H3>
linkSize</H3>
<PRE>
public void <B>linkSize</B>(int&nbsp;axis,
                     <A HREF="../../java/awt/Component.html" title="java.awt 中的类">Component</A>...&nbsp;components)</PRE>
<DL>
<DD>将指定组件强制调整为沿指定轴具有相同的大小，而不管其首选大小、最小大小或最大大小如何。将所有链接组件首选大小中的最大值赋予链接的组件。例如，如果沿水平轴将首选宽度分别为 10 和 20 的两个组件链接起来，则两个组件的宽度都将变为 20。
 <p>
可以多次使用此方法来将任意数量的组件强制调整为具有相同的大小。
 <p>
链接的 <code>Component</code> 是不可调整大小的。
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>参数：</B><DD><CODE>components</CODE> - 要具有相同大小的 <code>Component</code><DD><CODE>axis</CODE> - 沿其链接大小的轴；<code>SwingConstants.HORIZONTAL</code> 或 <code>SwingConstans.VERTICAL</code> 之一
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../java/lang/IllegalArgumentException.html" title="java.lang 中的类">IllegalArgumentException</A></CODE> - 如果 <code>components</code> 为 <code>null</code> 或包含 <code>null</code>；或者 <code>axis</code> 不是 <code>SwingConstants.HORIZONTAL</code> 或 <code>SwingConstants.VERTICAL</code></DL>
</DD>
</DL>
<HR>

<A NAME="replace(java.awt.Component, java.awt.Component)"><!-- --></A><H3>
replace</H3>
<PRE>
public void <B>replace</B>(<A HREF="../../java/awt/Component.html" title="java.awt 中的类">Component</A>&nbsp;existingComponent,
                    <A HREF="../../java/awt/Component.html" title="java.awt 中的类">Component</A>&nbsp;newComponent)</PRE>
<DL>
<DD>使用新的组件替代现有组件。
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>参数：</B><DD><CODE>existingComponent</CODE> - 应该被移除并用 <code>newComponent</code> 来替代的组件<DD><CODE>newComponent</CODE> - 要放入 <code>existingComponent</code> 的位置的组件
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../java/lang/IllegalArgumentException.html" title="java.lang 中的类">IllegalArgumentException</A></CODE> - 如果任一组件为 <code>null</code> 或者 <code>existingComponent</code> 不受此布局管理器管理</DL>
</DD>
</DL>
<HR>

<A NAME="setLayoutStyle(javax.swing.LayoutStyle)"><!-- --></A><H3>
setLayoutStyle</H3>
<PRE>
public void <B>setLayoutStyle</B>(<A HREF="../../javax/swing/LayoutStyle.html" title="javax.swing 中的类">LayoutStyle</A>&nbsp;layoutStyle)</PRE>
<DL>
<DD>设置用于计算组件之间首选间隙的 <code>LayoutStyle</code>。<code>null</code> 值指示应该使用 <code>LayoutStyle</code> 的共享实例。
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>参数：</B><DD><CODE>layoutStyle</CODE> - 要使用的 <code>LayoutStyle</code><DT><B>另请参见：</B><DD><A HREF="../../javax/swing/LayoutStyle.html" title="javax.swing 中的类"><CODE>LayoutStyle</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="getLayoutStyle()"><!-- --></A><H3>
getLayoutStyle</H3>
<PRE>
public <A HREF="../../javax/swing/LayoutStyle.html" title="javax.swing 中的类">LayoutStyle</A> <B>getLayoutStyle</B>()</PRE>
<DL>
<DD>返回 <code>LayoutStyle</code>，用于计算组件之间的首选间隙。此方法返回指定给 <code>setLayoutStyle</code> 的值，可以为 <code>null</code>。
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>返回：</B><DD>用于计算组件之间首选间隙的 <code>LayoutStyle</code></DL>
</DD>
</DL>
<HR>

<A NAME="addLayoutComponent(java.lang.String, java.awt.Component)"><!-- --></A><H3>
addLayoutComponent</H3>
<PRE>
public void <B>addLayoutComponent</B>(<A HREF="../../java/lang/String.html" title="java.lang 中的类">String</A>&nbsp;name,
                               <A HREF="../../java/awt/Component.html" title="java.awt 中的类">Component</A>&nbsp;component)</PRE>
<DL>
<DD>已将 <code>Component</code> 添加到父容器的通知。不应该直接调用此方法，而应该使用一个 <code>Group</code> 方法来添加 <code>Component</code>。
<P>
<DD><DL>
<DT><B>指定者：</B><DD>接口 <CODE><A HREF="../../java/awt/LayoutManager.html" title="java.awt 中的接口">LayoutManager</A></CODE> 中的 <CODE><A HREF="../../java/awt/LayoutManager.html#addLayoutComponent(java.lang.String, java.awt.Component)">addLayoutComponent</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>参数：</B><DD><CODE>name</CODE> - 要与组件关联的字符串<DD><CODE>component</CODE> - 要添加的 <code>Component</code></DL>
</DD>
</DL>
<HR>

<A NAME="removeLayoutComponent(java.awt.Component)"><!-- --></A><H3>
removeLayoutComponent</H3>
<PRE>
public void <B>removeLayoutComponent</B>(<A HREF="../../java/awt/Component.html" title="java.awt 中的类">Component</A>&nbsp;component)</PRE>
<DL>
<DD>已从父容器中移除 <code>Component</code> 的通知。不应该直接调用此方法，而应该调用父 <code>Container</code> 上的 <code>remove</code>。
<P>
<DD><DL>
<DT><B>指定者：</B><DD>接口 <CODE><A HREF="../../java/awt/LayoutManager.html" title="java.awt 中的接口">LayoutManager</A></CODE> 中的 <CODE><A HREF="../../java/awt/LayoutManager.html#removeLayoutComponent(java.awt.Component)">removeLayoutComponent</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>参数：</B><DD><CODE>component</CODE> - 要移除的组件<DT><B>另请参见：</B><DD><A HREF="../../java/awt/Component.html#remove(java.awt.MenuComponent)"><CODE>Component.remove(java.awt.MenuComponent)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="preferredLayoutSize(java.awt.Container)"><!-- --></A><H3>
preferredLayoutSize</H3>
<PRE>
public <A HREF="../../java/awt/Dimension.html" title="java.awt 中的类">Dimension</A> <B>preferredLayoutSize</B>(<A HREF="../../java/awt/Container.html" title="java.awt 中的类">Container</A>&nbsp;parent)</PRE>
<DL>
<DD>返回指定容器的首选大小。
<P>
<DD><DL>
<DT><B>指定者：</B><DD>接口 <CODE><A HREF="../../java/awt/LayoutManager.html" title="java.awt 中的接口">LayoutManager</A></CODE> 中的 <CODE><A HREF="../../java/awt/LayoutManager.html#preferredLayoutSize(java.awt.Container)">preferredLayoutSize</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>参数：</B><DD><CODE>parent</CODE> - 要返回其首选大小的容器
<DT><B>返回：</B><DD><code>parent</code> 的首选大小
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../java/lang/IllegalArgumentException.html" title="java.lang 中的类">IllegalArgumentException</A></CODE> - 如果 <code>parent</code> 不是创建此 GroupLayout 的相同 <code>Container</code>
<DD><CODE><A HREF="../../java/lang/IllegalStateException.html" title="java.lang 中的类">IllegalStateException</A></CODE> - 如果添加到此布局的任意组件不同时位于水平组和垂直组中<DT><B>另请参见：</B><DD><A HREF="../../java/awt/Container.html#getPreferredSize()"><CODE>Container.getPreferredSize()</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="minimumLayoutSize(java.awt.Container)"><!-- --></A><H3>
minimumLayoutSize</H3>
<PRE>
public <A HREF="../../java/awt/Dimension.html" title="java.awt 中的类">Dimension</A> <B>minimumLayoutSize</B>(<A HREF="../../java/awt/Container.html" title="java.awt 中的类">Container</A>&nbsp;parent)</PRE>
<DL>
<DD>返回指定容器的最小大小。
<P>
<DD><DL>
<DT><B>指定者：</B><DD>接口 <CODE><A HREF="../../java/awt/LayoutManager.html" title="java.awt 中的接口">LayoutManager</A></CODE> 中的 <CODE><A HREF="../../java/awt/LayoutManager.html#minimumLayoutSize(java.awt.Container)">minimumLayoutSize</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>参数：</B><DD><CODE>parent</CODE> - 要返回其大小的容器
<DT><B>返回：</B><DD><code>parent</code> 的最小大小
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../java/lang/IllegalArgumentException.html" title="java.lang 中的类">IllegalArgumentException</A></CODE> - 如果 <code>parent</code> 不是创建此 GroupLayout 的相同 <code>Container</code>
<DD><CODE><A HREF="../../java/lang/IllegalStateException.html" title="java.lang 中的类">IllegalStateException</A></CODE> - 如果添加到此布局的任意组件不同时位于水平组和垂直组中<DT><B>另请参见：</B><DD><A HREF="../../java/awt/Container.html#getMinimumSize()"><CODE>Container.getMinimumSize()</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="layoutContainer(java.awt.Container)"><!-- --></A><H3>
layoutContainer</H3>
<PRE>
public void <B>layoutContainer</B>(<A HREF="../../java/awt/Container.html" title="java.awt 中的类">Container</A>&nbsp;parent)</PRE>
<DL>
<DD>布置指定的容器。
<P>
<DD><DL>
<DT><B>指定者：</B><DD>接口 <CODE><A HREF="../../java/awt/LayoutManager.html" title="java.awt 中的接口">LayoutManager</A></CODE> 中的 <CODE><A HREF="../../java/awt/LayoutManager.html#layoutContainer(java.awt.Container)">layoutContainer</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>参数：</B><DD><CODE>parent</CODE> - 要布置的容器
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../java/lang/IllegalStateException.html" title="java.lang 中的类">IllegalStateException</A></CODE> - 如果添加到此布局的任意组件不同时位于水平组和垂直组中</DL>
</DD>
</DL>
<HR>

<A NAME="addLayoutComponent(java.awt.Component, java.lang.Object)"><!-- --></A><H3>
addLayoutComponent</H3>
<PRE>
public void <B>addLayoutComponent</B>(<A HREF="../../java/awt/Component.html" title="java.awt 中的类">Component</A>&nbsp;component,
                               <A HREF="../../java/lang/Object.html" title="java.lang 中的类">Object</A>&nbsp;constraints)</PRE>
<DL>
<DD>已将 <code>Component</code> 添加到父容器的通知。不应该直接调用此方法，而应该使用一个 <code>Group</code> 方法来添加 <code>Component</code>。
<P>
<DD><DL>
<DT><B>指定者：</B><DD>接口 <CODE><A HREF="../../java/awt/LayoutManager2.html" title="java.awt 中的接口">LayoutManager2</A></CODE> 中的 <CODE><A HREF="../../java/awt/LayoutManager2.html#addLayoutComponent(java.awt.Component, java.lang.Object)">addLayoutComponent</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>参数：</B><DD><CODE>component</CODE> - 要添加的组件<DD><CODE>constraints</CODE> - 组件放置位置的描述</DL>
</DD>
</DL>
<HR>

<A NAME="maximumLayoutSize(java.awt.Container)"><!-- --></A><H3>
maximumLayoutSize</H3>
<PRE>
public <A HREF="../../java/awt/Dimension.html" title="java.awt 中的类">Dimension</A> <B>maximumLayoutSize</B>(<A HREF="../../java/awt/Container.html" title="java.awt 中的类">Container</A>&nbsp;parent)</PRE>
<DL>
<DD>返回指定容器的最大大小。
<P>
<DD><DL>
<DT><B>指定者：</B><DD>接口 <CODE><A HREF="../../java/awt/LayoutManager2.html" title="java.awt 中的接口">LayoutManager2</A></CODE> 中的 <CODE><A HREF="../../java/awt/LayoutManager2.html#maximumLayoutSize(java.awt.Container)">maximumLayoutSize</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>参数：</B><DD><CODE>parent</CODE> - 要返回其大小的容器
<DT><B>返回：</B><DD><code>parent</code> 的最大大小
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../java/lang/IllegalArgumentException.html" title="java.lang 中的类">IllegalArgumentException</A></CODE> - 如果 <code>parent</code> 不是创建此 GroupLayout 的相同 <code>Container</code>
<DD><CODE><A HREF="../../java/lang/IllegalStateException.html" title="java.lang 中的类">IllegalStateException</A></CODE> - 如果添加到此布局的任意组件不同时位于水平组和垂直组中<DT><B>另请参见：</B><DD><A HREF="../../java/awt/Container.html#getMaximumSize()"><CODE>Container.getMaximumSize()</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="getLayoutAlignmentX(java.awt.Container)"><!-- --></A><H3>
getLayoutAlignmentX</H3>
<PRE>
public float <B>getLayoutAlignmentX</B>(<A HREF="../../java/awt/Container.html" title="java.awt 中的类">Container</A>&nbsp;parent)</PRE>
<DL>
<DD>返回沿 x 轴的对齐方式。此方法指出如何相对于其他组件对齐该组件。该值应该是 0 到 1 之间的一个数，其中 0 表示沿原点对齐，1 表示在距原点最远的地方对齐，0.5 表示居中等等。
<P>
<DD><DL>
<DT><B>指定者：</B><DD>接口 <CODE><A HREF="../../java/awt/LayoutManager2.html" title="java.awt 中的接口">LayoutManager2</A></CODE> 中的 <CODE><A HREF="../../java/awt/LayoutManager2.html#getLayoutAlignmentX(java.awt.Container)">getLayoutAlignmentX</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>参数：</B><DD><CODE>parent</CODE> - 应用此 <code>LayoutManager</code> 的 <code>Container</code>
<DT><B>返回：</B><DD>对齐方式；此实现返回 <code>0.5</code>
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../java/lang/IllegalArgumentException.html" title="java.lang 中的类">IllegalArgumentException</A></CODE> - 如果 <code>parent</code> 不是创建此 GroupLayout 的相同 <code>Container</code></DL>
</DD>
</DL>
<HR>

<A NAME="getLayoutAlignmentY(java.awt.Container)"><!-- --></A><H3>
getLayoutAlignmentY</H3>
<PRE>
public float <B>getLayoutAlignmentY</B>(<A HREF="../../java/awt/Container.html" title="java.awt 中的类">Container</A>&nbsp;parent)</PRE>
<DL>
<DD>返回沿 y 轴的对齐方式。此方法指出如何相对于其他组件对齐该组件。该值应该是 0 到 1 之间的一个数，其中 0 表示沿原点对齐，1 表示在距原点最远的地方对齐，0.5 表示居中等等。
<P>
<DD><DL>
<DT><B>指定者：</B><DD>接口 <CODE><A HREF="../../java/awt/LayoutManager2.html" title="java.awt 中的接口">LayoutManager2</A></CODE> 中的 <CODE><A HREF="../../java/awt/LayoutManager2.html#getLayoutAlignmentY(java.awt.Container)">getLayoutAlignmentY</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>参数：</B><DD><CODE>parent</CODE> - 应用此 <code>LayoutManager</code> 的 <code>Container</code>
<DT><B>返回：</B><DD>对齐方式；此实现返回 <code>0.5</code>
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../java/lang/IllegalArgumentException.html" title="java.lang 中的类">IllegalArgumentException</A></CODE> - 如果 <code>parent</code> 不是创建此 GroupLayout 的相同 <code>Container</code></DL>
</DD>
</DL>
<HR>

<A NAME="invalidateLayout(java.awt.Container)"><!-- --></A><H3>
invalidateLayout</H3>
<PRE>
public void <B>invalidateLayout</B>(<A HREF="../../java/awt/Container.html" title="java.awt 中的类">Container</A>&nbsp;parent)</PRE>
<DL>
<DD>使布局失效，指示如果布局管理器缓存了信息，则应该将其丢弃。
<P>
<DD><DL>
<DT><B>指定者：</B><DD>接口 <CODE><A HREF="../../java/awt/LayoutManager2.html" title="java.awt 中的接口">LayoutManager2</A></CODE> 中的 <CODE><A HREF="../../java/awt/LayoutManager2.html#invalidateLayout(java.awt.Container)">invalidateLayout</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>参数：</B><DD><CODE>parent</CODE> - 应用此 LayoutManager 的 <code>Container</code>
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../java/lang/IllegalArgumentException.html" title="java.lang 中的类">IllegalArgumentException</A></CODE> - 如果 <code>parent</code> 不是创建此 GroupLayout 的相同 <code>Container</code></DL>
</DD>
</DL>
<HR>

<A NAME="toString()"><!-- --></A><H3>
toString</H3>
<PRE>
public <A HREF="../../java/lang/String.html" title="java.lang 中的类">String</A> <B>toString</B>()</PRE>
<DL>
<DD>返回此 <code>GroupLayout</code> 的字符串表示形式。此方法仅用于调试，对于各个实现，所返回字符串的内容和格式可能有所不同。
<P>
<DD><DL>
<DT><B>覆盖：</B><DD>类 <CODE><A HREF="../../java/lang/Object.html" title="java.lang 中的类">Object</A></CODE> 中的 <CODE><A HREF="../../java/lang/Object.html#toString()">toString</A></CODE></DL>
</DD>
<DD><DL>

<DT><B>返回：</B><DD>此 <code>GroupLayout</code> 的字符串表示形式</DL>
</DD>
</DL>
<!-- ========= END OF CLASS DATA ========= -->
<HR>


<!-- ======= START OF BOTTOM NAVBAR ====== -->
<A NAME="navbar_bottom"><!-- --></A>
<A HREF="#skip-navbar_bottom" title="跳过导航链接"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>概述</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>软件包</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>类</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/GroupLayout.html"><FONT CLASS="NavBarFont1"><B>使用</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>树</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>已过时</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>索引</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../help-doc.html"><FONT CLASS="NavBarFont1"><B>帮助</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
<b>Java<sup><font size=-2>TM</font></sup>&nbsp;Platform<br>Standard&nbsp;Ed. 6</b></EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../javax/swing/GrayFilter.html" title="javax.swing 中的类"><B>上一个类</B></A>&nbsp;
&nbsp;<A HREF="../../javax/swing/GroupLayout.Alignment.html" title="javax.swing 中的枚举"><B>下一个类</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../index.html?javax/swing/GroupLayout.html" target="_top"><B>框架</B></A>  &nbsp;
&nbsp;<A HREF="GroupLayout.html" target="_top"><B>无框架</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../allclasses-noframe.html"><B>所有类</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../allclasses-noframe.html"><B>所有类</B></A>
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  摘要：&nbsp;<A HREF="#nested_class_summary">嵌套</A>&nbsp;|&nbsp;<A HREF="#field_summary">字段</A>&nbsp;|&nbsp;<A HREF="#constructor_summary">构造方法</A>&nbsp;|&nbsp;<A HREF="#method_summary">方法</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
详细信息：&nbsp;<A HREF="#field_detail">字段</A>&nbsp;|&nbsp;<A HREF="#constructor_detail">构造方法</A>&nbsp;|&nbsp;<A HREF="#method_detail">方法</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_bottom"></A>
<!-- ======== END OF BOTTOM NAVBAR ======= -->

<HR>
<font size="-1"><a href="http://bugs.sun.com/services/bugreport/index.jsp">提交错误或意见</a><br>有关更多的 API 参考资料和开发人员文档，请参阅 <a href="http://java.sun.com/javase/6/webnotes/devdocs-vs-specs.html">Java SE 开发人员文档</a>。该文档包含更详细的、面向开发人员的描述，以及总体概述、术语定义、使用技巧和工作代码示例。 <p>版权所有 2007 Sun Microsystems, Inc. 保留所有权利。 请遵守<a href="http://java.sun.com/javase/6/docs/legal/license.html">许可证条款</a>。另请参阅<a href="http://java.sun.com/docs/redist.html">文档重新分发政策</a>。</font>
</BODY>
</HTML>
