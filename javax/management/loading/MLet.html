<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc (build 1.6.0-beta2) on Mon Mar 19 18:29:53 CST 2007 -->
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
<TITLE>
MLet (Java Platform SE 6)
</TITLE>

<META NAME="date" CONTENT="2007-03-19">

<LINK REL ="stylesheet" TYPE="text/css" HREF="../../../stylesheet.css" TITLE="Style">

<SCRIPT type="text/javascript">
function windowTitle()
{
    if (location.href.indexOf('is-external=true') == -1) {
        parent.document.title="MLet (Java Platform SE 6)";
    }
}
</SCRIPT>
<NOSCRIPT>
</NOSCRIPT>

</HEAD>

<BODY BGCOLOR="white" onload="windowTitle();">
<HR>


<!-- ========= START OF TOP NAVBAR ======= -->
<A NAME="navbar_top"><!-- --></A>
<A HREF="#skip-navbar_top" title="跳过导航链接"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>概述</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>软件包</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>类</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/MLet.html"><FONT CLASS="NavBarFont1"><B>使用</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>树</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>已过时</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>索引</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>帮助</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
<b>Java<sup><font size=-2>TM</font></sup>&nbsp;Platform<br>Standard&nbsp;Ed. 6</b></EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../../javax/management/loading/DefaultLoaderRepository.html" title="javax.management.loading 中的类"><B>上一个类</B></A>&nbsp;
&nbsp;<A HREF="../../../javax/management/loading/MLetContent.html" title="javax.management.loading 中的类"><B>下一个类</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../index.html?javax/management/loading/MLet.html" target="_top"><B>框架</B></A>  &nbsp;
&nbsp;<A HREF="MLet.html" target="_top"><B>无框架</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../allclasses-noframe.html"><B>所有类</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../allclasses-noframe.html"><B>所有类</B></A>
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  摘要：&nbsp;嵌套&nbsp;|&nbsp;字段&nbsp;|&nbsp;<A HREF="#constructor_summary">构造方法</A>&nbsp;|&nbsp;<A HREF="#method_summary">方法</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
详细信息：&nbsp;字段&nbsp;|&nbsp;<A HREF="#constructor_detail">构造方法</A>&nbsp;|&nbsp;<A HREF="#method_detail">方法</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_top"></A>
<!-- ========= END OF TOP NAVBAR ========= -->

<HR>
<!-- ======== START OF CLASS DATA ======== -->
<H2>
<FONT SIZE="-1">
javax.management.loading</FONT>
<BR>
类 MLet</H2>
<PRE>
<A HREF="../../../java/lang/Object.html" title="java.lang 中的类">java.lang.Object</A>
  <IMG SRC="../../../resources/inherit.gif" ALT="继承者 "><A HREF="../../../java/lang/ClassLoader.html" title="java.lang 中的类">java.lang.ClassLoader</A>
      <IMG SRC="../../../resources/inherit.gif" ALT="继承者 "><A HREF="../../../java/security/SecureClassLoader.html" title="java.security 中的类">java.security.SecureClassLoader</A>
          <IMG SRC="../../../resources/inherit.gif" ALT="继承者 "><A HREF="../../../java/net/URLClassLoader.html" title="java.net 中的类">java.net.URLClassLoader</A>
              <IMG SRC="../../../resources/inherit.gif" ALT="继承者 "><B>javax.management.loading.MLet</B>
</PRE>
<DL>
<DT><B>所有已实现的接口：</B> <DD><A HREF="../../../java/io/Externalizable.html" title="java.io 中的接口">Externalizable</A>, <A HREF="../../../java/io/Serializable.html" title="java.io 中的接口">Serializable</A>, <A HREF="../../../javax/management/loading/MLetMBean.html" title="javax.management.loading 中的接口">MLetMBean</A>, <A HREF="../../../javax/management/MBeanRegistration.html" title="javax.management 中的接口">MBeanRegistration</A></DD>
</DL>
<DL>
<DT><B>直接已知子类：</B> <DD><A HREF="../../../javax/management/loading/PrivateMLet.html" title="javax.management.loading 中的类">PrivateMLet</A></DD>
</DL>
<HR>
<DL>
<DT><PRE>public class <B>MLet</B><DT>extends <A HREF="../../../java/net/URLClassLoader.html" title="java.net 中的类">URLClassLoader</A><DT>implements <A HREF="../../../javax/management/loading/MLetMBean.html" title="javax.management.loading 中的接口">MLetMBean</A>, <A HREF="../../../javax/management/MBeanRegistration.html" title="javax.management 中的接口">MBeanRegistration</A>, <A HREF="../../../java/io/Externalizable.html" title="java.io 中的接口">Externalizable</A></DL>
</PRE>

<P>
允许实例化和注册来自远程 URL 的 MBean 服务器中一个或几个 MBean。M-let 是管理 applet 的捷径。m-let 服务通过加载一个 m-let 文本文件来实现此功能，该文本文件指定了要获取的 MBean 上的信息。每个 MBean 上的信息都是在某个标记的单个实例中指定的，该标记称为 MLET 标记。m-let 文本文件的位置由 URL 指定。 
 <p>
<CODE>MLET</CODE> 标记具有以下语法：
 <p>
 &lt;<CODE>MLET</CODE><BR> <CODE>CODE = </CODE><VAR>class</VAR><CODE> | OBJECT = </CODE><VAR>serfile</VAR><BR> <CODE>ARCHIVE = &quot;</CODE><VAR>archiveList</VAR><CODE>&quot;</CODE><BR> <CODE>[CODEBASE = </CODE><VAR>codebaseURL</VAR><CODE>]</CODE><BR> <CODE>[NAME = </CODE><VAR>mbeanname</VAR><CODE>]</CODE><BR> <CODE>[VERSION = </CODE><VAR>version</VAR><CODE>]</CODE><BR> &gt;<BR> <CODE>[</CODE><VAR>arglist</VAR><CODE>]</CODE><BR> &lt;<CODE>/MLET</CODE>&gt;
 <p>
其中：
 <DL>
 <DT><CODE>CODE = </CODE><VAR>class</VAR></DT>
 <DD>
此属性指定了要获取的 MBean 的 Java 类的全名，包括包名称。编译后的 MBean 的 <CODE>.class</CODE> 文件必须包含在 <CODE>ARCHIVE</CODE> 属性指定的 <CODE>.jar</CODE> 文件中。<CODE>CODE</CODE> 或 <CODE>OBJECT</CODE> 必须存在。
 </DD>
 <DT><CODE>OBJECT = </CODE><VAR>serfile</VAR></DT>
 <DD>
此属性指定了 <CODE>.ser</CODE> 文件，该文件包含要获取的 MBean 的序列化表示形式。此文件必须包含在 <CODE>ARCHIVE</CODE> 属性指定的 <CODE>.jar</CODE> 文件中。如果 <CODE>.jar</CODE> 文件包含目录层次结构，则需要指定此层次结构中的文件路径。否则将找不到匹配项。<CODE>CODE</CODE> 或 <CODE>OBJECT</CODE> 必须存在。
 </DD>
 <DT><CODE>ARCHIVE = &quot;</CODE><VAR>archiveList</VAR><CODE>&quot;</CODE></DT>
 <DD>
此属性是必需的，它指定了一个或多个 <CODE>.jar</CODE> 文件，这些文件包含要获取的 MBean 使用的 MBean 或其他资源。<CODE>.jar</CODE> 文件之一必须包含 <CODE>CODE</CODE> 或 <CODE>OBJECT</CODE> 属性所指定的文件。如果 archivelist 包含多个文件：
 <UL>
<LI>必须用逗号 (,) 将每个文件与它后面的文件隔开。
<LI><VAR>archivelist</VAR> 必须用双引号引起来。
 </UL>
<VAR>archivelist</VAR> 中的所有 <CODE>.jar</CODE> 文件必须存储在代码基 URL 指定的目录中。
 </DD>
 <DT><CODE>CODEBASE = </CODE><VAR>codebaseURL</VAR></DT>
 <DD>
此可选属性指定了要获取的 MBean 的代码基 URL。它标识了包含 <CODE>ARCHIVE</CODE> 指定的 <CODE>.jar</CODE> 文件的目录。仅当 <CODE>.jar</CODE> 文件与 m-let 文本文件不在同一目录中时，指定此属性。如果不指定此属性，则使用 m-let 文本文件的基本 URL。
 </DD>
 <DT><CODE>NAME = </CODE><VAR>mbeanname</VAR></DT>
 <DD>
当 m-let 已注册 MBean 实例时，此可选属性指定了要分配给 MBean 实例的对象名称。如果 <VAR>mbeanname</VAR> 以冒号字符 (:) 开始，则对象名称的域部分是 MBean 服务器的默认域，可由 <A HREF="../../../javax/management/MBeanServer.html#getDefaultDomain()"><CODE>MBeanServer.getDefaultDomain()</CODE></A> 返回。
 </DD>
 <DT><CODE>VERSION = </CODE><VAR>version</VAR></DT>
 <DD>
此可选属性指定了要获取的 MBean 版本号和关联的 <CODE>.jar</CODE> 文件。此版本号可用于指定从服务器加载 <CODE>.jar</CODE> 文件，以便在下次调用 m-let 文本文件时更新存储在本地缓存中的文件。<VAR>version</VAR> 必须是一系列非负的十进制整数，每个整数都通过句点与它前面的整数隔开。
 </DD>
 <DT><VAR>arglist</VAR></DT>
 <DD>
此可选属性指定了将被实例化的 MBean 的一个或多个参数的列表。此列表描述了要传递给 MBean 的构造方法的参数。使用以下语法指定 <VAR>arglist</VAR> 中的每一项：</DD>
 <DL>
 <P>
 <DT>&lt;<CODE>ARG TYPE=</CODE><VAR>argumentType</VAR> <CODE>VALUE=</CODE><VAR>value</VAR>&gt;</DT>
 <P>
<DD>其中：</DD>
 <UL>
<LI><VAR>argumentType</VAR> 是将作为参数传递给 MBean 的构造方法的参数类型。</UL>
 </DL>
<P>参数列表中的参数类型应为 Java 基本类型（<CODE>java.lang.Boolean、java.lang.Byte、 java.lang.Short、java.lang.Long、java.lang.Integer、java.lang.Float、java.lang.Double 和 java.lang.String</CODE>）。
 </DL>

当加载一个 m-let 文本文件时，创建并注册该文件中所指定的每个 MBean 的实例。
 <P>
m-let 服务扩展了 <CODE>java.net.URLClassLoader</CODE>，可以用它加载代理的 VM 中的远程类和 jar 文件。
<p><STRONG>注意 － </STRONG> <CODE>MLet</CODE> 类加载器使用 <A HREF="../../../javax/management/MBeanServerFactory.html#getClassLoaderRepository(javax.management.MBeanServer)"><CODE>MBeanServerFactory.getClassLoaderRepository(javax.management.MBeanServer)</CODE></A> 来加载在已加载 jar 文件中找不到的类。
<P>

<P>
<DL>
<DT><B>从以下版本开始：</B></DT>
  <DD>1.5</DD>
<DT><B>另请参见：</B><DD><A HREF="../../../serialized-form.html#javax.management.loading.MLet">序列化表格</A></DL>
<HR>

<P>

<!-- ======== CONSTRUCTOR SUMMARY ======== -->

<A NAME="constructor_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>构造方法摘要</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../../javax/management/loading/MLet.html#MLet()">MLet</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;使用默认的代理父类加载器构造新的 MLet。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../../javax/management/loading/MLet.html#MLet(java.net.URL[])">MLet</A></B>(<A HREF="../../../java/net/URL.html" title="java.net 中的类">URL</A>[]&nbsp;urls)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;使用默认的代理父类加载器为指定的 URL 构造新的 MLet。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../../javax/management/loading/MLet.html#MLet(java.net.URL[], boolean)">MLet</A></B>(<A HREF="../../../java/net/URL.html" title="java.net 中的类">URL</A>[]&nbsp;urls,
     boolean&nbsp;delegateToCLR)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;使用默认的代理父类加载器为指定的 URL 构造新的 MLet。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../../javax/management/loading/MLet.html#MLet(java.net.URL[], java.lang.ClassLoader)">MLet</A></B>(<A HREF="../../../java/net/URL.html" title="java.net 中的类">URL</A>[]&nbsp;urls,
     <A HREF="../../../java/lang/ClassLoader.html" title="java.lang 中的类">ClassLoader</A>&nbsp;parent)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;为给定的 URL 构造新的 MLet。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../../javax/management/loading/MLet.html#MLet(java.net.URL[], java.lang.ClassLoader, boolean)">MLet</A></B>(<A HREF="../../../java/net/URL.html" title="java.net 中的类">URL</A>[]&nbsp;urls,
     <A HREF="../../../java/lang/ClassLoader.html" title="java.lang 中的类">ClassLoader</A>&nbsp;parent,
     boolean&nbsp;delegateToCLR)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;为给定的 URL 构造新的 MLet。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../../javax/management/loading/MLet.html#MLet(java.net.URL[], java.lang.ClassLoader, java.net.URLStreamHandlerFactory)">MLet</A></B>(<A HREF="../../../java/net/URL.html" title="java.net 中的类">URL</A>[]&nbsp;urls,
     <A HREF="../../../java/lang/ClassLoader.html" title="java.lang 中的类">ClassLoader</A>&nbsp;parent,
     <A HREF="../../../java/net/URLStreamHandlerFactory.html" title="java.net 中的接口">URLStreamHandlerFactory</A>&nbsp;factory)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;为指定的 URL、父类加载器和 URLStreamHandlerFactory 构造新的 MLet。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../../javax/management/loading/MLet.html#MLet(java.net.URL[], java.lang.ClassLoader, java.net.URLStreamHandlerFactory, boolean)">MLet</A></B>(<A HREF="../../../java/net/URL.html" title="java.net 中的类">URL</A>[]&nbsp;urls,
     <A HREF="../../../java/lang/ClassLoader.html" title="java.lang 中的类">ClassLoader</A>&nbsp;parent,
     <A HREF="../../../java/net/URLStreamHandlerFactory.html" title="java.net 中的接口">URLStreamHandlerFactory</A>&nbsp;factory,
     boolean&nbsp;delegateToCLR)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;为指定的 URL、父类加载器和 URLStreamHandlerFactory 构造新的 MLet。</TD>
</TR>
</TABLE>
&nbsp;
<!-- ========== METHOD SUMMARY =========== -->

<A NAME="method_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>方法摘要</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/management/loading/MLet.html#addURL(java.lang.String)">addURL</A></B>(<A HREF="../../../java/lang/String.html" title="java.lang 中的类">String</A>&nbsp;url)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;将指定的 URL 追加到 URL 列表中，以便搜索类和资源。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/management/loading/MLet.html#addURL(java.net.URL)">addURL</A></B>(<A HREF="../../../java/net/URL.html" title="java.net 中的类">URL</A>&nbsp;url)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;将指定的 URL 追加到 URL 列表中，以便搜索类和资源。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="../../../java/net/URL.html" title="java.net 中的类">URL</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/management/loading/MLet.html#check(java.lang.String, java.net.URL, java.lang.String, javax.management.loading.MLetContent)">check</A></B>(<A HREF="../../../java/lang/String.html" title="java.lang 中的类">String</A>&nbsp;version,
      <A HREF="../../../java/net/URL.html" title="java.net 中的类">URL</A>&nbsp;codebase,
      <A HREF="../../../java/lang/String.html" title="java.lang 中的类">String</A>&nbsp;jarfile,
      <A HREF="../../../javax/management/loading/MLetContent.html" title="javax.management.loading 中的类">MLetContent</A>&nbsp;mlet)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当扩展此服务来支持缓存和版本控制时，要重写此方法。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="../../../java/lang/Class.html" title="java.lang 中的类">Class</A>&lt;?&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/management/loading/MLet.html#findClass(java.lang.String)">findClass</A></B>(<A HREF="../../../java/lang/String.html" title="java.lang 中的类">String</A>&nbsp;name)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这是要重新定义的类加载器的主要方法。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="../../../java/lang/String.html" title="java.lang 中的类">String</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/management/loading/MLet.html#findLibrary(java.lang.String)">findLibrary</A></B>(<A HREF="../../../java/lang/String.html" title="java.lang 中的类">String</A>&nbsp;libname)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;返回本机库的绝对路径名称。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../java/lang/String.html" title="java.lang 中的类">String</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/management/loading/MLet.html#getLibraryDirectory()">getLibraryDirectory</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;获取库加载器在将本机库加载到内存中之前用于存储这些本机库的当前目录。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../java/util/Set.html" title="java.util 中的接口">Set</A>&lt;<A HREF="../../../java/lang/Object.html" title="java.lang 中的类">Object</A>&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/management/loading/MLet.html#getMBeansFromURL(java.lang.String)">getMBeansFromURL</A></B>(<A HREF="../../../java/lang/String.html" title="java.lang 中的类">String</A>&nbsp;url)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;加载一个包含 MLET 标记的文本文件，这些标记定义了要添加到 MBean 服务器的 MBean。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../java/util/Set.html" title="java.util 中的接口">Set</A>&lt;<A HREF="../../../java/lang/Object.html" title="java.lang 中的类">Object</A>&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/management/loading/MLet.html#getMBeansFromURL(java.net.URL)">getMBeansFromURL</A></B>(<A HREF="../../../java/net/URL.html" title="java.net 中的类">URL</A>&nbsp;url)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;加载一个包含 MLET 标记的文本文件，这些标记定义了要添加到 MBean 服务器的 MBean。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../java/net/URL.html" title="java.net 中的类">URL</A>[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/management/loading/MLet.html#getURLs()">getURLs</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;返回用于加载类和资源的 URL 搜索路径。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../java/lang/Class.html" title="java.lang 中的类">Class</A>&lt;?&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/management/loading/MLet.html#loadClass(java.lang.String, javax.management.loading.ClassLoaderRepository)">loadClass</A></B>(<A HREF="../../../java/lang/String.html" title="java.lang 中的类">String</A>&nbsp;name,
          <A HREF="../../../javax/management/loading/ClassLoaderRepository.html" title="javax.management.loading 中的接口">ClassLoaderRepository</A>&nbsp;clr)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果在此 MLet 的 URL 中找不到某个类，则使用给定的 <A HREF="../../../javax/management/loading/ClassLoaderRepository.html" title="javax.management.loading 中的接口"><CODE>ClassLoaderRepository</CODE></A> 加载该类。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/management/loading/MLet.html#postDeregister()">postDeregister</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;允许 m-let 在已从 MBean 服务器注销之后执行任何所需要的操作。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/management/loading/MLet.html#postRegister(java.lang.Boolean)">postRegister</A></B>(<A HREF="../../../java/lang/Boolean.html" title="java.lang 中的类">Boolean</A>&nbsp;registrationDone)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;允许 m-let 在已注册到 MBean 服务器之后或注册失败之后执行任何所需要的操作。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/management/loading/MLet.html#preDeregister()">preDeregister</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;允许 m-let 在由 MBean 服务器注销之前执行任何所需要的操作。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../javax/management/ObjectName.html" title="javax.management 中的类">ObjectName</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/management/loading/MLet.html#preRegister(javax.management.MBeanServer, javax.management.ObjectName)">preRegister</A></B>(<A HREF="../../../javax/management/MBeanServer.html" title="javax.management 中的接口">MBeanServer</A>&nbsp;server,
            <A HREF="../../../javax/management/ObjectName.html" title="javax.management 中的类">ObjectName</A>&nbsp;name)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;允许在将 m-let 注册到 MBean 之前执行任何所需要的操作。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/management/loading/MLet.html#readExternal(java.io.ObjectInput)">readExternal</A></B>(<A HREF="../../../java/io/ObjectInput.html" title="java.io 中的接口">ObjectInput</A>&nbsp;in)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;从给定的 <A HREF="../../../java/io/ObjectInput.html" title="java.io 中的接口"><CODE>ObjectInput</CODE></A> 恢复此 MLet 的内容。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/management/loading/MLet.html#setLibraryDirectory(java.lang.String)">setLibraryDirectory</A></B>(<A HREF="../../../java/lang/String.html" title="java.lang 中的类">String</A>&nbsp;libdir)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;设置在将本机库加载到内存中之前库加载器用来存储这些本机库的目录。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/management/loading/MLet.html#writeExternal(java.io.ObjectOutput)">writeExternal</A></B>(<A HREF="../../../java/io/ObjectOutput.html" title="java.io 中的接口">ObjectOutput</A>&nbsp;out)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;将此 MLet 的内容保存到给定的 <A HREF="../../../java/io/ObjectOutput.html" title="java.io 中的接口"><CODE>ObjectOutput</CODE></A>。</TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_java.net.URLClassLoader"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>从类 java.net.<A HREF="../../../java/net/URLClassLoader.html" title="java.net 中的类">URLClassLoader</A> 继承的方法</B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><A HREF="../../../java/net/URLClassLoader.html#definePackage(java.lang.String, java.util.jar.Manifest, java.net.URL)">definePackage</A>, <A HREF="../../../java/net/URLClassLoader.html#findResource(java.lang.String)">findResource</A>, <A HREF="../../../java/net/URLClassLoader.html#findResources(java.lang.String)">findResources</A>, <A HREF="../../../java/net/URLClassLoader.html#getPermissions(java.security.CodeSource)">getPermissions</A>, <A HREF="../../../java/net/URLClassLoader.html#newInstance(java.net.URL[])">newInstance</A>, <A HREF="../../../java/net/URLClassLoader.html#newInstance(java.net.URL[], java.lang.ClassLoader)">newInstance</A></CODE></TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_java.security.SecureClassLoader"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>从类 java.security.<A HREF="../../../java/security/SecureClassLoader.html" title="java.security 中的类">SecureClassLoader</A> 继承的方法</B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><A HREF="../../../java/security/SecureClassLoader.html#defineClass(java.lang.String, byte[], int, int, java.security.CodeSource)">defineClass</A>, <A HREF="../../../java/security/SecureClassLoader.html#defineClass(java.lang.String, java.nio.ByteBuffer, java.security.CodeSource)">defineClass</A></CODE></TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_java.lang.ClassLoader"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>从类 java.lang.<A HREF="../../../java/lang/ClassLoader.html" title="java.lang 中的类">ClassLoader</A> 继承的方法</B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><A HREF="../../../java/lang/ClassLoader.html#clearAssertionStatus()">clearAssertionStatus</A>, <A HREF="../../../java/lang/ClassLoader.html#defineClass(byte[], int, int)">defineClass</A>, <A HREF="../../../java/lang/ClassLoader.html#defineClass(java.lang.String, byte[], int, int)">defineClass</A>, <A HREF="../../../java/lang/ClassLoader.html#defineClass(java.lang.String, byte[], int, int, java.security.ProtectionDomain)">defineClass</A>, <A HREF="../../../java/lang/ClassLoader.html#defineClass(java.lang.String, java.nio.ByteBuffer, java.security.ProtectionDomain)">defineClass</A>, <A HREF="../../../java/lang/ClassLoader.html#definePackage(java.lang.String, java.lang.String, java.lang.String, java.lang.String, java.lang.String, java.lang.String, java.lang.String, java.net.URL)">definePackage</A>, <A HREF="../../../java/lang/ClassLoader.html#findLoadedClass(java.lang.String)">findLoadedClass</A>, <A HREF="../../../java/lang/ClassLoader.html#findSystemClass(java.lang.String)">findSystemClass</A>, <A HREF="../../../java/lang/ClassLoader.html#getPackage(java.lang.String)">getPackage</A>, <A HREF="../../../java/lang/ClassLoader.html#getPackages()">getPackages</A>, <A HREF="../../../java/lang/ClassLoader.html#getParent()">getParent</A>, <A HREF="../../../java/lang/ClassLoader.html#getResource(java.lang.String)">getResource</A>, <A HREF="../../../java/lang/ClassLoader.html#getResourceAsStream(java.lang.String)">getResourceAsStream</A>, <A HREF="../../../java/lang/ClassLoader.html#getResources(java.lang.String)">getResources</A>, <A HREF="../../../java/lang/ClassLoader.html#getSystemClassLoader()">getSystemClassLoader</A>, <A HREF="../../../java/lang/ClassLoader.html#getSystemResource(java.lang.String)">getSystemResource</A>, <A HREF="../../../java/lang/ClassLoader.html#getSystemResourceAsStream(java.lang.String)">getSystemResourceAsStream</A>, <A HREF="../../../java/lang/ClassLoader.html#getSystemResources(java.lang.String)">getSystemResources</A>, <A HREF="../../../java/lang/ClassLoader.html#loadClass(java.lang.String)">loadClass</A>, <A HREF="../../../java/lang/ClassLoader.html#loadClass(java.lang.String, boolean)">loadClass</A>, <A HREF="../../../java/lang/ClassLoader.html#resolveClass(java.lang.Class)">resolveClass</A>, <A HREF="../../../java/lang/ClassLoader.html#setClassAssertionStatus(java.lang.String, boolean)">setClassAssertionStatus</A>, <A HREF="../../../java/lang/ClassLoader.html#setDefaultAssertionStatus(boolean)">setDefaultAssertionStatus</A>, <A HREF="../../../java/lang/ClassLoader.html#setPackageAssertionStatus(java.lang.String, boolean)">setPackageAssertionStatus</A>, <A HREF="../../../java/lang/ClassLoader.html#setSigners(java.lang.Class, java.lang.Object[])">setSigners</A></CODE></TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_java.lang.Object"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>从类 java.lang.<A HREF="../../../java/lang/Object.html" title="java.lang 中的类">Object</A> 继承的方法</B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><A HREF="../../../java/lang/Object.html#clone()">clone</A>, <A HREF="../../../java/lang/Object.html#equals(java.lang.Object)">equals</A>, <A HREF="../../../java/lang/Object.html#finalize()">finalize</A>, <A HREF="../../../java/lang/Object.html#getClass()">getClass</A>, <A HREF="../../../java/lang/Object.html#hashCode()">hashCode</A>, <A HREF="../../../java/lang/Object.html#notify()">notify</A>, <A HREF="../../../java/lang/Object.html#notifyAll()">notifyAll</A>, <A HREF="../../../java/lang/Object.html#toString()">toString</A>, <A HREF="../../../java/lang/Object.html#wait()">wait</A>, <A HREF="../../../java/lang/Object.html#wait(long)">wait</A>, <A HREF="../../../java/lang/Object.html#wait(long, int)">wait</A></CODE></TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_javax.management.loading.MLetMBean"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>从接口 javax.management.loading.<A HREF="../../../javax/management/loading/MLetMBean.html" title="javax.management.loading 中的接口">MLetMBean</A> 继承的方法</B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><A HREF="../../../javax/management/loading/MLetMBean.html#getResource(java.lang.String)">getResource</A>, <A HREF="../../../javax/management/loading/MLetMBean.html#getResourceAsStream(java.lang.String)">getResourceAsStream</A>, <A HREF="../../../javax/management/loading/MLetMBean.html#getResources(java.lang.String)">getResources</A></CODE></TD>
</TR>
</TABLE>
&nbsp;
<P>

<!-- ========= CONSTRUCTOR DETAIL ======== -->

<A NAME="constructor_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>构造方法详细信息</B></FONT></TH>
</TR>
</TABLE>

<A NAME="MLet()"><!-- --></A><H3>
MLet</H3>
<PRE>
public <B>MLet</B>()</PRE>
<DL>
<DD>使用默认的代理父类加载器构造新的 MLet。
<P>
</DL>
<HR>

<A NAME="MLet(java.net.URL[])"><!-- --></A><H3>
MLet</H3>
<PRE>
public <B>MLet</B>(<A HREF="../../../java/net/URL.html" title="java.net 中的类">URL</A>[]&nbsp;urls)</PRE>
<DL>
<DD>使用默认的代理父类加载器为指定的 URL 构造新的 MLet。首先在父类加载器中搜索 URL，然后按照为类和资源指定的顺序搜索 URL。
<P>
<DL>
<DT><B>参数：</B><DD><CODE>urls</CODE> - 从其位置加载类和资源的 URL。</DL>
</DL>
<HR>

<A NAME="MLet(java.net.URL[], java.lang.ClassLoader)"><!-- --></A><H3>
MLet</H3>
<PRE>
public <B>MLet</B>(<A HREF="../../../java/net/URL.html" title="java.net 中的类">URL</A>[]&nbsp;urls,
            <A HREF="../../../java/lang/ClassLoader.html" title="java.lang 中的类">ClassLoader</A>&nbsp;parent)</PRE>
<DL>
<DD>为给定的 URL 构造新的 MLet。首先在指定的父类加载器中搜索 URL，然后按照为类和资源指定的顺序搜索 URL。该父参数将用作代理的父类加载器。
<P>
<DL>
<DT><B>参数：</B><DD><CODE>urls</CODE> - 从其指示的位置加载类和资源的 URL。<DD><CODE>parent</CODE> - 代理的父类加载器。</DL>
</DL>
<HR>

<A NAME="MLet(java.net.URL[], java.lang.ClassLoader, java.net.URLStreamHandlerFactory)"><!-- --></A><H3>
MLet</H3>
<PRE>
public <B>MLet</B>(<A HREF="../../../java/net/URL.html" title="java.net 中的类">URL</A>[]&nbsp;urls,
            <A HREF="../../../java/lang/ClassLoader.html" title="java.lang 中的类">ClassLoader</A>&nbsp;parent,
            <A HREF="../../../java/net/URLStreamHandlerFactory.html" title="java.net 中的接口">URLStreamHandlerFactory</A>&nbsp;factory)</PRE>
<DL>
<DD>为指定的 URL、父类加载器和 URLStreamHandlerFactory 构造新的 MLet。该父参数将用作代理的父类加载器。在创建新 URL 时，该工厂参数将用作获取协议处理程序的流处理程序工厂。
<P>
<DL>
<DT><B>参数：</B><DD><CODE>urls</CODE> - 从其指示的位置加载类和资源的 URL。<DD><CODE>parent</CODE> - 代理的父类加载器。<DD><CODE>factory</CODE> - 创建 URL 时要使用的 URLStreamHandlerFactory。</DL>
</DL>
<HR>

<A NAME="MLet(java.net.URL[], boolean)"><!-- --></A><H3>
MLet</H3>
<PRE>
public <B>MLet</B>(<A HREF="../../../java/net/URL.html" title="java.net 中的类">URL</A>[]&nbsp;urls,
            boolean&nbsp;delegateToCLR)</PRE>
<DL>
<DD>使用默认的代理父类加载器为指定的 URL 构造新的 MLet。首先在父类加载器中搜索 URL，然后按照为类和资源指定的顺序搜索 URL。
<P>
<DL>
<DT><B>参数：</B><DD><CODE>urls</CODE> - 从其指示的位置加载类和资源的 URL。<DD><CODE>delegateToCLR</CODE> - 如果该参数为 true，则当在父类加载器或 URL 中均未找到某个类时，MLet 应该委托给该类的包含 MBeanServer 的 <A HREF="../../../javax/management/loading/ClassLoaderRepository.html" title="javax.management.loading 中的接口"><CODE>ClassLoaderRepository</CODE></A>。</DL>
</DL>
<HR>

<A NAME="MLet(java.net.URL[], java.lang.ClassLoader, boolean)"><!-- --></A><H3>
MLet</H3>
<PRE>
public <B>MLet</B>(<A HREF="../../../java/net/URL.html" title="java.net 中的类">URL</A>[]&nbsp;urls,
            <A HREF="../../../java/lang/ClassLoader.html" title="java.lang 中的类">ClassLoader</A>&nbsp;parent,
            boolean&nbsp;delegateToCLR)</PRE>
<DL>
<DD>为给定的 URL 构造新的 MLet。首先在指定的父类加载器中搜索 URL，然后按照为类和资源指定的顺序搜索 URL。该父参数将用作代理的父类加载器。
<P>
<DL>
<DT><B>参数：</B><DD><CODE>urls</CODE> - 从其指示的位置加载类和资源的 URL。<DD><CODE>parent</CODE> - 代理的父类加载器。<DD><CODE>delegateToCLR</CODE> - 如果该参数为 true，则当在父类加载器或 URL 中均未找到某个类时，MLet 应该委托给该类的包含 MBeanServer 的 <A HREF="../../../javax/management/loading/ClassLoaderRepository.html" title="javax.management.loading 中的接口"><CODE>ClassLoaderRepository</CODE></A>。</DL>
</DL>
<HR>

<A NAME="MLet(java.net.URL[], java.lang.ClassLoader, java.net.URLStreamHandlerFactory, boolean)"><!-- --></A><H3>
MLet</H3>
<PRE>
public <B>MLet</B>(<A HREF="../../../java/net/URL.html" title="java.net 中的类">URL</A>[]&nbsp;urls,
            <A HREF="../../../java/lang/ClassLoader.html" title="java.lang 中的类">ClassLoader</A>&nbsp;parent,
            <A HREF="../../../java/net/URLStreamHandlerFactory.html" title="java.net 中的接口">URLStreamHandlerFactory</A>&nbsp;factory,
            boolean&nbsp;delegateToCLR)</PRE>
<DL>
<DD>为指定的 URL、父类加载器和 URLStreamHandlerFactory 构造新的 MLet。该父参数将用作代理的父类加载器。在创建新 URL 时，该工厂参数将用作获取协议处理程序的流处理程序工厂。
<P>
<DL>
<DT><B>参数：</B><DD><CODE>urls</CODE> - 从其指示的位置加载类和资源的 URL。<DD><CODE>parent</CODE> - 代理的父类加载器。<DD><CODE>factory</CODE> - 创建 URL 时要使用的 URLStreamHandlerFactory。<DD><CODE>delegateToCLR</CODE> - 如果该参数为 true，则当在父类加载器或 URL 中均未找到某个类时，MLet 应该委托给该类的包含 MBeanServer 的 <A HREF="../../../javax/management/loading/ClassLoaderRepository.html" title="javax.management.loading 中的接口"><CODE>ClassLoaderRepository</CODE></A>。</DL>
</DL>

<!-- ============ METHOD DETAIL ========== -->

<A NAME="method_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>方法详细信息</B></FONT></TH>
</TR>
</TABLE>

<A NAME="addURL(java.net.URL)"><!-- --></A><H3>
addURL</H3>
<PRE>
public void <B>addURL</B>(<A HREF="../../../java/net/URL.html" title="java.net 中的类">URL</A>&nbsp;url)</PRE>
<DL>
<DD>将指定的 URL 追加到 URL 列表中，以便搜索类和资源。
<P>
<DD><DL>
<DT><B>指定者：</B><DD>接口 <CODE><A HREF="../../../javax/management/loading/MLetMBean.html" title="javax.management.loading 中的接口">MLetMBean</A></CODE> 中的 <CODE><A HREF="../../../javax/management/loading/MLetMBean.html#addURL(java.net.URL)">addURL</A></CODE><DT><B>覆盖：</B><DD>类 <CODE><A HREF="../../../java/net/URLClassLoader.html" title="java.net 中的类">URLClassLoader</A></CODE> 中的 <CODE><A HREF="../../../java/net/URLClassLoader.html#addURL(java.net.URL)">addURL</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>参数：</B><DD><CODE>url</CODE> - 将添加到 URL 搜索路径中的 URL</DL>
</DD>
</DL>
<HR>

<A NAME="addURL(java.lang.String)"><!-- --></A><H3>
addURL</H3>
<PRE>
public void <B>addURL</B>(<A HREF="../../../java/lang/String.html" title="java.lang 中的类">String</A>&nbsp;url)
            throws <A HREF="../../../javax/management/ServiceNotFoundException.html" title="javax.management 中的类">ServiceNotFoundException</A></PRE>
<DL>
<DD>将指定的 URL 追加到 URL 列表中，以便搜索类和资源。
<P>
<DD><DL>
<DT><B>指定者：</B><DD>接口 <CODE><A HREF="../../../javax/management/loading/MLetMBean.html" title="javax.management.loading 中的接口">MLetMBean</A></CODE> 中的 <CODE><A HREF="../../../javax/management/loading/MLetMBean.html#addURL(java.lang.String)">addURL</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>参数：</B><DD><CODE>url</CODE> - 要添加的 URL。
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../../javax/management/ServiceNotFoundException.html" title="javax.management 中的类">ServiceNotFoundException</A></CODE> - 如果指定的 URL 错误。</DL>
</DD>
</DL>
<HR>

<A NAME="getURLs()"><!-- --></A><H3>
getURLs</H3>
<PRE>
public <A HREF="../../../java/net/URL.html" title="java.net 中的类">URL</A>[] <B>getURLs</B>()</PRE>
<DL>
<DD>返回用于加载类和资源的 URL 搜索路径。这包括为构造方法指定的原始 URL 列表，以及 addURL() 方法后来添加的 URL。
<P>
<DD><DL>
<DT><B>指定者：</B><DD>接口 <CODE><A HREF="../../../javax/management/loading/MLetMBean.html" title="javax.management.loading 中的接口">MLetMBean</A></CODE> 中的 <CODE><A HREF="../../../javax/management/loading/MLetMBean.html#getURLs()">getURLs</A></CODE><DT><B>覆盖：</B><DD>类 <CODE><A HREF="../../../java/net/URLClassLoader.html" title="java.net 中的类">URLClassLoader</A></CODE> 中的 <CODE><A HREF="../../../java/net/URLClassLoader.html#getURLs()">getURLs</A></CODE></DL>
</DD>
<DD><DL>

<DT><B>返回：</B><DD>用于加载类和资源的 URL 搜索路径。</DL>
</DD>
</DL>
<HR>

<A NAME="getMBeansFromURL(java.net.URL)"><!-- --></A><H3>
getMBeansFromURL</H3>
<PRE>
public <A HREF="../../../java/util/Set.html" title="java.util 中的接口">Set</A>&lt;<A HREF="../../../java/lang/Object.html" title="java.lang 中的类">Object</A>&gt; <B>getMBeansFromURL</B>(<A HREF="../../../java/net/URL.html" title="java.net 中的类">URL</A>&nbsp;url)
                             throws <A HREF="../../../javax/management/ServiceNotFoundException.html" title="javax.management 中的类">ServiceNotFoundException</A></PRE>
<DL>
<DD>加载一个包含 MLET 标记的文本文件，这些标记定义了要添加到 MBean 服务器的 MBean。文本文件的位置由 URL 指定。MLET 文件中指定的 MBean 将被实例化并在 MBean 服务器中注册。
<P>
<DD><DL>
<DT><B>指定者：</B><DD>接口 <CODE><A HREF="../../../javax/management/loading/MLetMBean.html" title="javax.management.loading 中的接口">MLetMBean</A></CODE> 中的 <CODE><A HREF="../../../javax/management/loading/MLetMBean.html#getMBeansFromURL(java.net.URL)">getMBeansFromURL</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>参数：</B><DD><CODE>url</CODE> - 以 URL 对象形式加载的文本文件的 URL。
<DT><B>返回：</B><DD>一个集合，在所加载的 m-let 文本文件中，每个 MLET 标记都对应该集合中的一项。每一项要么指定了所创建的 MBean 的 ObjectInstance，要么在无法创建 MBean 时指定一个 throwable 对象（即一个错误或异常）。
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../../javax/management/ServiceNotFoundException.html" title="javax.management 中的类">ServiceNotFoundException</A></CODE> - 如果发生以下错误之一：m-let 文本文件不包含 MLET 标记；未找到 m-let 文本文件；未指定 MLET 标记的必需的属性；url 的值为 null。
<DD><CODE><A HREF="../../../java/lang/IllegalStateException.html" title="java.lang 中的类">IllegalStateException</A></CODE> - 如果没有在 MBeanServer 中注册 MLet MBean。</DL>
</DD>
</DL>
<HR>

<A NAME="getMBeansFromURL(java.lang.String)"><!-- --></A><H3>
getMBeansFromURL</H3>
<PRE>
public <A HREF="../../../java/util/Set.html" title="java.util 中的接口">Set</A>&lt;<A HREF="../../../java/lang/Object.html" title="java.lang 中的类">Object</A>&gt; <B>getMBeansFromURL</B>(<A HREF="../../../java/lang/String.html" title="java.lang 中的类">String</A>&nbsp;url)
                             throws <A HREF="../../../javax/management/ServiceNotFoundException.html" title="javax.management 中的类">ServiceNotFoundException</A></PRE>
<DL>
<DD>加载一个包含 MLET 标记的文本文件，这些标记定义了要添加到 MBean 服务器的 MBean。文本文件的位置由 URL 指定。MLET 文件中指定的 MBean 将被实例化并在 MBean 服务器中注册。
<P>
<DD><DL>
<DT><B>指定者：</B><DD>接口 <CODE><A HREF="../../../javax/management/loading/MLetMBean.html" title="javax.management.loading 中的接口">MLetMBean</A></CODE> 中的 <CODE><A HREF="../../../javax/management/loading/MLetMBean.html#getMBeansFromURL(java.lang.String)">getMBeansFromURL</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>参数：</B><DD><CODE>url</CODE> - 以 String 对象形式加载的文本文件的 URL。
<DT><B>返回：</B><DD>一个集合，在所加载的 m-let 文本文件中，每个 MLET 标记都对应该集合中的一项。每一项要么指定了所创建的 MBean 的 ObjectInstance，要么在无法创建 MBean 时指定一个 throwable 对象（即一个错误或异常）。
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../../javax/management/ServiceNotFoundException.html" title="javax.management 中的类">ServiceNotFoundException</A></CODE> - 如果发生以下错误之一：m-let 文本文件不包含 MLET 标记；未找到 m-let 文本文件；未指定 MLET 标记的必需的属性，url 错误。
<DD><CODE><A HREF="../../../java/lang/IllegalStateException.html" title="java.lang 中的类">IllegalStateException</A></CODE> - 如果没有在 MBeanServer 中注册 MLet MBean。</DL>
</DD>
</DL>
<HR>

<A NAME="getLibraryDirectory()"><!-- --></A><H3>
getLibraryDirectory</H3>
<PRE>
public <A HREF="../../../java/lang/String.html" title="java.lang 中的类">String</A> <B>getLibraryDirectory</B>()</PRE>
<DL>
<DD>获取库加载器在将本机库加载到内存中之前用于存储这些本机库的当前目录。
<P>
<DD><DL>
<DT><B>指定者：</B><DD>接口 <CODE><A HREF="../../../javax/management/loading/MLetMBean.html" title="javax.management.loading 中的接口">MLetMBean</A></CODE> 中的 <CODE><A HREF="../../../javax/management/loading/MLetMBean.html#getLibraryDirectory()">getLibraryDirectory</A></CODE></DL>
</DD>
<DD><DL>

<DT><B>返回：</B><DD>库加载器使用的当前目录。
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../../java/lang/UnsupportedOperationException.html" title="java.lang 中的类">UnsupportedOperationException</A></CODE> - 如果此实现不支持以这种方式存储本机库。<DT><B>另请参见：</B><DD><A HREF="../../../javax/management/loading/MLet.html#setLibraryDirectory(java.lang.String)"><CODE>setLibraryDirectory(java.lang.String)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="setLibraryDirectory(java.lang.String)"><!-- --></A><H3>
setLibraryDirectory</H3>
<PRE>
public void <B>setLibraryDirectory</B>(<A HREF="../../../java/lang/String.html" title="java.lang 中的类">String</A>&nbsp;libdir)</PRE>
<DL>
<DD>设置在将本机库加载到内存中之前库加载器用来存储这些本机库的目录。
<P>
<DD><DL>
<DT><B>指定者：</B><DD>接口 <CODE><A HREF="../../../javax/management/loading/MLetMBean.html" title="javax.management.loading 中的接口">MLetMBean</A></CODE> 中的 <CODE><A HREF="../../../javax/management/loading/MLetMBean.html#setLibraryDirectory(java.lang.String)">setLibraryDirectory</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>参数：</B><DD><CODE>libdir</CODE> - 库加载器使用的目录。
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../../java/lang/UnsupportedOperationException.html" title="java.lang 中的类">UnsupportedOperationException</A></CODE> - 如果此实现不支持以这种方式存储本机库。<DT><B>另请参见：</B><DD><A HREF="../../../javax/management/loading/MLet.html#getLibraryDirectory()"><CODE>getLibraryDirectory()</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="preRegister(javax.management.MBeanServer, javax.management.ObjectName)"><!-- --></A><H3>
preRegister</H3>
<PRE>
public <A HREF="../../../javax/management/ObjectName.html" title="javax.management 中的类">ObjectName</A> <B>preRegister</B>(<A HREF="../../../javax/management/MBeanServer.html" title="javax.management 中的接口">MBeanServer</A>&nbsp;server,
                              <A HREF="../../../javax/management/ObjectName.html" title="javax.management 中的类">ObjectName</A>&nbsp;name)
                       throws <A HREF="../../../java/lang/Exception.html" title="java.lang 中的类">Exception</A></PRE>
<DL>
<DD>允许在将 m-let 注册到 MBean 之前执行任何所需要的操作。如果 ObjectName 为 null，则 m-let 为它的注册 &lt;defaultDomain&gt;:type=MLet 提供了一个默认名称。
<P>
<DD><DL>
<DT><B>指定者：</B><DD>接口 <CODE><A HREF="../../../javax/management/MBeanRegistration.html" title="javax.management 中的接口">MBeanRegistration</A></CODE> 中的 <CODE><A HREF="../../../javax/management/MBeanRegistration.html#preRegister(javax.management.MBeanServer, javax.management.ObjectName)">preRegister</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>参数：</B><DD><CODE>server</CODE> - 将在其中注册 m-let 的 MBean 服务器。<DD><CODE>name</CODE> - m-let 的对象名称。
<DT><B>返回：</B><DD>所注册的 m-let 名称。
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../../java/lang/Exception.html" title="java.lang 中的类">Exception</A></CODE> - 此异常应由 MBean 服务器捕获，并以 MBeanRegistrationException 的形式重新抛出。</DL>
</DD>
</DL>
<HR>

<A NAME="postRegister(java.lang.Boolean)"><!-- --></A><H3>
postRegister</H3>
<PRE>
public void <B>postRegister</B>(<A HREF="../../../java/lang/Boolean.html" title="java.lang 中的类">Boolean</A>&nbsp;registrationDone)</PRE>
<DL>
<DD>允许 m-let 在已注册到 MBean 服务器之后或注册失败之后执行任何所需要的操作。
<P>
<DD><DL>
<DT><B>指定者：</B><DD>接口 <CODE><A HREF="../../../javax/management/MBeanRegistration.html" title="javax.management 中的接口">MBeanRegistration</A></CODE> 中的 <CODE><A HREF="../../../javax/management/MBeanRegistration.html#postRegister(java.lang.Boolean)">postRegister</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>参数：</B><DD><CODE>registrationDone</CODE> - 指示 m-let 是否已经成功注册到 MBean 服务器。值 false 意味着注册失败。</DL>
</DD>
</DL>
<HR>

<A NAME="preDeregister()"><!-- --></A><H3>
preDeregister</H3>
<PRE>
public void <B>preDeregister</B>()
                   throws <A HREF="../../../java/lang/Exception.html" title="java.lang 中的类">Exception</A></PRE>
<DL>
<DD>允许 m-let 在由 MBean 服务器注销之前执行任何所需要的操作。
<P>
<DD><DL>
<DT><B>指定者：</B><DD>接口 <CODE><A HREF="../../../javax/management/MBeanRegistration.html" title="javax.management 中的接口">MBeanRegistration</A></CODE> 中的 <CODE><A HREF="../../../javax/management/MBeanRegistration.html#preDeregister()">preDeregister</A></CODE></DL>
</DD>
<DD><DL>

<DT><B>抛出：</B>
<DD><CODE>java.langException</CODE> - 此异常应由 MBean 服务器捕获，并以 MBeanRegistrationException 的形式重新抛出它。
<DD><CODE><A HREF="../../../java/lang/Exception.html" title="java.lang 中的类">Exception</A></CODE> - MBean 服务器会捕捉此异常并以 <A HREF="../../../javax/management/MBeanRegistrationException.html" title="javax.management 中的类"><CODE>MBeanRegistrationException</CODE></A> 的形式重新抛出。</DL>
</DD>
</DL>
<HR>

<A NAME="postDeregister()"><!-- --></A><H3>
postDeregister</H3>
<PRE>
public void <B>postDeregister</B>()</PRE>
<DL>
<DD>允许 m-let 在已从 MBean 服务器注销之后执行任何所需要的操作。
<P>
<DD><DL>
<DT><B>指定者：</B><DD>接口 <CODE><A HREF="../../../javax/management/MBeanRegistration.html" title="javax.management 中的接口">MBeanRegistration</A></CODE> 中的 <CODE><A HREF="../../../javax/management/MBeanRegistration.html#postDeregister()">postDeregister</A></CODE></DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="writeExternal(java.io.ObjectOutput)"><!-- --></A><H3>
writeExternal</H3>
<PRE>
public void <B>writeExternal</B>(<A HREF="../../../java/io/ObjectOutput.html" title="java.io 中的接口">ObjectOutput</A>&nbsp;out)
                   throws <A HREF="../../../java/io/IOException.html" title="java.io 中的类">IOException</A>,
                          <A HREF="../../../java/lang/UnsupportedOperationException.html" title="java.lang 中的类">UnsupportedOperationException</A></PRE>
<DL>
<DD><p>将此 MLet 的内容保存到给定的 <A HREF="../../../java/io/ObjectOutput.html" title="java.io 中的接口"><CODE>ObjectOutput</CODE></A>。不是所有的实现都支持此方法。不支持此方法的实现将抛出 <A HREF="../../../java/lang/UnsupportedOperationException.html" title="java.lang 中的类"><CODE>UnsupportedOperationException</CODE></A>。子类可以重写此方法以支持它或更改写入数据的格式。</p>

<p>写入数据的格式是未指定的，但如果某个实现支持 <A HREF="../../../javax/management/loading/MLet.html#writeExternal(java.io.ObjectOutput)"><CODE>writeExternal(java.io.ObjectOutput)</CODE></A>，则它必须也支持 <A HREF="../../../javax/management/loading/MLet.html#readExternal(java.io.ObjectInput)"><CODE>readExternal(java.io.ObjectInput)</CODE></A>，以便后者可以读取前者所写入的内容。</p>
<P>
<DD><DL>
<DT><B>指定者：</B><DD>接口 <CODE><A HREF="../../../java/io/Externalizable.html" title="java.io 中的接口">Externalizable</A></CODE> 中的 <CODE><A HREF="../../../java/io/Externalizable.html#writeExternal(java.io.ObjectOutput)">writeExternal</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>参数：</B><DD><CODE>out</CODE> - 要写入的对象输出流。
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../../java/io/IOException.html" title="java.io 中的类">IOException</A></CODE> - 如果在写入时发生问题。
<DD><CODE><A HREF="../../../java/lang/UnsupportedOperationException.html" title="java.lang 中的类">UnsupportedOperationException</A></CODE> - 如果此实现不支持此操作。</DL>
</DD>
</DL>
<HR>

<A NAME="readExternal(java.io.ObjectInput)"><!-- --></A><H3>
readExternal</H3>
<PRE>
public void <B>readExternal</B>(<A HREF="../../../java/io/ObjectInput.html" title="java.io 中的接口">ObjectInput</A>&nbsp;in)
                  throws <A HREF="../../../java/io/IOException.html" title="java.io 中的类">IOException</A>,
                         <A HREF="../../../java/lang/ClassNotFoundException.html" title="java.lang 中的类">ClassNotFoundException</A>,
                         <A HREF="../../../java/lang/UnsupportedOperationException.html" title="java.lang 中的类">UnsupportedOperationException</A></PRE>
<DL>
<DD><p>从给定的 <A HREF="../../../java/io/ObjectInput.html" title="java.io 中的接口"><CODE>ObjectInput</CODE></A> 恢复此 MLet 的内容。不是所有的实现都支持此方法。不支持此方法的实现将抛出 <A HREF="../../../java/lang/UnsupportedOperationException.html" title="java.lang 中的类"><CODE>UnsupportedOperationException</CODE></A>。子类可以重写此方法以支持它或更改读取数据的格式。</p>

<p>读取数据的格式是未指定的，但如果某个实现支持 <A HREF="../../../javax/management/loading/MLet.html#readExternal(java.io.ObjectInput)"><CODE>readExternal(java.io.ObjectInput)</CODE></A>，则它必须也支持 <A HREF="../../../javax/management/loading/MLet.html#writeExternal(java.io.ObjectOutput)"><CODE>writeExternal(java.io.ObjectOutput)</CODE></A>，以便前者可以读取后者所写入的内容。</p>
<P>
<DD><DL>
<DT><B>指定者：</B><DD>接口 <CODE><A HREF="../../../java/io/Externalizable.html" title="java.io 中的接口">Externalizable</A></CODE> 中的 <CODE><A HREF="../../../java/io/Externalizable.html#readExternal(java.io.ObjectInput)">readExternal</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>参数：</B><DD><CODE>in</CODE> - 要从中读取的对象输入流。
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../../java/io/IOException.html" title="java.io 中的类">IOException</A></CODE> - 如果在读取时出现问题。
<DD><CODE><A HREF="../../../java/lang/ClassNotFoundException.html" title="java.lang 中的类">ClassNotFoundException</A></CODE> - 如果找不到要恢复的对象的类。
<DD><CODE><A HREF="../../../java/lang/UnsupportedOperationException.html" title="java.lang 中的类">UnsupportedOperationException</A></CODE> - 如果此实现不支持此操作。</DL>
</DD>
</DL>
<HR>

<A NAME="loadClass(java.lang.String, javax.management.loading.ClassLoaderRepository)"><!-- --></A><H3>
loadClass</H3>
<PRE>
public <A HREF="../../../java/lang/Class.html" title="java.lang 中的类">Class</A>&lt;?&gt; <B>loadClass</B>(<A HREF="../../../java/lang/String.html" title="java.lang 中的类">String</A>&nbsp;name,
                          <A HREF="../../../javax/management/loading/ClassLoaderRepository.html" title="javax.management.loading 中的接口">ClassLoaderRepository</A>&nbsp;clr)
                   throws <A HREF="../../../java/lang/ClassNotFoundException.html" title="java.lang 中的类">ClassNotFoundException</A></PRE>
<DL>
<DD><p>如果在此 MLet 的 URL 中找不到某个类，则使用给定的 <A HREF="../../../javax/management/loading/ClassLoaderRepository.html" title="javax.management.loading 中的接口"><CODE>ClassLoaderRepository</CODE></A> 加载该类。给定的 ClassLoaderRepository 可以为 null，在这种情况下, 如果在此 MLet 的 URL 中找不到该类，则立即发生 <A HREF="../../../java/lang/ClassNotFoundException.html" title="java.lang 中的类"><CODE>ClassNotFoundException</CODE></A>。</p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>参数：</B><DD><CODE>name</CODE> - 想要加载的类名称。<DD><CODE>clr</CODE> - 在此类加载器中未找到给定类时用于搜索给定类的 ClassLoaderRepository。可以为 null。
<DT><B>返回：</B><DD>得到的 Class 对象。
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../../java/lang/ClassNotFoundException.html" title="java.lang 中的类">ClassNotFoundException</A></CODE> - 如果在此类加载器和给定的 ClassLoaderRepository 中均找不到指定的类。</DL>
</DD>
</DL>
<HR>

<A NAME="findClass(java.lang.String)"><!-- --></A><H3>
findClass</H3>
<PRE>
protected <A HREF="../../../java/lang/Class.html" title="java.lang 中的类">Class</A>&lt;?&gt; <B>findClass</B>(<A HREF="../../../java/lang/String.html" title="java.lang 中的类">String</A>&nbsp;name)
                      throws <A HREF="../../../java/lang/ClassNotFoundException.html" title="java.lang 中的类">ClassNotFoundException</A></PRE>
<DL>
<DD>这是要重新定义的类加载器的主要方法。
<P>
<DD><DL>
<DT><B>覆盖：</B><DD>类 <CODE><A HREF="../../../java/net/URLClassLoader.html" title="java.net 中的类">URLClassLoader</A></CODE> 中的 <CODE><A HREF="../../../java/net/URLClassLoader.html#findClass(java.lang.String)">findClass</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>参数：</B><DD><CODE>name</CODE> - 类的名称。
<DT><B>返回：</B><DD>得到的 Class 对象。
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../../java/lang/ClassNotFoundException.html" title="java.lang 中的类">ClassNotFoundException</A></CODE> - 如果找不到指定的类。</DL>
</DD>
</DL>
<HR>

<A NAME="findLibrary(java.lang.String)"><!-- --></A><H3>
findLibrary</H3>
<PRE>
protected <A HREF="../../../java/lang/String.html" title="java.lang 中的类">String</A> <B>findLibrary</B>(<A HREF="../../../java/lang/String.html" title="java.lang 中的类">String</A>&nbsp;libname)</PRE>
<DL>
<DD>返回本机库的绝对路径名称。虚拟机 (VM) 调用此方法查找属于利用此类加载器加载的类的本机库。首先只使用第一个本机库名称在 JAR 文件中搜索库，如果未找到这样的本机库，则使用本机库名称连同特定于架构的路径名（<code>OSName/OSArch/OSVersion/lib/nativelibname</code>）来搜索，即
 <p>
Solaris SPARC 5.7 上的库 stat 将按照以下方式在 JAR 文件中进行搜索：
 <OL>
 <LI>libstat.so
 <LI>SunOS/sparc/5.7/lib/libstat.so
 </OL>
Windows NT 4.0 上的库 stat 将按照以下方式在 JAR 文件中进行搜索：
 <OL>
 <LI>stat.dll
 <LI>WindowsNT/x86/4.0/lib/stat.dll
 </OL>
 <p>更明确地说，可以设 <em><code>nativelibname</code></em> 为 <A HREF="../../../java/lang/System.html#mapLibraryName(java.lang.String)"><CODE>System.mapLibraryName</CODE></A><code>(libname)</code> 的结果。这样将在 JAR 文件中依次搜索以下名称：<br>
 <em><code>nativelibname</code></em><br>
 <code>&lt;os.name&gt;/&lt;os.arch&gt;/&lt;os.version&gt;/lib/</code><em><code>nativelibname</code></em><br>
 其中 <code>&lt;X&gt;</code> 表示 <code>System.getProperty(X)</code>（结果中不带空格）；<code>/</code> 代表文件分隔符 (<A HREF="../../../java/io/File.html#separator"><CODE>File.separator</CODE></A>)。
 <p>
如果此方法返回 <code>null</code>，即在任何使用此类加载器加载的 JAR 文件中都找不到库，则 VM 根据指定为 <code>java.library.path</code> 属性的路径搜索库。
<P>
<DD><DL>
<DT><B>覆盖：</B><DD>类 <CODE><A HREF="../../../java/lang/ClassLoader.html" title="java.lang 中的类">ClassLoader</A></CODE> 中的 <CODE><A HREF="../../../java/lang/ClassLoader.html#findLibrary(java.lang.String)">findLibrary</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>参数：</B><DD><CODE>libname</CODE> - 库名称。
<DT><B>返回：</B><DD>本机库的绝对路径。<DT><B>另请参见：</B><DD><A HREF="../../../java/lang/System.html#loadLibrary(java.lang.String)"><CODE>System.loadLibrary(String)</CODE></A>, 
<A HREF="../../../java/lang/System.html#mapLibraryName(java.lang.String)"><CODE>System.mapLibraryName(String)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="check(java.lang.String, java.net.URL, java.lang.String, javax.management.loading.MLetContent)"><!-- --></A><H3>
check</H3>
<PRE>
protected <A HREF="../../../java/net/URL.html" title="java.net 中的类">URL</A> <B>check</B>(<A HREF="../../../java/lang/String.html" title="java.lang 中的类">String</A>&nbsp;version,
                    <A HREF="../../../java/net/URL.html" title="java.net 中的类">URL</A>&nbsp;codebase,
                    <A HREF="../../../java/lang/String.html" title="java.lang 中的类">String</A>&nbsp;jarfile,
                    <A HREF="../../../javax/management/loading/MLetContent.html" title="javax.management.loading 中的类">MLetContent</A>&nbsp;mlet)
             throws <A HREF="../../../java/lang/Exception.html" title="java.lang 中的类">Exception</A></PRE>
<DL>
<DD><p>当扩展此服务来支持缓存和版本控制时，要重写此方法。当已经从 MLet 文件提取出版本、代码基和 jarfile 时，从 <A HREF="../../../javax/management/loading/MLet.html#getMBeansFromURL(java.net.URL)"><CODE>getMBeansFromURL</CODE></A> 调用此方法，可以用它验证是否可以正确加载给定的 MBean，或者用不同的 URL 替换给定的 URL。</p>

<p>此方法的默认实现返回未更改的 <code>codebase</code>。</p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>参数：</B><DD><CODE>version</CODE> - 本地存储的 <CODE>.jar</CODE> 文件的版本号。<DD><CODE>codebase</CODE> - 远程 <CODE>.jar</CODE> 文件的基本 URL。<DD><CODE>jarfile</CODE> - 要加载的 <CODE>.jar</CODE> 文件名称。<DD><CODE>mlet</CODE> - 表示 <CODE>MLET</CODE> 标记的 <CODE>MLetContent</CODE> 实例。
<DT><B>返回：</B><DD>用于已加载 MBean 的代码基。返回值应该不为 null。
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../../java/lang/Exception.html" title="java.lang 中的类">Exception</A></CODE> - 如果由于某种原因未加载 MBean。该异常将被添加到 <A HREF="../../../javax/management/loading/MLet.html#getMBeansFromURL(java.net.URL)"><CODE>getMBeansFromURL</CODE></A> 返回的集合中。</DL>
</DD>
</DL>
<!-- ========= END OF CLASS DATA ========= -->
<HR>


<!-- ======= START OF BOTTOM NAVBAR ====== -->
<A NAME="navbar_bottom"><!-- --></A>
<A HREF="#skip-navbar_bottom" title="跳过导航链接"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>概述</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>软件包</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>类</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/MLet.html"><FONT CLASS="NavBarFont1"><B>使用</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>树</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>已过时</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>索引</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>帮助</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
<b>Java<sup><font size=-2>TM</font></sup>&nbsp;Platform<br>Standard&nbsp;Ed. 6</b></EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../../javax/management/loading/DefaultLoaderRepository.html" title="javax.management.loading 中的类"><B>上一个类</B></A>&nbsp;
&nbsp;<A HREF="../../../javax/management/loading/MLetContent.html" title="javax.management.loading 中的类"><B>下一个类</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../index.html?javax/management/loading/MLet.html" target="_top"><B>框架</B></A>  &nbsp;
&nbsp;<A HREF="MLet.html" target="_top"><B>无框架</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../allclasses-noframe.html"><B>所有类</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../allclasses-noframe.html"><B>所有类</B></A>
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  摘要：&nbsp;嵌套&nbsp;|&nbsp;字段&nbsp;|&nbsp;<A HREF="#constructor_summary">构造方法</A>&nbsp;|&nbsp;<A HREF="#method_summary">方法</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
详细信息：&nbsp;字段&nbsp;|&nbsp;<A HREF="#constructor_detail">构造方法</A>&nbsp;|&nbsp;<A HREF="#method_detail">方法</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_bottom"></A>
<!-- ======== END OF BOTTOM NAVBAR ======= -->

<HR>
<font size="-1"><a href="http://bugs.sun.com/services/bugreport/index.jsp">提交错误或意见</a><br>有关更多的 API 参考资料和开发人员文档，请参阅 <a href="http://java.sun.com/javase/6/webnotes/devdocs-vs-specs.html">Java SE 开发人员文档</a>。该文档包含更详细的、面向开发人员的描述，以及总体概述、术语定义、使用技巧和工作代码示例。 <p>版权所有 2007 Sun Microsystems, Inc. 保留所有权利。 请遵守<a href="http://java.sun.com/javase/6/docs/legal/license.html">许可证条款</a>。另请参阅<a href="http://java.sun.com/docs/redist.html">文档重新分发政策</a>。</font>
</BODY>
</HTML>
