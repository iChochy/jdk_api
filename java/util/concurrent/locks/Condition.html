<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc (build 1.6.0-beta2) on Mon Mar 19 18:27:54 CST 2007 -->
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
<TITLE>
Condition (Java Platform SE 6)
</TITLE>

<META NAME="date" CONTENT="2007-03-19">

<LINK REL ="stylesheet" TYPE="text/css" HREF="../../../../stylesheet.css" TITLE="Style">

<SCRIPT type="text/javascript">
function windowTitle()
{
    if (location.href.indexOf('is-external=true') == -1) {
        parent.document.title="Condition (Java Platform SE 6)";
    }
}
</SCRIPT>
<NOSCRIPT>
</NOSCRIPT>

</HEAD>

<BODY BGCOLOR="white" onload="windowTitle();">
<HR>


<!-- ========= START OF TOP NAVBAR ======= -->
<A NAME="navbar_top"><!-- --></A>
<A HREF="#skip-navbar_top" title="跳过导航链接"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>概述</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>软件包</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>类</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/Condition.html"><FONT CLASS="NavBarFont1"><B>使用</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>树</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>已过时</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>索引</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>帮助</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
<b>Java<sup><font size=-2>TM</font></sup>&nbsp;Platform<br>Standard&nbsp;Ed. 6</b></EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../../../java/util/concurrent/locks/AbstractQueuedSynchronizer.ConditionObject.html" title="java.util.concurrent.locks 中的类"><B>上一个类</B></A>&nbsp;
&nbsp;<A HREF="../../../../java/util/concurrent/locks/Lock.html" title="java.util.concurrent.locks 中的接口"><B>下一个类</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../../index.html?java/util/concurrent/locks/Condition.html" target="_top"><B>框架</B></A>  &nbsp;
&nbsp;<A HREF="Condition.html" target="_top"><B>无框架</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../../allclasses-noframe.html"><B>所有类</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../../allclasses-noframe.html"><B>所有类</B></A>
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  摘要：&nbsp;嵌套&nbsp;|&nbsp;字段&nbsp;|&nbsp;构造方法&nbsp;|&nbsp;<A HREF="#method_summary">方法</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
详细信息：&nbsp;字段&nbsp;|&nbsp;构造方法&nbsp;|&nbsp;<A HREF="#method_detail">方法</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_top"></A>
<!-- ========= END OF TOP NAVBAR ========= -->

<HR>
<!-- ======== START OF CLASS DATA ======== -->
<H2>
<FONT SIZE="-1">
java.util.concurrent.locks</FONT>
<BR>
接口 Condition</H2>
<DL>
<DT><B>所有已知实现类：</B> <DD><A HREF="../../../../java/util/concurrent/locks/AbstractQueuedLongSynchronizer.ConditionObject.html" title="java.util.concurrent.locks 中的类">AbstractQueuedLongSynchronizer.ConditionObject</A>, <A HREF="../../../../java/util/concurrent/locks/AbstractQueuedSynchronizer.ConditionObject.html" title="java.util.concurrent.locks 中的类">AbstractQueuedSynchronizer.ConditionObject</A></DD>
</DL>
<HR>
<DL>
<DT><PRE>public interface <B>Condition</B></DL>
</PRE>

<P>
<code>Condition</code> 将 <code>Object</code> 监视器方法（<A HREF="../../../../java/lang/Object.html#wait()"><CODE>wait</CODE></A>、<A HREF="../../../../java/lang/Object.html#notify()"><CODE>notify</CODE></A> 和 <A HREF="../../../../java/lang/Object.html#notifyAll()"><CODE>notifyAll</CODE></A>）分解成截然不同的对象，以便通过将这些对象与任意 <A HREF="../../../../java/util/concurrent/locks/Lock.html" title="java.util.concurrent.locks 中的接口"><CODE>Lock</CODE></A> 实现组合使用，为每个对象提供多个等待 set（wait-set）。其中，<code>Lock</code> 替代了 <code>synchronized</code> 方法和语句的使用，<code>Condition</code> 替代了 Object 监视器方法的使用。

<p>条件（也称为<em>条件队列</em> 或<em>条件变量</em>）为线程提供了一个含义，以便在某个状态条件现在可能为 true 的另一个线程通知它之前，一直挂起该线程（即让其&ldquo;等待&rdquo;）。因为访问此共享状态信息发生在不同的线程中，所以它必须受保护，因此要将某种形式的锁与该条件相关联。等待提供一个条件的主要属性是：<em>以原子方式</em> 释放相关的锁，并挂起当前线程，就像 <code>Object.wait</code> 做的那样。

<p><code>Condition</code> 实例实质上被绑定到一个锁上。要为特定 <A HREF="../../../../java/util/concurrent/locks/Lock.html" title="java.util.concurrent.locks 中的接口"><CODE>Lock</CODE></A> 实例获得 <code>Condition</code> 实例，请使用其 <A HREF="../../../../java/util/concurrent/locks/Lock.html#newCondition()"><CODE>newCondition()</CODE></A> 方法。

<p>作为一个示例，假定有一个绑定的缓冲区，它支持 <code>put</code> 和 <code>take</code> 方法。如果试图在空的缓冲区上执行 <code>take</code> 操作，则在某一个项变得可用之前，线程将一直阻塞；如果试图在满的缓冲区上执行 <code>put</code> 操作，则在有空间变得可用之前，线程将一直阻塞。我们喜欢在单独的等待 set 中保存 <code>put</code> 线程和 <code>take</code> 线程，这样就可以在缓冲区中的项或空间变得可用时利用最佳规划，一次只通知一个线程。可以使用两个 <A HREF="../../../../java/util/concurrent/locks/Condition.html" title="java.util.concurrent.locks 中的接口"><CODE>Condition</CODE></A> 实例来做到这一点。
 <pre>
 class BoundedBuffer {
   <b>final Lock lock = new ReentrantLock();</b>
   final Condition notFull  = <b>lock.newCondition(); </b>
   final Condition notEmpty = <b>lock.newCondition(); </b>

   final Object[] items = new Object[100];
   int putptr, takeptr, count;

   public void put(Object x) throws InterruptedException {
     <b>lock.lock();
     try {</b>
       while (count == items.length) 
         <b>notFull.await();</b>
       items[putptr] = x; 
       if (++putptr == items.length) putptr = 0;
       ++count;
       <b>notEmpty.signal();</b>
     <b>} finally {
       lock.unlock();
     }</b>
   }

   public Object take() throws InterruptedException {
     <b>lock.lock();
     try {</b>
       while (count == 0) 
         <b>notEmpty.await();</b>
       Object x = items[takeptr]; 
       if (++takeptr == items.length) takeptr = 0;
       --count;
       <b>notFull.signal();</b>
       return x;
     <b>} finally {
       lock.unlock();
     }</b>
   } 
 }
 </pre>

（<A HREF="../../../../java/util/concurrent/ArrayBlockingQueue.html" title="java.util.concurrent 中的类"><CODE>ArrayBlockingQueue</CODE></A> 类提供了这项功能，因此没有理由去实现这个示例类。）

<p><code>Condition</code> 实现可以提供不同于 <code>Object</code> 监视器方法的行为和语义，比如受保证的通知排序，或者在执行通知时不需要保持一个锁。如果某个实现提供了这样特殊的语义，则该实现必须记录这些语义。

<p>注意，<code>Condition</code> 实例只是一些普通的对象，它们自身可以用作 <code>synchronized</code> 语句中的目标，并且可以调用自己的 <A HREF="../../../../java/lang/Object.html#wait(long)"><CODE>wait</CODE></A> 和 <A HREF="../../../../java/lang/Object.html#notify()"><CODE>notification</CODE></A> 监视器方法。获取 <code>Condition</code> 实例的监视器锁或者使用其监视器方法，与获取和该 <code>Condition</code> 相关的 <A HREF="../../../../java/util/concurrent/locks/Lock.html" title="java.util.concurrent.locks 中的接口"><CODE>Lock</CODE></A> 或使用其 <A HREF="../../../../java/util/concurrent/locks/Condition.html#await()"><CODE>waiting</CODE></A> 和 <A HREF="../../../../java/util/concurrent/locks/Condition.html#signal()"><CODE>signalling</CODE></A> 方法没有什么特定的关系。为了避免混淆，建议除了在其自身的实现中之外，切勿以这种方式使用 <code>Condition</code> 实例。

<p>除非另行说明，否则为任何参数传递 <code>null</code> 值将导致抛出 <A HREF="../../../../java/lang/NullPointerException.html" title="java.lang 中的类"><CODE>NullPointerException</CODE></A>。

<h3>实现注意事项</h3>

<p>在等待 <code>Condition</code> 时，允许发生&ldquo;<em>虚假唤醒</em>&rdquo;，这通常作为对基础平台语义的让步。对于大多数应用程序，这带来的实际影响很小，因为 <code>Condition</code> 应该总是在一个循环中被等待，并测试正被等待的状态声明。某个实现可以随意移除可能的虚假唤醒，但建议应用程序程序员总是假定这些虚假唤醒可能发生，因此总是在一个循环中等待。

<p>三种形式的条件等待（可中断、不可中断和超时）在一些平台上的实现以及它们的性能特征可能会有所不同。尤其是它可能很难提供这些特性和维护特定语义，比如排序保证。更进一步地说，中断线程实际挂起的能力在所有平台上并不是总是可行的。
<p>因此，并不要求某个实现为所有三种形式的等待定义完全相同的保证或语义，也不要求其支持中断线程的实际挂起。
<p>要求实现清楚地记录每个等待方法提供的语义和保证，在某个实现不支持中断线程的挂起时，它必须遵从此接口中定义的中断语义。
<p>由于中断通常意味着取消，而又通常很少进行中断检查，因此实现可以先于普通方法的返回来对中断进行响应。即使出现在另一个操作后的中断可能会释放线程锁时也是如此。实现应记录此行为。
<P>

<P>
<DL>
<DT><B>从以下版本开始：</B></DT>
  <DD>1.5</DD>
</DL>
<HR>

<P>

<!-- ========== METHOD SUMMARY =========== -->

<A NAME="method_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>方法摘要</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../java/util/concurrent/locks/Condition.html#await()">await</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;造成当前线程在接到信号或被<A HREF="../../../../java/lang/Thread.html#interrupt()">中断</A>之前一直处于等待状态。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../java/util/concurrent/locks/Condition.html#await(long, java.util.concurrent.TimeUnit)">await</A></B>(long&nbsp;time,
      <A HREF="../../../../java/util/concurrent/TimeUnit.html" title="java.util.concurrent 中的枚举">TimeUnit</A>&nbsp;unit)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;造成当前线程在接到信号、被中断或到达指定等待时间之前一直处于等待状态。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;long</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../java/util/concurrent/locks/Condition.html#awaitNanos(long)">awaitNanos</A></B>(long&nbsp;nanosTimeout)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;造成当前线程在接到信号、被中断或到达指定等待时间之前一直处于等待状态。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../java/util/concurrent/locks/Condition.html#awaitUninterruptibly()">awaitUninterruptibly</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;造成当前线程在接到信号之前一直处于等待状态。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../java/util/concurrent/locks/Condition.html#awaitUntil(java.util.Date)">awaitUntil</A></B>(<A HREF="../../../../java/util/Date.html" title="java.util 中的类">Date</A>&nbsp;deadline)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;造成当前线程在接到信号、被中断或到达指定最后期限之前一直处于等待状态。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../java/util/concurrent/locks/Condition.html#signal()">signal</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;唤醒一个等待线程。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../java/util/concurrent/locks/Condition.html#signalAll()">signalAll</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;唤醒所有等待线程。</TD>
</TR>
</TABLE>
&nbsp;
<P>

<!-- ============ METHOD DETAIL ========== -->

<A NAME="method_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>方法详细信息</B></FONT></TH>
</TR>
</TABLE>

<A NAME="await()"><!-- --></A><H3>
await</H3>
<PRE>
void <B>await</B>()
           throws <A HREF="../../../../java/lang/InterruptedException.html" title="java.lang 中的类">InterruptedException</A></PRE>
<DL>
<DD>造成当前线程在接到信号或被<A HREF="../../../../java/lang/Thread.html#interrupt()">中断</A>之前一直处于等待状态。

<p>与此 <code>Condition</code> 相关的锁以原子方式释放，并且出于线程调度的目的，将禁用当前线程，且在发生以下四种情况<em>之一</em> 以前，当前线程将一直处于休眠状态：
 <ul>
<li>其他某个线程调用此 <code>Condition</code> 的 <A HREF="../../../../java/util/concurrent/locks/Condition.html#signal()"><CODE>signal()</CODE></A> 方法，并且碰巧将当前线程选为被唤醒的线程；或者
<li>其他某个线程调用此 <code>Condition</code> 的 <A HREF="../../../../java/util/concurrent/locks/Condition.html#signalAll()"><CODE>signalAll()</CODE></A> 方法；或者
<li>其他某个线程<A HREF="../../../../java/lang/Thread.html#interrupt()">中断</A>当前线程，且支持中断线程的挂起；或者
<li>发生&ldquo;<em>虚假唤醒</em>&rdquo;
 </ul>

<p>在所有情况下，在此方法可以返回当前线程之前，都必须重新获取与此条件有关的锁。在线程返回时，可以<em>保证</em> 它保持此锁。

<p>如果当前线程：
 <ul>
<li>在进入此方法时已经设置了该线程的中断状态；或者
<li>在支持等待和中断线程挂起时，线程被<A HREF="../../../../java/lang/Thread.html#interrupt()">中断</A>， 
 </ul>
则抛出 <A HREF="../../../../java/lang/InterruptedException.html" title="java.lang 中的类"><CODE>InterruptedException</CODE></A>，并清除当前线程的中断状态。在第一种情况下，没有指定是否在释放锁之前发生中断测试。
 
<p><b>实现注意事项</b>
<p>假定调用此方法时，当前线程保持了与此 <code>Condition</code> 有关联的锁。这取决于确定是否为这种情况以及不是时，如何对此作出响应的实现。通常，将抛出一个异常（比如 <A HREF="../../../../java/lang/IllegalMonitorStateException.html" title="java.lang 中的类"><CODE>IllegalMonitorStateException</CODE></A>）并且该实现必须对此进行记录。

<p>与响应某个信号而返回的普通方法相比，实现可能更喜欢响应某个中断。在这种情况下，实现必须确保信号被重定向到另一个等待线程（如果有的话）。
<P>
<DD><DL>

<DT><B>抛出：</B>
<DD><CODE><A HREF="../../../../java/lang/InterruptedException.html" title="java.lang 中的类">InterruptedException</A></CODE> - 如果当前线程被中断（并且支持中断线程挂起）</DL>
</DD>
</DL>
<HR>

<A NAME="awaitUninterruptibly()"><!-- --></A><H3>
awaitUninterruptibly</H3>
<PRE>
void <B>awaitUninterruptibly</B>()</PRE>
<DL>
<DD>造成当前线程在接到信号之前一直处于等待状态。

<p>与此条件相关的锁以原子方式释放，并且出于线程调度的目的，将禁用当前线程，且在发生以下三种情况<em>之一</em> 以前，当前线程将一直处于休眠状态：
 <ul>
<li>其他某个线程调用此 <code>Condition</code> 的 <A HREF="../../../../java/util/concurrent/locks/Condition.html#signal()"><CODE>signal()</CODE></A> 方法，并且碰巧将当前线程选为被唤醒的线程；或者
<li>其他某个线程调用此 <code>Condition</code> 的 <A HREF="../../../../java/util/concurrent/locks/Condition.html#signalAll()"><CODE>signalAll()</CODE></A> 方法；或者
<li>发生&ldquo;<em>虚假唤醒</em>&rdquo;
 </ul>

<p>在所有情况下，在此方法可以返回当前线程之前，都必须重新获取与此条件有关的锁。在线程返回时，可以<em>保证</em> 它保持此锁。

<p>如果在进入此方法时设置了当前线程的中断状态，或者在等待时，线程被<A HREF="../../../../java/lang/Thread.html#interrupt()">中断</A>，那么在接到信号之前，它将继续等待。当最终从此方法返回时，仍然将设置其中断状态。
 
<p><b>实现注意事项</b>
<p>假定调用此方法时，当前线程保持了与此 <code>Condition</code> 有关联的锁。这取决于确定是否为这种情况以及不是时，如何对此作出响应的实现。通常，将抛出一个异常（比如 <A HREF="../../../../java/lang/IllegalMonitorStateException.html" title="java.lang 中的类"><CODE>IllegalMonitorStateException</CODE></A>）并且该实现必须对此进行记录。
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="awaitNanos(long)"><!-- --></A><H3>
awaitNanos</H3>
<PRE>
long <B>awaitNanos</B>(long&nbsp;nanosTimeout)
                throws <A HREF="../../../../java/lang/InterruptedException.html" title="java.lang 中的类">InterruptedException</A></PRE>
<DL>
<DD>造成当前线程在接到信号、被中断或到达指定等待时间之前一直处于等待状态。

<p>与此条件相关的锁以原子方式释放，并且出于线程调度的目的，将禁用当前线程，且在发生以下五种情况<em>之一</em> 以前，当前线程将一直处于休眠状态：
 <ul>
<li>其他某个线程调用此 <code>Condition</code> 的 <A HREF="../../../../java/util/concurrent/locks/Condition.html#signal()"><CODE>signal()</CODE></A> 方法，并且碰巧将当前线程选为被唤醒的线程；或者 
<li>其他某个线程调用此 <code>Condition</code> 的 <A HREF="../../../../java/util/concurrent/locks/Condition.html#signalAll()"><CODE>signalAll()</CODE></A> 方法；或者
<li>其他某个线程<A HREF="../../../../java/lang/Thread.html#interrupt()">中断</A>当前线程，且支持中断线程的挂起；或者
<li>已超过指定的等待时间；或者
<li>发生&ldquo;<em>虚假唤醒</em>&rdquo;。
 </ul>

<p>在所有情况下，在此方法可以返回当前线程之前，都必须重新获取与此条件有关的锁。在线程返回时，可以<em>保证</em> 它保持此锁。

<p>如果当前线程：
 <ul>
<li>在进入此方法时已经设置了该线程的中断状态；或者
<li>在支持等待和中断线程挂起时，线程被<A HREF="../../../../java/lang/Thread.html#interrupt()">中断</A>， 
 </ul>
则抛出 <A HREF="../../../../java/lang/InterruptedException.html" title="java.lang 中的类"><CODE>InterruptedException</CODE></A>，并且清除当前线程的已中断状态。在第一种情况下，没有指定是否在释放锁之前发生中断测试。

<p>在返回时，该方法返回了所剩毫微秒数的一个估计值，以等待所提供的 <code>nanosTimeout</code> 值的时间，如果超时，则返回一个小于等于 0 的值。可以用此值来确定在等待返回但某一等待条件仍不具备的情况下，是否要再次等待，以及再次等待的时间。此方法的典型用法采用以下形式：

 <pre>
 synchronized boolean aMethod(long timeout, TimeUnit unit) {
   long nanosTimeout = unit.toNanos(timeout);
   while (!conditionBeingWaitedFor) {
     if (nanosTimeout &gt; 0)
         nanosTimeout = theCondition.awaitNanos(nanosTimeout);
      else
        return false;
   }
   // ... 
 }
 </pre>

<p> 设计注意事项：此方法需要一个 nanosecond 参数，以避免在报告剩余时间时出现截断错误。在发生重新等待时，这种精度损失使得程序员难以确保总的等待时间不少于指定等待时间。

<p><b>实现注意事项</b>
<p>假定调用此方法时，当前线程保持了与此 <code>Condition</code> 有关联的锁。这取决于确定是否为这种情况以及不是时，如何对此作出响应的实现。通常会抛出一个异常（比如 <A HREF="../../../../java/lang/IllegalMonitorStateException.html" title="java.lang 中的类"><CODE>IllegalMonitorStateException</CODE></A>）并且该实现必须对此进行记录。

<p>与响应某个信号而返回的普通方法相比，或者与指示所使用的指定等待时间相比，实现可能更喜欢响应某个中断。在任意一种情况下，实现必须确保信号被重定向到另一个等待线程（如果有的话）。
<P>
<DD><DL>
<DT><B>参数：</B><DD><CODE>nanosTimeout</CODE> - 等待的最长时间，以毫微秒为单位
<DT><B>返回：</B><DD><code>nanosTimeout</code> 值减去花费在等待此方法的返回结果的时间的估算。正值可以用作对此方法进行后续调用的参数，来完成等待所需时间结束。小于等于零的值表示没有剩余时间。
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../../../java/lang/InterruptedException.html" title="java.lang 中的类">InterruptedException</A></CODE> - 如果当前线程被中断（并且支持中断线程挂起）</DL>
</DD>
</DL>
<HR>

<A NAME="await(long, java.util.concurrent.TimeUnit)"><!-- --></A><H3>
await</H3>
<PRE>
boolean <B>await</B>(long&nbsp;time,
              <A HREF="../../../../java/util/concurrent/TimeUnit.html" title="java.util.concurrent 中的枚举">TimeUnit</A>&nbsp;unit)
              throws <A HREF="../../../../java/lang/InterruptedException.html" title="java.lang 中的类">InterruptedException</A></PRE>
<DL>
<DD>造成当前线程在接到信号、被中断或到达指定等待时间之前一直处于等待状态。此方法在行为上等效于：<br>
 <pre>
   awaitNanos(unit.toNanos(time)) &gt; 0
 </pre>
<P>
<DD><DL>
<DT><B>参数：</B><DD><CODE>time</CODE> - 最长等待时间<DD><CODE>unit</CODE> - <code>time</code> 参数的时间单位
<DT><B>返回：</B><DD>如果在从此方法返回前检测到等待时间超时，则返回 <code>false</code>，否则返回 <code>true</code>
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../../../java/lang/InterruptedException.html" title="java.lang 中的类">InterruptedException</A></CODE> - 如果当前线程被中断（并且支持中断线程挂起）</DL>
</DD>
</DL>
<HR>

<A NAME="awaitUntil(java.util.Date)"><!-- --></A><H3>
awaitUntil</H3>
<PRE>
boolean <B>awaitUntil</B>(<A HREF="../../../../java/util/Date.html" title="java.util 中的类">Date</A>&nbsp;deadline)
                   throws <A HREF="../../../../java/lang/InterruptedException.html" title="java.lang 中的类">InterruptedException</A></PRE>
<DL>
<DD>造成当前线程在接到信号、被中断或到达指定最后期限之前一直处于等待状态。

<p>与此条件相关的锁以原子方式释放，并且出于线程调度的目的，将禁用当前线程，且在发生以下五种情况<em>之一</em> 以前，当前线程将一直处于休眠状态：
 <ul>
<li>其他某个线程调用此 <code>Condition</code> 的 <A HREF="../../../../java/util/concurrent/locks/Condition.html#signal()"><CODE>signal()</CODE></A> 方法，并且碰巧将当前线程选为被唤醒的线程；或者 
<li>其他某个线程调用此 <code>Condition</code> 的 <A HREF="../../../../java/util/concurrent/locks/Condition.html#signalAll()"><CODE>signalAll()</CODE></A> 方法；或者
<li>其他某个线程<A HREF="../../../../java/lang/Thread.html#interrupt()">中断</A>当前线程，且支持中断线程的挂起；或者
<li>指定的最后期限到了；或者
<li>发生&ldquo;<em>虚假唤醒</em>&rdquo;。
 </ul>

<p>在所有情况下，在此方法可以返回当前线程之前，都必须重新获取与此条件有关的锁。在线程返回时，可以<em>保证</em> 它保持此锁。


<p>如果当前线程：
 <ul>
<li>在进入此方法时已经设置了该线程的中断状态；或者
<li>在支持等待和中断线程挂起时，线程被<A HREF="../../../../java/lang/Thread.html#interrupt()">中断</A>， 
 </ul>
则抛出 <A HREF="../../../../java/lang/InterruptedException.html" title="java.lang 中的类"><CODE>InterruptedException</CODE></A>，并且清除当前线程的已中断状态。在第一种情况下，没有指定是否在释放锁之前发生中断测试。


<p>返回值指示是否到达最后期限，使用方式如下：
 <pre>
 synchronized boolean aMethod(Date deadline) {
   boolean stillWaiting = true;
   while (!conditionBeingWaitedFor) {
     if (stillWaiting)
         stillWaiting = theCondition.awaitUntil(deadline);
      else
        return false;
   }
   // ... 
 }
 </pre>

<p><b>实现注意事项</b>
<p>假定调用此方法时，当前线程保持了与此 <code>Condition</code> 有关联的锁。这取决于确定是否为这种情况以及不是时，如何对此作出响应的实现。通常，将抛出一个异常（比如 <A HREF="../../../../java/lang/IllegalMonitorStateException.html" title="java.lang 中的类"><CODE>IllegalMonitorStateException</CODE></A>）并且该实现必须对此进行记录。

<p>与响应某个信号而返回的普通方法相比，或者与指示是否到达指定最终期限相比，实现可能更喜欢响应某个中断。在任意一种情况下，实现必须确保信号被重定向到另一个等待线程（如果有的话）。
<P>
<DD><DL>
<DT><B>参数：</B><DD><CODE>deadline</CODE> - 一直处于等待状态的绝对时间
<DT><B>返回：</B><DD>如果在返回时已经到达最后期限，则返回 <code>false</code>，否则返回 <code>true</code>
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../../../java/lang/InterruptedException.html" title="java.lang 中的类">InterruptedException</A></CODE> - 如果当前线程被中断（并且支持中断线程挂起）</DL>
</DD>
</DL>
<HR>

<A NAME="signal()"><!-- --></A><H3>
signal</H3>
<PRE>
void <B>signal</B>()</PRE>
<DL>
<DD>唤醒一个等待线程。

<p>如果所有的线程都在等待此条件，则选择其中的一个唤醒。在从 <code>await</code> 返回之前，该线程必须重新获取锁。
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="signalAll()"><!-- --></A><H3>
signalAll</H3>
<PRE>
void <B>signalAll</B>()</PRE>
<DL>
<DD>唤醒所有等待线程。

<p>如果所有的线程都在等待此条件，则唤醒所有线程。在从 <code>await</code> 返回之前，每个线程都必须重新获取锁。
<P>
<DD><DL>
</DL>
</DD>
</DL>
<!-- ========= END OF CLASS DATA ========= -->
<HR>


<!-- ======= START OF BOTTOM NAVBAR ====== -->
<A NAME="navbar_bottom"><!-- --></A>
<A HREF="#skip-navbar_bottom" title="跳过导航链接"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>概述</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>软件包</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>类</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/Condition.html"><FONT CLASS="NavBarFont1"><B>使用</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>树</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>已过时</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>索引</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>帮助</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
<b>Java<sup><font size=-2>TM</font></sup>&nbsp;Platform<br>Standard&nbsp;Ed. 6</b></EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../../../java/util/concurrent/locks/AbstractQueuedSynchronizer.ConditionObject.html" title="java.util.concurrent.locks 中的类"><B>上一个类</B></A>&nbsp;
&nbsp;<A HREF="../../../../java/util/concurrent/locks/Lock.html" title="java.util.concurrent.locks 中的接口"><B>下一个类</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../../index.html?java/util/concurrent/locks/Condition.html" target="_top"><B>框架</B></A>  &nbsp;
&nbsp;<A HREF="Condition.html" target="_top"><B>无框架</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../../allclasses-noframe.html"><B>所有类</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../../allclasses-noframe.html"><B>所有类</B></A>
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  摘要：&nbsp;嵌套&nbsp;|&nbsp;字段&nbsp;|&nbsp;构造方法&nbsp;|&nbsp;<A HREF="#method_summary">方法</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
详细信息：&nbsp;字段&nbsp;|&nbsp;构造方法&nbsp;|&nbsp;<A HREF="#method_detail">方法</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_bottom"></A>
<!-- ======== END OF BOTTOM NAVBAR ======= -->

<HR>
<font size="-1"><a href="http://bugs.sun.com/services/bugreport/index.jsp">提交错误或意见</a><br>有关更多的 API 参考资料和开发人员文档，请参阅 <a href="http://java.sun.com/javase/6/webnotes/devdocs-vs-specs.html">Java SE 开发人员文档</a>。该文档包含更详细的、面向开发人员的描述，以及总体概述、术语定义、使用技巧和工作代码示例。 <p>版权所有 2007 Sun Microsystems, Inc. 保留所有权利。 请遵守<a href="http://java.sun.com/javase/6/docs/legal/license.html">许可证条款</a>。另请参阅<a href="http://java.sun.com/docs/redist.html">文档重新分发政策</a>。</font>
</BODY>
</HTML>
