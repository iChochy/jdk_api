<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc (build 1.6.0-beta2) on Mon Mar 19 18:22:42 CST 2007 -->
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
<TITLE>
ClassLoader (Java Platform SE 6)
</TITLE>

<META NAME="date" CONTENT="2007-03-19">

<LINK REL ="stylesheet" TYPE="text/css" HREF="../../stylesheet.css" TITLE="Style">

<SCRIPT type="text/javascript">
function windowTitle()
{
    if (location.href.indexOf('is-external=true') == -1) {
        parent.document.title="ClassLoader (Java Platform SE 6)";
    }
}
</SCRIPT>
<NOSCRIPT>
</NOSCRIPT>

</HEAD>

<BODY BGCOLOR="white" onload="windowTitle();">
<HR>


<!-- ========= START OF TOP NAVBAR ======= -->
<A NAME="navbar_top"><!-- --></A>
<A HREF="#skip-navbar_top" title="跳过导航链接"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>概述</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>软件包</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>类</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/ClassLoader.html"><FONT CLASS="NavBarFont1"><B>使用</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>树</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>已过时</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>索引</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../help-doc.html"><FONT CLASS="NavBarFont1"><B>帮助</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
<b>Java<sup><font size=-2>TM</font></sup>&nbsp;Platform<br>Standard&nbsp;Ed. 6</b></EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../java/lang/ClassFormatError.html" title="java.lang 中的类"><B>上一个类</B></A>&nbsp;
&nbsp;<A HREF="../../java/lang/ClassNotFoundException.html" title="java.lang 中的类"><B>下一个类</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../index.html?java/lang/ClassLoader.html" target="_top"><B>框架</B></A>  &nbsp;
&nbsp;<A HREF="ClassLoader.html" target="_top"><B>无框架</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../allclasses-noframe.html"><B>所有类</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../allclasses-noframe.html"><B>所有类</B></A>
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  摘要：&nbsp;嵌套&nbsp;|&nbsp;字段&nbsp;|&nbsp;<A HREF="#constructor_summary">构造方法</A>&nbsp;|&nbsp;<A HREF="#method_summary">方法</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
详细信息：&nbsp;字段&nbsp;|&nbsp;<A HREF="#constructor_detail">构造方法</A>&nbsp;|&nbsp;<A HREF="#method_detail">方法</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_top"></A>
<!-- ========= END OF TOP NAVBAR ========= -->

<HR>
<!-- ======== START OF CLASS DATA ======== -->
<H2>
<FONT SIZE="-1">
java.lang</FONT>
<BR>
类 ClassLoader</H2>
<PRE>
<A HREF="../../java/lang/Object.html" title="java.lang 中的类">java.lang.Object</A>
  <IMG SRC="../../resources/inherit.gif" ALT="继承者 "><B>java.lang.ClassLoader</B>
</PRE>
<DL>
<DT><B>直接已知子类：</B> <DD><A HREF="../../java/security/SecureClassLoader.html" title="java.security 中的类">SecureClassLoader</A></DD>
</DL>
<HR>
<DL>
<DT><PRE>public abstract class <B>ClassLoader</B><DT>extends <A HREF="../../java/lang/Object.html" title="java.lang 中的类">Object</A></DL>
</PRE>

<P>
类加载器是负责加载类的对象。<tt>ClassLoader</tt> 类是一个抽象类。如果给定类的<a href="#name">二进制名称</a>，那么类加载器会试图查找或生成构成类定义的数据。一般策略是将名称转换为某个文件名，然后从文件系统读取该名称的&ldquo;类文件&rdquo;。

<p> 每个 <A HREF="../../java/lang/Class.html" title="java.lang 中的类"><CODE><tt>Class</tt></CODE></A> 对象都包含一个对定义它的 <tt>ClassLoader</tt> 的<A HREF="../../java/lang/Class.html#getClassLoader()"><CODE>引用</CODE></A>。

<p> 数组类的 <tt>Class</tt> 对象不是由类加载器创建的，而是由 Java 运行时根据需要自动创建。数组类的类加载器由 <A HREF="../../java/lang/Class.html#getClassLoader()"><CODE>Class.getClassLoader()</CODE></A> 返回，该加载器与其元素类型的类加载器是相同的；如果该元素类型是基本类型，则该数组类没有类加载器。

<p> 应用程序需要实现 <tt>ClassLoader</tt> 的子类，以扩展 Java 虚拟机动态加载类的方式。

<p> 类加载器通常由安全管理器使用，用于指示安全域。

<p> <tt>ClassLoader</tt> 类使用委托模型来搜索类和资源。每个 <tt>ClassLoader</tt> 实例都有一个相关的父类加载器。需要查找类或资源时，<tt>ClassLoader</tt> 实例会在试图亲自查找类或资源之前，将搜索类或资源的任务委托给其父类加载器。虚拟机的内置类加载器（称为 "bootstrap class loader"）本身没有父类加载器，但是可以将它用作 <tt>ClassLoader</tt> 实例的父类加载器。

<p> 通常情况下，Java 虚拟机以与平台有关的方式，从本地文件系统中加载类。例如，在 UNIX 系统中，虚拟机从 <tt>CLASSPATH</tt> 环境变量定义的目录中加载类。

<p> 然而，有些类可能并非源自一个文件；它们可能源自其他来源（如网络），也可能是由应用程序构造的。<A HREF="../../java/lang/ClassLoader.html#defineClass(java.lang.String, byte[], int, int)"><CODE><tt>defineClass</tt></CODE></A> 方法将一个 byte 数组转换为 <tt>Class</tt> 类的实例。这种新定义的类的实例可以使用 <A HREF="../../java/lang/Class.html#newInstance()"><CODE><tt>Class.newInstance</tt></CODE></A> 来创建。

<p> 类加载器所创建对象的方法和构造方法可以引用其他类。为了确定引用的类，Java 虚拟机将调用最初创建该类的类加载器的 <A HREF="../../java/lang/ClassLoader.html#loadClass(java.lang.String)"><CODE><tt>loadClass</tt></CODE></A> 方法。

<p> 例如，应用程序可以创建一个网络类加载器，从服务器中下载类文件。示例代码如下所示：

 <blockquote><pre>
   ClassLoader loader&nbsp;= new NetworkClassLoader(host,&nbsp;port);
   Object main&nbsp;= loader.loadClass(&quot;Main&quot;, true).newInstance();
         &nbsp;.&nbsp;.&nbsp;.
 </pre></blockquote>

<p> 网络类加载器子类必须定义方法 <A HREF="../../java/lang/ClassLoader.html#findClass(java.lang.String)"><CODE><tt>findClass</tt></CODE></A> 和 <tt>loadClassData</tt>，以实现从网络加载类。下载组成该类的字节后，它应该使用方法 <A HREF="../../java/lang/ClassLoader.html#defineClass(byte[], int, int)"><CODE><tt>defineClass</tt></CODE></A> 来创建类实例。示例实现如下：

 <blockquote><pre>
     class NetworkClassLoader extends ClassLoader {
         String host;
         int port;

         public Class findClass(String name) {
             byte[] b = loadClassData(name);
             return defineClass(name, b, 0, b.length);
         }

         private byte[] loadClassData(String name) {
             // load the class data from the connection
             &nbsp;.&nbsp;.&nbsp;.
         }
     }
 </pre></blockquote>

<h4> <a name="name">二进制名称</a> </h4>

<p> 按照《<a href="http://java.sun.com/docs/books/jls/">Java Language Specification</a>》的定义，任何作为 <A HREF="../../java/lang/String.html" title="java.lang 中的类"><CODE>String</CODE></A> 类型参数传递给 <tt>ClassLoader</tt> 中方法的类名称都必须是一个二进制名称。

<p> 有效类名称的示例包括：
 <blockquote><pre>
   "java.lang.String"
   "javax.swing.JSpinner$DefaultEditor"
   "java.security.KeyStore$Builder$FileBuilder$1"
   "java.net.URLClassLoader$3$1"
 </pre></blockquote>
<P>

<P>
<DL>
<DT><B>从以下版本开始：</B></DT>
  <DD>1.0</DD>
<DT><B>另请参见：</B><DD><A HREF="../../java/lang/ClassLoader.html#resolveClass(java.lang.Class)"><CODE>resolveClass(Class)</CODE></A></DL>
<HR>

<P>

<!-- ======== CONSTRUCTOR SUMMARY ======== -->

<A NAME="constructor_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>构造方法摘要</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/ClassLoader.html#ClassLoader()">ClassLoader</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;使用方法 <A HREF="../../java/lang/ClassLoader.html#getSystemClassLoader()"><CODE><tt>getSystemClassLoader()</tt></CODE></A> 返回的 <tt>ClassLoader</tt> 创建一个新的类加载器，将该加载器作为父类加载器。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/ClassLoader.html#ClassLoader(java.lang.ClassLoader)">ClassLoader</A></B>(<A HREF="../../java/lang/ClassLoader.html" title="java.lang 中的类">ClassLoader</A>&nbsp;parent)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;使用指定的、用于委托操作的父类加载器创建新的类加载器。</TD>
</TR>
</TABLE>
&nbsp;
<!-- ========== METHOD SUMMARY =========== -->

<A NAME="method_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>方法摘要</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/ClassLoader.html#clearAssertionStatus()">clearAssertionStatus</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;将此类加载器的默认断言状态设置为 <tt>false</tt>，并放弃与此类加载器关联的所有默认包或类断言状态设置。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="../../java/lang/Class.html" title="java.lang 中的类">Class</A>&lt;?&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/ClassLoader.html#defineClass(byte[], int, int)">defineClass</A></B>(byte[]&nbsp;b,
            int&nbsp;off,
            int&nbsp;len)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>已过时。</B>&nbsp;<I>由 <A HREF="../../java/lang/ClassLoader.html#defineClass(java.lang.String, byte[], int, int)"><CODE>defineClass(String, byte[], int, int)</CODE></A> 取代</I></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="../../java/lang/Class.html" title="java.lang 中的类">Class</A>&lt;?&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/ClassLoader.html#defineClass(java.lang.String, byte[], int, int)">defineClass</A></B>(<A HREF="../../java/lang/String.html" title="java.lang 中的类">String</A>&nbsp;name,
            byte[]&nbsp;b,
            int&nbsp;off,
            int&nbsp;len)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;将一个 byte 数组转换为 <tt>Class</tt> 类的实例。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="../../java/lang/Class.html" title="java.lang 中的类">Class</A>&lt;?&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/ClassLoader.html#defineClass(java.lang.String, byte[], int, int, java.security.ProtectionDomain)">defineClass</A></B>(<A HREF="../../java/lang/String.html" title="java.lang 中的类">String</A>&nbsp;name,
            byte[]&nbsp;b,
            int&nbsp;off,
            int&nbsp;len,
            <A HREF="../../java/security/ProtectionDomain.html" title="java.security 中的类">ProtectionDomain</A>&nbsp;protectionDomain)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;使用可选的 <tt>ProtectionDomain</tt> 将一个 byte 数组转换为 <tt>Class</tt> 类的实例。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="../../java/lang/Class.html" title="java.lang 中的类">Class</A>&lt;?&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/ClassLoader.html#defineClass(java.lang.String, java.nio.ByteBuffer, java.security.ProtectionDomain)">defineClass</A></B>(<A HREF="../../java/lang/String.html" title="java.lang 中的类">String</A>&nbsp;name,
            <A HREF="../../java/nio/ByteBuffer.html" title="java.nio 中的类">ByteBuffer</A>&nbsp;b,
            <A HREF="../../java/security/ProtectionDomain.html" title="java.security 中的类">ProtectionDomain</A>&nbsp;protectionDomain)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;使用可选的 <tt>ProtectionDomain</tt> 将 <A HREF="../../java/nio/ByteBuffer.html" title="java.nio 中的类"><CODE><tt>ByteBuffer</tt></CODE></A> 转换为 <tt>Class</tt> 类的实例。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="../../java/lang/Package.html" title="java.lang 中的类">Package</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/ClassLoader.html#definePackage(java.lang.String, java.lang.String, java.lang.String, java.lang.String, java.lang.String, java.lang.String, java.lang.String, java.net.URL)">definePackage</A></B>(<A HREF="../../java/lang/String.html" title="java.lang 中的类">String</A>&nbsp;name,
              <A HREF="../../java/lang/String.html" title="java.lang 中的类">String</A>&nbsp;specTitle,
              <A HREF="../../java/lang/String.html" title="java.lang 中的类">String</A>&nbsp;specVersion,
              <A HREF="../../java/lang/String.html" title="java.lang 中的类">String</A>&nbsp;specVendor,
              <A HREF="../../java/lang/String.html" title="java.lang 中的类">String</A>&nbsp;implTitle,
              <A HREF="../../java/lang/String.html" title="java.lang 中的类">String</A>&nbsp;implVersion,
              <A HREF="../../java/lang/String.html" title="java.lang 中的类">String</A>&nbsp;implVendor,
              <A HREF="../../java/net/URL.html" title="java.net 中的类">URL</A>&nbsp;sealBase)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;根据 name 在此 <tt>ClassLoader</tt> 中定义包。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="../../java/lang/Class.html" title="java.lang 中的类">Class</A>&lt;?&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/ClassLoader.html#findClass(java.lang.String)">findClass</A></B>(<A HREF="../../java/lang/String.html" title="java.lang 中的类">String</A>&nbsp;name)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;使用指定的<a href="#name">二进制名称</a>查找类。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="../../java/lang/String.html" title="java.lang 中的类">String</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/ClassLoader.html#findLibrary(java.lang.String)">findLibrary</A></B>(<A HREF="../../java/lang/String.html" title="java.lang 中的类">String</A>&nbsp;libname)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;返回本机库的绝对路径名。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="../../java/lang/Class.html" title="java.lang 中的类">Class</A>&lt;?&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/ClassLoader.html#findLoadedClass(java.lang.String)">findLoadedClass</A></B>(<A HREF="../../java/lang/String.html" title="java.lang 中的类">String</A>&nbsp;name)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果 Java 虚拟机已将此加载器记录为具有给定<a href="#name">二进制名称</a>的某个类的启动加载器，则返回该<a href="#name">二进制名称</a>的类。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="../../java/net/URL.html" title="java.net 中的类">URL</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/ClassLoader.html#findResource(java.lang.String)">findResource</A></B>(<A HREF="../../java/lang/String.html" title="java.lang 中的类">String</A>&nbsp;name)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;查找具有给定名称的资源。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="../../java/util/Enumeration.html" title="java.util 中的接口">Enumeration</A>&lt;<A HREF="../../java/net/URL.html" title="java.net 中的类">URL</A>&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/ClassLoader.html#findResources(java.lang.String)">findResources</A></B>(<A HREF="../../java/lang/String.html" title="java.lang 中的类">String</A>&nbsp;name)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;返回表示所有具有给定名称的资源的 <A HREF="../../java/net/URL.html" title="java.net 中的类"><CODE><tt>URL</tt></CODE></A> 对象的枚举。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="../../java/lang/Class.html" title="java.lang 中的类">Class</A>&lt;?&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/ClassLoader.html#findSystemClass(java.lang.String)">findSystemClass</A></B>(<A HREF="../../java/lang/String.html" title="java.lang 中的类">String</A>&nbsp;name)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;查找具有指定的<a href="#name">二进制名称</a>的类，必要时加载它。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="../../java/lang/Package.html" title="java.lang 中的类">Package</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/ClassLoader.html#getPackage(java.lang.String)">getPackage</A></B>(<A HREF="../../java/lang/String.html" title="java.lang 中的类">String</A>&nbsp;name)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;返回由此类加载器或其任何祖先所定义的 <tt>Package</tt>。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="../../java/lang/Package.html" title="java.lang 中的类">Package</A>[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/ClassLoader.html#getPackages()">getPackages</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;返回此类加载器及其祖先所定义的所有 <tt>Package</tt>。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/lang/ClassLoader.html" title="java.lang 中的类">ClassLoader</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/ClassLoader.html#getParent()">getParent</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;返回委托的父类加载器。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/net/URL.html" title="java.net 中的类">URL</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/ClassLoader.html#getResource(java.lang.String)">getResource</A></B>(<A HREF="../../java/lang/String.html" title="java.lang 中的类">String</A>&nbsp;name)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;查找具有给定名称的资源。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/io/InputStream.html" title="java.io 中的类">InputStream</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/ClassLoader.html#getResourceAsStream(java.lang.String)">getResourceAsStream</A></B>(<A HREF="../../java/lang/String.html" title="java.lang 中的类">String</A>&nbsp;name)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;返回读取指定资源的输入流。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/util/Enumeration.html" title="java.util 中的接口">Enumeration</A>&lt;<A HREF="../../java/net/URL.html" title="java.net 中的类">URL</A>&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/ClassLoader.html#getResources(java.lang.String)">getResources</A></B>(<A HREF="../../java/lang/String.html" title="java.lang 中的类">String</A>&nbsp;name)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;查找所有给定名称的资源。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../java/lang/ClassLoader.html" title="java.lang 中的类">ClassLoader</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/ClassLoader.html#getSystemClassLoader()">getSystemClassLoader</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;返回委托的系统类加载器。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../java/net/URL.html" title="java.net 中的类">URL</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/ClassLoader.html#getSystemResource(java.lang.String)">getSystemResource</A></B>(<A HREF="../../java/lang/String.html" title="java.lang 中的类">String</A>&nbsp;name)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;从用来加载类的搜索路径中查找具有指定名称的资源。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../java/io/InputStream.html" title="java.io 中的类">InputStream</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/ClassLoader.html#getSystemResourceAsStream(java.lang.String)">getSystemResourceAsStream</A></B>(<A HREF="../../java/lang/String.html" title="java.lang 中的类">String</A>&nbsp;name)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;从用来加载类的搜索路径打开具有指定名称的资源，以读取该资源。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../java/util/Enumeration.html" title="java.util 中的接口">Enumeration</A>&lt;<A HREF="../../java/net/URL.html" title="java.net 中的类">URL</A>&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/ClassLoader.html#getSystemResources(java.lang.String)">getSystemResources</A></B>(<A HREF="../../java/lang/String.html" title="java.lang 中的类">String</A>&nbsp;name)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;从用来加载类的搜索路径中查找所有具有指定名称的资源。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/lang/Class.html" title="java.lang 中的类">Class</A>&lt;?&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/ClassLoader.html#loadClass(java.lang.String)">loadClass</A></B>(<A HREF="../../java/lang/String.html" title="java.lang 中的类">String</A>&nbsp;name)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;使用指定的<a href="#name">二进制名称</a>来加载类。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="../../java/lang/Class.html" title="java.lang 中的类">Class</A>&lt;?&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/ClassLoader.html#loadClass(java.lang.String, boolean)">loadClass</A></B>(<A HREF="../../java/lang/String.html" title="java.lang 中的类">String</A>&nbsp;name,
          boolean&nbsp;resolve)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;使用指定的<a href="#name">二进制名称</a>来加载类。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/ClassLoader.html#resolveClass(java.lang.Class)">resolveClass</A></B>(<A HREF="../../java/lang/Class.html" title="java.lang 中的类">Class</A>&lt;?&gt;&nbsp;c)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;链接指定的类。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/ClassLoader.html#setClassAssertionStatus(java.lang.String, boolean)">setClassAssertionStatus</A></B>(<A HREF="../../java/lang/String.html" title="java.lang 中的类">String</A>&nbsp;className,
                        boolean&nbsp;enabled)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;设置在此类加载器及其包含的嵌套类中指定的最高层类所需的断言状态。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/ClassLoader.html#setDefaultAssertionStatus(boolean)">setDefaultAssertionStatus</A></B>(boolean&nbsp;enabled)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;设置此类加载器的默认断言状态。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/ClassLoader.html#setPackageAssertionStatus(java.lang.String, boolean)">setPackageAssertionStatus</A></B>(<A HREF="../../java/lang/String.html" title="java.lang 中的类">String</A>&nbsp;packageName,
                          boolean&nbsp;enabled)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;为指定包设置默认断言状态。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/ClassLoader.html#setSigners(java.lang.Class, java.lang.Object[])">setSigners</A></B>(<A HREF="../../java/lang/Class.html" title="java.lang 中的类">Class</A>&lt;?&gt;&nbsp;c,
           <A HREF="../../java/lang/Object.html" title="java.lang 中的类">Object</A>[]&nbsp;signers)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;设置类的签署者。</TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_java.lang.Object"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>从类 java.lang.<A HREF="../../java/lang/Object.html" title="java.lang 中的类">Object</A> 继承的方法</B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><A HREF="../../java/lang/Object.html#clone()">clone</A>, <A HREF="../../java/lang/Object.html#equals(java.lang.Object)">equals</A>, <A HREF="../../java/lang/Object.html#finalize()">finalize</A>, <A HREF="../../java/lang/Object.html#getClass()">getClass</A>, <A HREF="../../java/lang/Object.html#hashCode()">hashCode</A>, <A HREF="../../java/lang/Object.html#notify()">notify</A>, <A HREF="../../java/lang/Object.html#notifyAll()">notifyAll</A>, <A HREF="../../java/lang/Object.html#toString()">toString</A>, <A HREF="../../java/lang/Object.html#wait()">wait</A>, <A HREF="../../java/lang/Object.html#wait(long)">wait</A>, <A HREF="../../java/lang/Object.html#wait(long, int)">wait</A></CODE></TD>
</TR>
</TABLE>
&nbsp;
<P>

<!-- ========= CONSTRUCTOR DETAIL ======== -->

<A NAME="constructor_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>构造方法详细信息</B></FONT></TH>
</TR>
</TABLE>

<A NAME="ClassLoader(java.lang.ClassLoader)"><!-- --></A><H3>
ClassLoader</H3>
<PRE>
protected <B>ClassLoader</B>(<A HREF="../../java/lang/ClassLoader.html" title="java.lang 中的类">ClassLoader</A>&nbsp;parent)</PRE>
<DL>
<DD>使用指定的、用于委托操作的父类加载器创建新的类加载器。

<p> 如果存在安全管理器，则调用其 <A HREF="../../java/lang/SecurityManager.html#checkCreateClassLoader()"><CODE><tt>checkCreateClassLoader</tt></CODE></A> 方法。这可能导致安全性异常。  </p>
<P>
<DL>
<DT><B>参数：</B><DD><CODE>parent</CODE> - 父类加载器
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../java/lang/SecurityException.html" title="java.lang 中的类">SecurityException</A></CODE> - 如果存在安全管理器并且其 <tt>checkCreateClassLoader</tt> 方法不允许创建新的类加载器。<DT><B>从以下版本开始：</B></DT>
  <DD>1.2</DD>
</DL>
</DL>
<HR>

<A NAME="ClassLoader()"><!-- --></A><H3>
ClassLoader</H3>
<PRE>
protected <B>ClassLoader</B>()</PRE>
<DL>
<DD>使用方法 <A HREF="../../java/lang/ClassLoader.html#getSystemClassLoader()"><CODE><tt>getSystemClassLoader()</tt></CODE></A> 返回的 <tt>ClassLoader</tt> 创建一个新的类加载器，将该加载器作为父类加载器。

<p> 如果存在安全管理器，则调用其 <A HREF="../../java/lang/SecurityManager.html#checkCreateClassLoader()"><CODE><tt>checkCreateClassLoader</tt></CODE></A> 方法。这可能导致安全性异常。  </p>
<P>
<DL>

<DT><B>抛出：</B>
<DD><CODE><A HREF="../../java/lang/SecurityException.html" title="java.lang 中的类">SecurityException</A></CODE> - 如果存在安全管理器并且其 <tt>checkCreateClassLoader</tt> 方法不允许创建新的类加载器。</DL>
</DL>

<!-- ============ METHOD DETAIL ========== -->

<A NAME="method_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>方法详细信息</B></FONT></TH>
</TR>
</TABLE>

<A NAME="loadClass(java.lang.String)"><!-- --></A><H3>
loadClass</H3>
<PRE>
public <A HREF="../../java/lang/Class.html" title="java.lang 中的类">Class</A>&lt;?&gt; <B>loadClass</B>(<A HREF="../../java/lang/String.html" title="java.lang 中的类">String</A>&nbsp;name)
                   throws <A HREF="../../java/lang/ClassNotFoundException.html" title="java.lang 中的类">ClassNotFoundException</A></PRE>
<DL>
<DD>使用指定的<a href="#name">二进制名称</a>来加载类。此方法使用与 <A HREF="../../java/lang/ClassLoader.html#loadClass(java.lang.String, boolean)"><CODE>loadClass(String, boolean)</CODE></A> 方法相同的方式搜索类。Java 虚拟机调用它来分析类引用。调用此方法等效于调用 <A HREF="../../java/lang/ClassLoader.html#loadClass(java.lang.String, boolean)"><CODE><tt>loadClass(name, false)</tt></CODE></A>。</p>
<P>
<DD><DL>
<DT><B>参数：</B><DD><CODE>name</CODE> - 类的<a href="#name">二进制名称</a>
<DT><B>返回：</B><DD>得到的 <tt>Class</tt> 对象
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../java/lang/ClassNotFoundException.html" title="java.lang 中的类">ClassNotFoundException</A></CODE> - 如果没有找到类</DL>
</DD>
</DL>
<HR>

<A NAME="loadClass(java.lang.String, boolean)"><!-- --></A><H3>
loadClass</H3>
<PRE>
protected <A HREF="../../java/lang/Class.html" title="java.lang 中的类">Class</A>&lt;?&gt; <B>loadClass</B>(<A HREF="../../java/lang/String.html" title="java.lang 中的类">String</A>&nbsp;name,
                             boolean&nbsp;resolve)
                      throws <A HREF="../../java/lang/ClassNotFoundException.html" title="java.lang 中的类">ClassNotFoundException</A></PRE>
<DL>
<DD>使用指定的<a href="#name">二进制名称</a>来加载类。此方法的默认实现将按以下顺序搜索类：

 <p><ol>

<li><p> 调用 <A HREF="../../java/lang/ClassLoader.html#findLoadedClass(java.lang.String)"><CODE>findLoadedClass(String)</CODE></A> 来检查是否已经加载类。</p></li>

<li><p> 在父类加载器上调用 <A HREF="../../java/lang/ClassLoader.html#loadClass(java.lang.String)"><CODE><tt>loadClass</tt></CODE></A> 方法。如果父类加载器为 <tt>null</tt>，则使用虚拟机的内置类加载器。  </p></li>

<li><p> 调用 <A HREF="../../java/lang/ClassLoader.html#findClass(java.lang.String)"><CODE>findClass(String)</CODE></A> 方法查找类。</p></li>

 </ol>

<p> 如果使用上述步骤找到类，并且 <tt>resolve</tt> 标志为真，则此方法将在得到的 <tt>Class</tt> 对象上调用 <A HREF="../../java/lang/ClassLoader.html#resolveClass(java.lang.Class)"><CODE>resolveClass(Class)</CODE></A> 方法。

<p> 鼓励用 <tt>ClassLoader</tt> 的子类重写 <A HREF="../../java/lang/ClassLoader.html#findClass(java.lang.String)"><CODE>findClass(String)</CODE></A>，而不是使用此方法。</p>
<P>
<DD><DL>
<DT><B>参数：</B><DD><CODE>name</CODE> - 类的<a href="#name">二进制名称</a><DD><CODE>resolve</CODE> - 如果该参数为 <tt>true</tt>，则分析这个类
<DT><B>返回：</B><DD>得到的 <tt>Class</tt> 对象
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../java/lang/ClassNotFoundException.html" title="java.lang 中的类">ClassNotFoundException</A></CODE> - 如果无法找到类</DL>
</DD>
</DL>
<HR>

<A NAME="findClass(java.lang.String)"><!-- --></A><H3>
findClass</H3>
<PRE>
protected <A HREF="../../java/lang/Class.html" title="java.lang 中的类">Class</A>&lt;?&gt; <B>findClass</B>(<A HREF="../../java/lang/String.html" title="java.lang 中的类">String</A>&nbsp;name)
                      throws <A HREF="../../java/lang/ClassNotFoundException.html" title="java.lang 中的类">ClassNotFoundException</A></PRE>
<DL>
<DD>使用指定的<a href="#name">二进制名称</a>查找类。此方法应该被类加载器的实现重写，该实现按照委托模型来加载类。在通过父类加载器检查所请求的类后，此方法将被 <A HREF="../../java/lang/ClassLoader.html#loadClass(java.lang.String)"><CODE><tt>loadClass</tt></CODE></A> 方法调用。默认实现抛出一个 <tt>ClassNotFoundException</tt>。  </p>
<P>
<DD><DL>
<DT><B>参数：</B><DD><CODE>name</CODE> - 类的<a href="#name">二进制名称</a>
<DT><B>返回：</B><DD>得到的 <tt>Class</tt> 对象
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../java/lang/ClassNotFoundException.html" title="java.lang 中的类">ClassNotFoundException</A></CODE> - 如果无法找到类<DT><B>从以下版本开始：</B></DT>
  <DD>1.2</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="defineClass(byte[], int, int)"><!-- --></A><H3>
defineClass</H3>
<PRE>
<FONT SIZE="-1"><A HREF="../../java/lang/Deprecated.html" title="java.lang 中的注释">@Deprecated</A>
</FONT>protected final <A HREF="../../java/lang/Class.html" title="java.lang 中的类">Class</A>&lt;?&gt; <B>defineClass</B>(byte[]&nbsp;b,
                                                int&nbsp;off,
                                                int&nbsp;len)
                              throws <A HREF="../../java/lang/ClassFormatError.html" title="java.lang 中的类">ClassFormatError</A></PRE>
<DL>
<DD><B>已过时。</B>&nbsp;<I>由 <A HREF="../../java/lang/ClassLoader.html#defineClass(java.lang.String, byte[], int, int)"><CODE>defineClass(String, byte[], int, int)</CODE></A> 取代</I>
<P>
<DD>将一个 byte 数组转换为 <tt>Class</tt> 类的实例。必须分析 <tt>Class</tt>，然后才能使用它。此方法已废弃，新版本将<a
 href="#name">二进制名称</a>作为该类的第一个参数，后者更加安全。
<P>
<DD><DL>
<DT><B>参数：</B><DD><CODE>b</CODE> - 组成类数据的字节。<tt>off</tt> 与 <tt>off+len-1</tt> 之间的字节应该具有《<a
         href="http://java.sun.com/docs/books/vmspec/">Java Virtual Machine Specification</a>》定义的有效类文件的格式。<DD><CODE>off</CODE> - 类数据的 <tt>b</tt> 中的起始偏移量<DD><CODE>len</CODE> - 类数据的长度
<DT><B>返回：</B><DD>从指定类数据创建的 <tt>Class</tt> 对象
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../java/lang/ClassFormatError.html" title="java.lang 中的类">ClassFormatError</A></CODE> - 如果数据不包含有效类
<DD><CODE><A HREF="../../java/lang/IndexOutOfBoundsException.html" title="java.lang 中的类">IndexOutOfBoundsException</A></CODE> - 如果 <tt>off</tt> 或 <tt>len</tt> 为负，或者 <tt>off+len</tt> 大于 <tt>b.length</tt>。<DT><B>另请参见：</B><DD><A HREF="../../java/lang/ClassLoader.html#loadClass(java.lang.String, boolean)"><CODE>loadClass(String, boolean)</CODE></A>, 
<A HREF="../../java/lang/ClassLoader.html#resolveClass(java.lang.Class)"><CODE>resolveClass(Class)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="defineClass(java.lang.String, byte[], int, int)"><!-- --></A><H3>
defineClass</H3>
<PRE>
protected final <A HREF="../../java/lang/Class.html" title="java.lang 中的类">Class</A>&lt;?&gt; <B>defineClass</B>(<A HREF="../../java/lang/String.html" title="java.lang 中的类">String</A>&nbsp;name,
                                     byte[]&nbsp;b,
                                     int&nbsp;off,
                                     int&nbsp;len)
                              throws <A HREF="../../java/lang/ClassFormatError.html" title="java.lang 中的类">ClassFormatError</A></PRE>
<DL>
<DD>将一个 byte 数组转换为 <tt>Class</tt> 类的实例。必须分析 <tt>Class</tt>，然后才能使用它。

<p> 此方法将默认的 <A HREF="../../java/security/ProtectionDomain.html" title="java.security 中的类"><CODE><tt>ProtectionDomain</tt></CODE></A> 分配给新定义的类。调用 <A HREF="../../java/security/Policy.html#getPermissions(java.security.CodeSource)"><CODE><tt>Policy.getPolicy().getPermissions(new CodeSource(null, null))</tt></CODE></A> 时，<tt>ProtectionDomain</tt> 被有效授予所返回的相同权限集。默认域在第一次调用 <A HREF="../../java/lang/ClassLoader.html#defineClass(java.lang.String, byte[], int, int)"><CODE><tt>defineClass</tt></CODE></A> 时创建，并在后续调用时被重用。

<p> 要将特定的 <tt>ProtectionDomain</tt> 分配给类，需要使用 <A HREF="../../java/lang/ClassLoader.html#defineClass(java.lang.String, byte[], int, int, java.security.ProtectionDomain)"><CODE><tt>defineClass</tt></CODE></A> 方法，该方法将 <tt>ProtectionDomain</tt> 用作其参数之一。  </p>
<P>
<DD><DL>
<DT><B>参数：</B><DD><CODE>name</CODE> - 所需要的类的<a href="#name">二进制名称</a>，如果不知道此名称，则该参数为 <tt>null</tt><DD><CODE>b</CODE> - 组成类数据的字节。<tt>off</tt> 与 <tt>off+len-1</tt> 之间的字节应该具有《<a href="http://java.sun.com/docs/books/vmspec/">Java Virtual Machine Specification</a>》定义的有效类文件的格式。<DD><CODE>off</CODE> - 类数据的 <tt>b</tt> 中的起始偏移量<DD><CODE>len</CODE> - 类数据的长度
<DT><B>返回：</B><DD>从指定类数据中创建的 <tt>Class</tt> 对象。
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../java/lang/ClassFormatError.html" title="java.lang 中的类">ClassFormatError</A></CODE> - 如果数据不包含有效类
<DD><CODE><A HREF="../../java/lang/IndexOutOfBoundsException.html" title="java.lang 中的类">IndexOutOfBoundsException</A></CODE> - 如果 <tt>off</tt> 或 <tt>len</tt> 为负，或者 <tt>off+len</tt> 大于 <tt>b.length</tt>。
<DD><CODE><A HREF="../../java/lang/SecurityException.html" title="java.lang 中的类">SecurityException</A></CODE> - 如果试图将此类添加到包含由不同证书集签名的类（而不是此类，此类未签名）的包中，或者 <tt>name</tt> 以 "<tt>java.</tt>" 开头。<DT><B>从以下版本开始：</B></DT>
  <DD>1.1</DD>
<DT><B>另请参见：</B><DD><A HREF="../../java/lang/ClassLoader.html#loadClass(java.lang.String, boolean)"><CODE>loadClass(String, boolean)</CODE></A>, 
<A HREF="../../java/lang/ClassLoader.html#resolveClass(java.lang.Class)"><CODE>resolveClass(Class)</CODE></A>, 
<A HREF="../../java/security/CodeSource.html" title="java.security 中的类"><CODE>CodeSource</CODE></A>, 
<A HREF="../../java/security/SecureClassLoader.html" title="java.security 中的类"><CODE>SecureClassLoader</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="defineClass(java.lang.String, byte[], int, int, java.security.ProtectionDomain)"><!-- --></A><H3>
defineClass</H3>
<PRE>
protected final <A HREF="../../java/lang/Class.html" title="java.lang 中的类">Class</A>&lt;?&gt; <B>defineClass</B>(<A HREF="../../java/lang/String.html" title="java.lang 中的类">String</A>&nbsp;name,
                                     byte[]&nbsp;b,
                                     int&nbsp;off,
                                     int&nbsp;len,
                                     <A HREF="../../java/security/ProtectionDomain.html" title="java.security 中的类">ProtectionDomain</A>&nbsp;protectionDomain)
                              throws <A HREF="../../java/lang/ClassFormatError.html" title="java.lang 中的类">ClassFormatError</A></PRE>
<DL>
<DD>使用可选的 <tt>ProtectionDomain</tt> 将一个 byte 数组转换为 <tt>Class</tt> 类的实例。如果该域为 <tt>null</tt>，则将默认域分配给 <A HREF="../../java/lang/ClassLoader.html#defineClass(java.lang.String, byte[], int, int)"><CODE>defineClass(String, byte[], int, int)</CODE></A> 的文档中指定的类。这个类必须分析后才能使用。

<p> 包中定义的第一个类确定在该包中定义的所有后续类必须包含的证书的确切集合。从该类的 <tt>ProtectionDomain</tt> 中的 <A HREF="../../java/security/CodeSource.html" title="java.security 中的类"><CODE><tt>CodeSource</tt></CODE></A> 可以获得类的证书集合。添加到该包中的任何类都必须包含相同的证书集合，否则抛出 <tt>SecurityException</tt> 异常。注意，如果 <tt>name</tt> 为 <tt>null</tt>，则不执行该检查。应该始终传入要定义的类的<a href="#name">二进制名称</a>以及字节。这可确保定义该类的正确性。

<p> 指定的 <tt>name</tt> 不能以 "<tt>java.</tt>" 开头，因为 &quot;<tt>java.*</tt>&quot; 包中的所有类都只能由引导类加载器定义。如果 <tt>name</tt> 不是 <tt>null</tt>，则它必定等于由 byte 数组 &quot;<tt>b</tt>&quot; 指定的类的<a href="#name">二进制名称</a>，否则将抛出 <tt>NoClassDefFoundError</tt>。  </p>
<P>
<DD><DL>
<DT><B>参数：</B><DD><CODE>name</CODE> - 所需类的<a href="#name">二进制名称</a>，如果不知道此名称，则该参数为 <tt>null</tt><DD><CODE>b</CODE> - 组成类数据的字节。从 <tt>off</tt> 到 <tt>off+len-1</tt> 的字节应该具有由《<a href="http://java.sun.com/docs/books/vmspec/">Java Virtual Machine Specification</a>》定义的有效类文件的格式。<DD><CODE>off</CODE> - 类数据的 <tt>b</tt> 中的起始偏移量<DD><CODE>len</CODE> - 类数据的长度<DD><CODE>protectionDomain</CODE> - 类的 ProtectionDomain
<DT><B>返回：</B><DD>从数据中创建的 <tt>Class</tt> 对象和可选的 <tt>ProtectionDomain</tt>。
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../java/lang/ClassFormatError.html" title="java.lang 中的类">ClassFormatError</A></CODE> - 如果数据不包含有效的类
<DD><CODE><A HREF="../../java/lang/NoClassDefFoundError.html" title="java.lang 中的类">NoClassDefFoundError</A></CODE> - 如果 <tt>name</tt> 不等于 <tt>b</tt> 指定的类的<a href="#name">二进制名称</a>。
<DD><CODE><A HREF="../../java/lang/IndexOutOfBoundsException.html" title="java.lang 中的类">IndexOutOfBoundsException</A></CODE> - 如果 <tt>off</tt> 或者 <tt>len</tt> 为负，或者 <tt>off+len</tt> 大于 <tt>b.length</tt>。
<DD><CODE><A HREF="../../java/lang/SecurityException.html" title="java.lang 中的类">SecurityException</A></CODE> - 如果试图将此类添加到某个包中，而这个包中包含由不同证书集合（而不是该类）签名的类，或者 <tt>name</tt> 以 "<tt>java.</tt>" 开头。</DL>
</DD>
</DL>
<HR>

<A NAME="defineClass(java.lang.String, java.nio.ByteBuffer, java.security.ProtectionDomain)"><!-- --></A><H3>
defineClass</H3>
<PRE>
protected final <A HREF="../../java/lang/Class.html" title="java.lang 中的类">Class</A>&lt;?&gt; <B>defineClass</B>(<A HREF="../../java/lang/String.html" title="java.lang 中的类">String</A>&nbsp;name,
                                     <A HREF="../../java/nio/ByteBuffer.html" title="java.nio 中的类">ByteBuffer</A>&nbsp;b,
                                     <A HREF="../../java/security/ProtectionDomain.html" title="java.security 中的类">ProtectionDomain</A>&nbsp;protectionDomain)
                              throws <A HREF="../../java/lang/ClassFormatError.html" title="java.lang 中的类">ClassFormatError</A></PRE>
<DL>
<DD>使用可选的 <tt>ProtectionDomain</tt> 将 <A HREF="../../java/nio/ByteBuffer.html" title="java.nio 中的类"><CODE><tt>ByteBuffer</tt></CODE></A> 转换为 <tt>Class</tt> 类的实例。如果该域为 <tt>null</tt>，则将默认域分配给 <A HREF="../../java/lang/ClassLoader.html#defineClass(java.lang.String, byte[], int, int)"><CODE>defineClass(String, byte[], int, int)</CODE></A> 的文档中指定的类。这个类必须分析后才能使用。

<p>有关包中定义的第一个类（它确定了包的证书集合）的规则，以及对类名称的限制，都与 <A HREF="../../java/lang/ClassLoader.html#defineClass(java.lang.String, byte[], int, int, java.security.ProtectionDomain)"><CODE>defineClass(String, byte[], int, int, ProtectionDomain)</CODE></A> 的文档中指定的相同。

<p> 调用形式为 <i>cl</i><tt>.defineClass(</tt><i>name</i><tt>,</tt> <i>bBuffer</i><tt>,</tt> <i>pd</i><tt>)</tt> 的此方法所产生的结果与以下语句产生的结果相同

 <blockquote><tt>
 ...<br>
 byte[] temp = new byte[</tt><i>bBuffer</i><tt>.<A HREF="../../java/nio/Buffer.html#remaining()"><CODE>remaining</CODE></A>()];<br>
           </tt><i>bBuffer</i><tt>.<A HREF="../../java/nio/ByteBuffer.html#get(byte[])"><CODE>get</CODE></A>(temp);<br>
     return <A HREF="../../java/lang/ClassLoader.html#defineClass(java.lang.String, byte[], int, int, java.security.ProtectionDomain)"><CODE></tt><i>cl</i><tt>.defineClass</CODE></A>(</tt><i>name</i><tt>, temp, 0, temp.length, </tt><i>pd</i><tt>);<br>
 </tt></blockquote>
<P>
<DD><DL>
<DT><B>参数：</B><DD><CODE>name</CODE> - 所需要的类的<a href="#name">二进制名称</a>，如果不知道此名称，则该参数为 <tt>null</tt><DD><CODE>b</CODE> - 组成类数据的字节。从 <tt>b.position</tt> 到 <tt>b.position() + b.limit() -1 </tt> 的字节应该具有由《<a          href="http://java.sun.com/docs/books/vmspec/">Java Virtual Machine Specification</a>》定义的有效类文件的格式。<DD><CODE>protectionDomain</CODE> - 类的 ProtectionDomain，或为 <tt>null</tt>。
<DT><B>返回：</B><DD>从数据中创建的 <tt>Class</tt> 对象和可选的 <tt>ProtectionDomain</tt>。
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../java/lang/ClassFormatError.html" title="java.lang 中的类">ClassFormatError</A></CODE> - 如果数据不包含有效的类。
<DD><CODE><A HREF="../../java/lang/NoClassDefFoundError.html" title="java.lang 中的类">NoClassDefFoundError</A></CODE> - 如果 <tt>name</tt> 不等于 <tt>b</tt> 指定的类的<a href="#name">二进制名称</a>。
<DD><CODE><A HREF="../../java/lang/SecurityException.html" title="java.lang 中的类">SecurityException</A></CODE> - 如果试图将此类添加到某个包中，而这个包中包含由不同证书集合（而不是该类）签名的类，或者 <tt>name</tt> 以 "<tt>java.</tt>" 开头。<DT><B>从以下版本开始：</B></DT>
  <DD>1.5</DD>
<DT><B>另请参见：</B><DD><A HREF="../../java/lang/ClassLoader.html#defineClass(java.lang.String, byte[], int, int, java.security.ProtectionDomain)"><CODE>defineClass(String, byte[], int, int, ProtectionDomain)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="resolveClass(java.lang.Class)"><!-- --></A><H3>
resolveClass</H3>
<PRE>
protected final void <B>resolveClass</B>(<A HREF="../../java/lang/Class.html" title="java.lang 中的类">Class</A>&lt;?&gt;&nbsp;c)</PRE>
<DL>
<DD>链接指定的类。类加载器可以使用此方法（其名称容易使人误解）来链接类。如果已经链接类 <tt>c</tt>，则仅返回此方法。否则，该类就按《<a
 href="http://java.sun.com/docs/books/jls/">Java Language Specification</a>》中 "Execution" 一章所描述的进行链接。
 </p>
<P>
<DD><DL>
<DT><B>参数：</B><DD><CODE>c</CODE> - 要链接的类
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../java/lang/NullPointerException.html" title="java.lang 中的类">NullPointerException</A></CODE> - 如果 <tt>c</tt> 为 <tt>null</tt>。<DT><B>另请参见：</B><DD><A HREF="../../java/lang/ClassLoader.html#defineClass(java.lang.String, byte[], int, int)"><CODE>defineClass(String, byte[], int, int)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="findSystemClass(java.lang.String)"><!-- --></A><H3>
findSystemClass</H3>
<PRE>
protected final <A HREF="../../java/lang/Class.html" title="java.lang 中的类">Class</A>&lt;?&gt; <B>findSystemClass</B>(<A HREF="../../java/lang/String.html" title="java.lang 中的类">String</A>&nbsp;name)
                                  throws <A HREF="../../java/lang/ClassNotFoundException.html" title="java.lang 中的类">ClassNotFoundException</A></PRE>
<DL>
<DD>查找具有指定的<a href="#name">二进制名称</a>的类，必要时加载它。

<p> 此方法通过系统类加载器（参见 <A HREF="../../java/lang/ClassLoader.html#getSystemClassLoader()"><CODE>getSystemClassLoader()</CODE></A>）来加载该类。返回的 <tt>Class</tt> 对象具有多个与之相关联的 <tt>ClassLoader</tt>。<tt>ClassLoader</tt> 的子类通常不必调用此方法，因为大多数类加载器只需重写 <A HREF="../../java/lang/ClassLoader.html#findClass(java.lang.String)"><CODE>findClass(String)</CODE></A> 即可。</p>
<P>
<DD><DL>
<DT><B>参数：</B><DD><CODE>name</CODE> - 类的<a href="#name">二进制名称</a>
<DT><B>返回：</B><DD>指定 <tt>name</tt> 的 <tt>Class</tt> 对象
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../java/lang/ClassNotFoundException.html" title="java.lang 中的类">ClassNotFoundException</A></CODE> - 如果找不到类<DT><B>另请参见：</B><DD><A HREF="../../java/lang/ClassLoader.html#ClassLoader(java.lang.ClassLoader)"><CODE>ClassLoader(ClassLoader)</CODE></A>, 
<A HREF="../../java/lang/ClassLoader.html#getParent()"><CODE>getParent()</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="findLoadedClass(java.lang.String)"><!-- --></A><H3>
findLoadedClass</H3>
<PRE>
protected final <A HREF="../../java/lang/Class.html" title="java.lang 中的类">Class</A>&lt;?&gt; <B>findLoadedClass</B>(<A HREF="../../java/lang/String.html" title="java.lang 中的类">String</A>&nbsp;name)</PRE>
<DL>
<DD>如果 Java 虚拟机已将此加载器记录为具有给定<a href="#name">二进制名称</a>的某个类的启动加载器，则返回该<a href="#name">二进制名称</a>的类。否则，返回 <tt>null</tt>。</p>
<P>
<DD><DL>
<DT><B>参数：</B><DD><CODE>name</CODE> - 类的<a href="#name">二进制名称</a>
<DT><B>返回：</B><DD><tt>Class</tt> 对象，如果类没有被加载，则返回 <tt>null</tt><DT><B>从以下版本开始：</B></DT>
  <DD>1.1</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="setSigners(java.lang.Class, java.lang.Object[])"><!-- --></A><H3>
setSigners</H3>
<PRE>
protected final void <B>setSigners</B>(<A HREF="../../java/lang/Class.html" title="java.lang 中的类">Class</A>&lt;?&gt;&nbsp;c,
                                <A HREF="../../java/lang/Object.html" title="java.lang 中的类">Object</A>[]&nbsp;signers)</PRE>
<DL>
<DD>设置类的签署者。应该在定义类后调用此方法。</p>
<P>
<DD><DL>
<DT><B>参数：</B><DD><CODE>c</CODE> - <tt>Class</tt> 对象<DD><CODE>signers</CODE> - 类的签署者<DT><B>从以下版本开始：</B></DT>
  <DD>1.1</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="getResource(java.lang.String)"><!-- --></A><H3>
getResource</H3>
<PRE>
public <A HREF="../../java/net/URL.html" title="java.net 中的类">URL</A> <B>getResource</B>(<A HREF="../../java/lang/String.html" title="java.lang 中的类">String</A>&nbsp;name)</PRE>
<DL>
<DD>查找具有给定名称的资源。资源是可以通过类代码以与代码基无关的方式访问的一些数据（图像、声音、文本等）。

<p> 资源名称是以 '<tt>/</tt>' 分隔的标识资源的路径名称。

<p> 此方法首先搜索资源的父类加载器；如果父类加载器为 <tt>null</tt>，则搜索的路径就是虚拟机的内置类加载器的路径。如果搜索失败，则此方法将调用 <A HREF="../../java/lang/ClassLoader.html#findResource(java.lang.String)"><CODE>findResource(String)</CODE></A> 来查找资源。</p>
<P>
<DD><DL>
<DT><B>参数：</B><DD><CODE>name</CODE> - 资源名称
<DT><B>返回：</B><DD>读取资源的 <tt>URL</tt> 对象；如果找不到该资源，或者调用者没有足够的权限获取该资源，则返回 <tt>null</tt>。<DT><B>从以下版本开始：</B></DT>
  <DD>1.1</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="getResources(java.lang.String)"><!-- --></A><H3>
getResources</H3>
<PRE>
public <A HREF="../../java/util/Enumeration.html" title="java.util 中的接口">Enumeration</A>&lt;<A HREF="../../java/net/URL.html" title="java.net 中的类">URL</A>&gt; <B>getResources</B>(<A HREF="../../java/lang/String.html" title="java.lang 中的类">String</A>&nbsp;name)
                              throws <A HREF="../../java/io/IOException.html" title="java.io 中的类">IOException</A></PRE>
<DL>
<DD>查找所有给定名称的资源。资源是可以通过类代码以与代码基无关的方式访问的某些数据（图像、声音、文本等）。

<p>资源名称是以 '<tt>/</tt>' 分隔的标识资源的路径名称。

<p><A HREF="../../java/lang/ClassLoader.html#getResource(java.lang.String)"><CODE>getResource(String)</CODE></A> 的文档中描述了搜索顺序。</p>
<P>
<DD><DL>
<DT><B>参数：</B><DD><CODE>name</CODE> - 资源名称
<DT><B>返回：</B><DD>资源的 <A HREF="../../java/net/URL.html" title="java.net 中的类"><CODE><tt>URL</tt></CODE></A> 对象的枚举。如果找不到资源，则该枚举将为空。类加载器无权访问的资源不在此枚举中。
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../java/io/IOException.html" title="java.io 中的类">IOException</A></CODE> - 如果发生 I/O 错误<DT><B>从以下版本开始：</B></DT>
  <DD>1.2</DD>
<DT><B>另请参见：</B><DD><A HREF="../../java/lang/ClassLoader.html#findResources(java.lang.String)"><CODE>findResources(String)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="findResource(java.lang.String)"><!-- --></A><H3>
findResource</H3>
<PRE>
protected <A HREF="../../java/net/URL.html" title="java.net 中的类">URL</A> <B>findResource</B>(<A HREF="../../java/lang/String.html" title="java.lang 中的类">String</A>&nbsp;name)</PRE>
<DL>
<DD>查找具有给定名称的资源。类加载器实现应该重写此方法，以指定从何处查找资源。</p>
<P>
<DD><DL>
<DT><B>参数：</B><DD><CODE>name</CODE> - 资源名称
<DT><B>返回：</B><DD>用于读取资源的 <tt>URL</tt> 对象；如果无法找到资源，则返回 <tt>null</tt><DT><B>从以下版本开始：</B></DT>
  <DD>1.2</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="findResources(java.lang.String)"><!-- --></A><H3>
findResources</H3>
<PRE>
protected <A HREF="../../java/util/Enumeration.html" title="java.util 中的接口">Enumeration</A>&lt;<A HREF="../../java/net/URL.html" title="java.net 中的类">URL</A>&gt; <B>findResources</B>(<A HREF="../../java/lang/String.html" title="java.lang 中的类">String</A>&nbsp;name)
                                  throws <A HREF="../../java/io/IOException.html" title="java.io 中的类">IOException</A></PRE>
<DL>
<DD>返回表示所有具有给定名称的资源的 <A HREF="../../java/net/URL.html" title="java.net 中的类"><CODE><tt>URL</tt></CODE></A> 对象的枚举。类加载器实现应该重写此方法，以指定从何处加载资源。</p>
<P>
<DD><DL>
<DT><B>参数：</B><DD><CODE>name</CODE> - 资源名称
<DT><B>返回：</B><DD>资源的 <A HREF="../../java/net/URL.html" title="java.net 中的类"><CODE><tt>URL</tt></CODE></A> 对象的枚举
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../java/io/IOException.html" title="java.io 中的类">IOException</A></CODE> - 如果发生 I/O 错误<DT><B>从以下版本开始：</B></DT>
  <DD>1.2</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="getSystemResource(java.lang.String)"><!-- --></A><H3>
getSystemResource</H3>
<PRE>
public static <A HREF="../../java/net/URL.html" title="java.net 中的类">URL</A> <B>getSystemResource</B>(<A HREF="../../java/lang/String.html" title="java.lang 中的类">String</A>&nbsp;name)</PRE>
<DL>
<DD>从用来加载类的搜索路径中查找具有指定名称的资源。此方法通过系统类加载器（参见 <A HREF="../../java/lang/ClassLoader.html#getSystemClassLoader()"><CODE>getSystemClassLoader()</CODE></A>）来查找资源。</p>
<P>
<DD><DL>
<DT><B>参数：</B><DD><CODE>name</CODE> - 资源名称
<DT><B>返回：</B><DD>用于读取资源的 <A HREF="../../java/net/URL.html" title="java.net 中的类"><CODE><tt>URL</tt></CODE></A> 对象，如果找不到资源，则返回 <tt>null</tt><DT><B>从以下版本开始：</B></DT>
  <DD>1.1</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="getSystemResources(java.lang.String)"><!-- --></A><H3>
getSystemResources</H3>
<PRE>
public static <A HREF="../../java/util/Enumeration.html" title="java.util 中的接口">Enumeration</A>&lt;<A HREF="../../java/net/URL.html" title="java.net 中的类">URL</A>&gt; <B>getSystemResources</B>(<A HREF="../../java/lang/String.html" title="java.lang 中的类">String</A>&nbsp;name)
                                           throws <A HREF="../../java/io/IOException.html" title="java.io 中的类">IOException</A></PRE>
<DL>
<DD>从用来加载类的搜索路径中查找所有具有指定名称的资源。找到的资源作为 <A HREF="../../java/net/URL.html" title="java.net 中的类"><CODE><tt>URL</tt></CODE></A> 对象的 <A HREF="../../java/util/Enumeration.html" title="java.util 中的接口"><CODE><tt>Enumeration</tt></CODE></A> 返回。

<p> <A HREF="../../java/lang/ClassLoader.html#getSystemResource(java.lang.String)"><CODE>getSystemResource(String)</CODE></A> 的文档中描述了搜索顺序。</p>
<P>
<DD><DL>
<DT><B>参数：</B><DD><CODE>name</CODE> - 资源名称
<DT><B>返回：</B><DD>资源 <A HREF="../../java/net/URL.html" title="java.net 中的类"><CODE><tt>URL</tt></CODE></A> 对象的枚举
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../java/io/IOException.html" title="java.io 中的类">IOException</A></CODE> - 如果发生 I/O 错误<DT><B>从以下版本开始：</B></DT>
  <DD>1.2</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="getResourceAsStream(java.lang.String)"><!-- --></A><H3>
getResourceAsStream</H3>
<PRE>
public <A HREF="../../java/io/InputStream.html" title="java.io 中的类">InputStream</A> <B>getResourceAsStream</B>(<A HREF="../../java/lang/String.html" title="java.lang 中的类">String</A>&nbsp;name)</PRE>
<DL>
<DD>返回读取指定资源的输入流。

<p> <A HREF="../../java/lang/ClassLoader.html#getResource(java.lang.String)"><CODE>getResource(String)</CODE></A> 的文档中描述了搜索顺序。</p>
<P>
<DD><DL>
<DT><B>参数：</B><DD><CODE>name</CODE> - 资源名称
<DT><B>返回：</B><DD>用于读取资源的输入流，如果无法找到资源，则返回 <tt>null</tt><DT><B>从以下版本开始：</B></DT>
  <DD>1.1</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="getSystemResourceAsStream(java.lang.String)"><!-- --></A><H3>
getSystemResourceAsStream</H3>
<PRE>
public static <A HREF="../../java/io/InputStream.html" title="java.io 中的类">InputStream</A> <B>getSystemResourceAsStream</B>(<A HREF="../../java/lang/String.html" title="java.lang 中的类">String</A>&nbsp;name)</PRE>
<DL>
<DD>从用来加载类的搜索路径打开具有指定名称的资源，以读取该资源。此方法通过系统类加载器（参见 <A HREF="../../java/lang/ClassLoader.html#getSystemClassLoader()"><CODE>getSystemClassLoader()</CODE></A>）来查找资源。</p>
<P>
<DD><DL>
<DT><B>参数：</B><DD><CODE>name</CODE> - 资源名称
<DT><B>返回：</B><DD>用于读取资源的输入流，如果无法找到资源，则返回 <tt>null</tt><DT><B>从以下版本开始：</B></DT>
  <DD>1.1</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="getParent()"><!-- --></A><H3>
getParent</H3>
<PRE>
public final <A HREF="../../java/lang/ClassLoader.html" title="java.lang 中的类">ClassLoader</A> <B>getParent</B>()</PRE>
<DL>
<DD>返回委托的父类加载器。一些实现可能使用 <tt>null</tt> 来表示引导类加载器。如果类加载器的父类加载器就是引导类加载器，则此方法将在这样的实现中返回 <tt>null</tt>。

<p> 如果存在安全管理器，且调用者的类加载器既不是 <tt>null</tt>，也不是此类加载器的祖先，那么此方法将使用 <A HREF="../../java/lang/RuntimePermission.html#RuntimePermission(java.lang.String)"><CODE><tt>RuntimePermission(&quot;getClassLoader&quot;)</tt></CODE></A> 权限调用安全管理器的 <A HREF="../../java/lang/SecurityManager.html#checkPermission(java.security.Permission)"><CODE><tt>checkPermission</tt></CODE></A> 方法，以检验是否允许访问该类的父类加载器。如果无此权限，则抛出 <tt>SecurityException</tt> 异常。  </p>
<P>
<DD><DL>

<DT><B>返回：</B><DD>父级 <tt>ClassLoader</tt>
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../java/lang/SecurityException.html" title="java.lang 中的类">SecurityException</A></CODE> - 如果存在安全管理器，并且其 <tt>checkPermission</tt> 方法不允许访问此类加载器的父类加载器。<DT><B>从以下版本开始：</B></DT>
  <DD>1.2</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="getSystemClassLoader()"><!-- --></A><H3>
getSystemClassLoader</H3>
<PRE>
public static <A HREF="../../java/lang/ClassLoader.html" title="java.lang 中的类">ClassLoader</A> <B>getSystemClassLoader</B>()</PRE>
<DL>
<DD>返回委托的系统类加载器。该加载器是新的 <tt>ClassLoader</tt> 实例的默认委托父类加载器，通常是用来启动应用程序的类加载器。

<p> 在运行时启动序列的早期首先调用此方法，这时会创建系统类加载器并将其设置为调用 <tt>Thread</tt> 的上下文类加载器。

<p> 默认的系统类加载器是此类的一个与实现有关的实例。

<p> 如果在第一次调用此方法时定义系统属性 "<tt>java.system.class.loader</tt>"，那么该属性的值就是将作为系统类加载器返回的那个类的名称。该类是使用默认系统类加载器进行加载的，它必须定义一个公共的构造方法，此构造方法带有用作委托父类加载器的 <tt>ClassLoader</tt> 类型的单个参数。然后可以使用将默认系统类加载器用作参数的此构造方法创建一个实例。得到的类加载器被定义为系统类加载器。

<p> 如果存在安全管理器，且调用者的类加载器既不是 <tt>null</tt>，也不同于或不是系统类加载器的祖先，那么该方法将使用 <A HREF="../../java/lang/RuntimePermission.html#RuntimePermission(java.lang.String)"><CODE><tt>RuntimePermission(&quot;getClassLoader&quot;)</tt></CODE></A> 权限调用安全管理器的 <A HREF="../../java/lang/SecurityManager.html#checkPermission(java.security.Permission)"><CODE><tt>checkPermission</tt></CODE></A> 方法，以检验系统类加载器的访问权。如果无此权限，则抛出 <tt>SecurityException</tt> 异常。</p>
<P>
<DD><DL>

<DT><B>返回：</B><DD>委托的系统 <tt>ClassLoader</tt>，如果没有这样的类加载器，则返回 <tt>null</tt>
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../java/lang/SecurityException.html" title="java.lang 中的类">SecurityException</A></CODE> - 如果存在安全管理器，且其 <tt>checkPermission</tt> 方法不允许访问系统类加载器。
<DD><CODE><A HREF="../../java/lang/IllegalStateException.html" title="java.lang 中的类">IllegalStateException</A></CODE> - 如果在构造由 "<tt>java.system.class.loader</tt>" 属性指定的类加载器期间进行递归调用。
<DD><CODE><A HREF="../../java/lang/Error.html" title="java.lang 中的类">Error</A></CODE> - 如果定义了系统属性 "<tt>java.system.class.loader</tt>"，但是无法加载指定的类，提供者类没有定义所需的构造方法，或者在调用该构造方法时抛出异常。可以通过 <A HREF="../../java/lang/Throwable.html#getCause()"><CODE>Throwable.getCause()</CODE></A> 方法找出导致该错误的基本原因。</DL>
</DD>
</DL>
<HR>

<A NAME="definePackage(java.lang.String, java.lang.String, java.lang.String, java.lang.String, java.lang.String, java.lang.String, java.lang.String, java.net.URL)"><!-- --></A><H3>
definePackage</H3>
<PRE>
protected <A HREF="../../java/lang/Package.html" title="java.lang 中的类">Package</A> <B>definePackage</B>(<A HREF="../../java/lang/String.html" title="java.lang 中的类">String</A>&nbsp;name,
                                <A HREF="../../java/lang/String.html" title="java.lang 中的类">String</A>&nbsp;specTitle,
                                <A HREF="../../java/lang/String.html" title="java.lang 中的类">String</A>&nbsp;specVersion,
                                <A HREF="../../java/lang/String.html" title="java.lang 中的类">String</A>&nbsp;specVendor,
                                <A HREF="../../java/lang/String.html" title="java.lang 中的类">String</A>&nbsp;implTitle,
                                <A HREF="../../java/lang/String.html" title="java.lang 中的类">String</A>&nbsp;implVersion,
                                <A HREF="../../java/lang/String.html" title="java.lang 中的类">String</A>&nbsp;implVendor,
                                <A HREF="../../java/net/URL.html" title="java.net 中的类">URL</A>&nbsp;sealBase)
                         throws <A HREF="../../java/lang/IllegalArgumentException.html" title="java.lang 中的类">IllegalArgumentException</A></PRE>
<DL>
<DD>根据 name 在此 <tt>ClassLoader</tt> 中定义包。这允许类加载器定义用于它们的类的包。包必须在定义类之前创建，包名在类加载器中必须惟一，并且一旦创建就不能重新定义或更改。</p>
<P>
<DD><DL>
<DT><B>参数：</B><DD><CODE>name</CODE> - 包名<DD><CODE>specTitle</CODE> - 规范标题<DD><CODE>specVersion</CODE> - 规范版本<DD><CODE>specVendor</CODE> - 规范供应商<DD><CODE>implTitle</CODE> - 实现标题<DD><CODE>implVersion</CODE> - 实现版本<DD><CODE>implVendor</CODE> - 实现供应商<DD><CODE>sealBase</CODE> - 如果不为 <tt>null</tt>，那么将此包对于给定代码源 <A HREF="../../java/net/URL.html" title="java.net 中的类"><CODE><tt>URL</tt></CODE></A> 对象是密封的。否则，不密封此包。
<DT><B>返回：</B><DD>新定义的 <tt>Package</tt> 对象
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../java/lang/IllegalArgumentException.html" title="java.lang 中的类">IllegalArgumentException</A></CODE> - 如果包名与此类加载器或其某个祖先中的现有包的名称重复<DT><B>从以下版本开始：</B></DT>
  <DD>1.2</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="getPackage(java.lang.String)"><!-- --></A><H3>
getPackage</H3>
<PRE>
protected <A HREF="../../java/lang/Package.html" title="java.lang 中的类">Package</A> <B>getPackage</B>(<A HREF="../../java/lang/String.html" title="java.lang 中的类">String</A>&nbsp;name)</PRE>
<DL>
<DD>返回由此类加载器或其任何祖先所定义的 <tt>Package</tt>。</p>
<P>
<DD><DL>
<DT><B>参数：</B><DD><CODE>name</CODE> - 包名
<DT><B>返回：</B><DD>与给定名称相对应的 <tt>Package</tt>；如果没有这样的包，则返回 <tt>null</tt><DT><B>从以下版本开始：</B></DT>
  <DD>1.2</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="getPackages()"><!-- --></A><H3>
getPackages</H3>
<PRE>
protected <A HREF="../../java/lang/Package.html" title="java.lang 中的类">Package</A>[] <B>getPackages</B>()</PRE>
<DL>
<DD>返回此类加载器及其祖先所定义的所有 <tt>Package</tt>。</p>
<P>
<DD><DL>

<DT><B>返回：</B><DD>此 <tt>ClassLoader</tt> 定义的 <tt>Package</tt> 对象的数组<DT><B>从以下版本开始：</B></DT>
  <DD>1.2</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="findLibrary(java.lang.String)"><!-- --></A><H3>
findLibrary</H3>
<PRE>
protected <A HREF="../../java/lang/String.html" title="java.lang 中的类">String</A> <B>findLibrary</B>(<A HREF="../../java/lang/String.html" title="java.lang 中的类">String</A>&nbsp;libname)</PRE>
<DL>
<DD>返回本机库的绝对路径名。虚拟机 (VM) 调用此方法来查找那些属于利用此类加载器加载的类的本机库。如果此方法返回 <tt>null</tt>，则虚拟机沿指定为 "<tt>java.library.path</tt>" 属性的路径搜索该库。</p>
<P>
<DD><DL>
<DT><B>参数：</B><DD><CODE>libname</CODE> - 库名称
<DT><B>返回：</B><DD>本机库的绝对路径<DT><B>从以下版本开始：</B></DT>
  <DD>1.2</DD>
<DT><B>另请参见：</B><DD><A HREF="../../java/lang/System.html#loadLibrary(java.lang.String)"><CODE>System.loadLibrary(String)</CODE></A>, 
<A HREF="../../java/lang/System.html#mapLibraryName(java.lang.String)"><CODE>System.mapLibraryName(String)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="setDefaultAssertionStatus(boolean)"><!-- --></A><H3>
setDefaultAssertionStatus</H3>
<PRE>
public void <B>setDefaultAssertionStatus</B>(boolean&nbsp;enabled)</PRE>
<DL>
<DD>设置此类加载器的默认断言状态。此设置确定由此类加载器加载并在将来初始化的类在默认情况下是启用还是禁用断言。通过调用 <A HREF="../../java/lang/ClassLoader.html#setPackageAssertionStatus(java.lang.String, boolean)"><CODE>setPackageAssertionStatus(String, boolean)</CODE></A> 或 <A HREF="../../java/lang/ClassLoader.html#setClassAssertionStatus(java.lang.String, boolean)"><CODE>setClassAssertionStatus(String, boolean)</CODE></A>，在每个包或每个类上重写此设置。</p>
<P>
<DD><DL>
<DT><B>参数：</B><DD><CODE>enabled</CODE> - 如果由此类加载器加载的类将默认为启用断言，则该参数为 <tt>true</tt>；如果默认为禁用断言，则该参数为 <tt>false</tt>。<DT><B>从以下版本开始：</B></DT>
  <DD>1.4</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="setPackageAssertionStatus(java.lang.String, boolean)"><!-- --></A><H3>
setPackageAssertionStatus</H3>
<PRE>
public void <B>setPackageAssertionStatus</B>(<A HREF="../../java/lang/String.html" title="java.lang 中的类">String</A>&nbsp;packageName,
                                      boolean&nbsp;enabled)</PRE>
<DL>
<DD>为指定包设置默认断言状态。包的默认断言状态确定了以后初始化属于指定包或其子包的类的断言状态。

<p> 名为 p 的包的子包是所有名称以 "<tt>p.</tt>" 开头的包。例如，<tt>javax.swing.text</tt> 是 <tt>javax.swing</tt> 的子包，<tt>java.util</tt> 和 <tt>java.lang.reflect</tt> 是 <tt>java</tt> 的子包。

<p> 如果默认情况下多个包可应用于一个给定类，则默认与最特殊的包相关的包拥有高于其他包的优先级。例如，如果 <tt>javax.lang</tt> 和 <tt>javax.lang.reflect</tt> 都具有与之相关的默认包，则将后者应用于 <tt>javax.lang.reflect</tt> 中的类。

<p> 包的优先级默认情况下高于类加载器的默认断言状态，并且可以通过调用 <A HREF="../../java/lang/ClassLoader.html#setClassAssertionStatus(java.lang.String, boolean)"><CODE>setClassAssertionStatus(String, boolean)</CODE></A> 在每个类的基础上进行重写。  </p>
<P>
<DD><DL>
<DT><B>参数：</B><DD><CODE>packageName</CODE> - 要设置其默认包断言状态的包名。<tt>null</tt> 值指示未命名的包为“当前”状态（<a
         href="http://java.sun.com/docs/books/jls/">Java Language Specification</a> 的第 7.4.2 节）。<DD><CODE>enabled</CODE> - 如果由此类加载器加载并属于指定包或其子包的类在默认情况下启用断言，则该参数为 <tt>true</tt>；如果在默认情况下禁用断言，则该参数为 <tt>false</tt>。<DT><B>从以下版本开始：</B></DT>
  <DD>1.4</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="setClassAssertionStatus(java.lang.String, boolean)"><!-- --></A><H3>
setClassAssertionStatus</H3>
<PRE>
public void <B>setClassAssertionStatus</B>(<A HREF="../../java/lang/String.html" title="java.lang 中的类">String</A>&nbsp;className,
                                    boolean&nbsp;enabled)</PRE>
<DL>
<DD>设置在此类加载器及其包含的嵌套类中指定的最高层类所需的断言状态。该设置的优先级高于类加载器的默认断言状态以及可用的任何包的默认值。如果已经初始化指定类，则此方法无效。（初始化类后，其断言状态无法再改变。）

<p> 如果指定类不是最高层的类，则此调用对任何类的实际断言都无效。</p>
<P>
<DD><DL>
<DT><B>参数：</B><DD><CODE>className</CODE> - 将要设置其断言状态的最高层类的完全限定类名。<DD><CODE>enabled</CODE> - 如果指定类在初始化时启用断言，则该参数为<tt>true</tt>；如果该类禁用断言，则该参数为<tt>false</tt>。<DT><B>从以下版本开始：</B></DT>
  <DD>1.4</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="clearAssertionStatus()"><!-- --></A><H3>
clearAssertionStatus</H3>
<PRE>
public void <B>clearAssertionStatus</B>()</PRE>
<DL>
<DD>将此类加载器的默认断言状态设置为 <tt>false</tt>，并放弃与此类加载器关联的所有默认包或类断言状态设置。提供此方法可以让类加载器忽略任何命令行或持久断言状态设置，并且“无不良记录”。
 </p>
<P>
<DD><DL>
<DT><B>从以下版本开始：</B></DT>
  <DD>1.4</DD>
</DL>
</DD>
</DL>
<!-- ========= END OF CLASS DATA ========= -->
<HR>


<!-- ======= START OF BOTTOM NAVBAR ====== -->
<A NAME="navbar_bottom"><!-- --></A>
<A HREF="#skip-navbar_bottom" title="跳过导航链接"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>概述</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>软件包</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>类</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/ClassLoader.html"><FONT CLASS="NavBarFont1"><B>使用</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>树</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>已过时</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>索引</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../help-doc.html"><FONT CLASS="NavBarFont1"><B>帮助</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
<b>Java<sup><font size=-2>TM</font></sup>&nbsp;Platform<br>Standard&nbsp;Ed. 6</b></EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../java/lang/ClassFormatError.html" title="java.lang 中的类"><B>上一个类</B></A>&nbsp;
&nbsp;<A HREF="../../java/lang/ClassNotFoundException.html" title="java.lang 中的类"><B>下一个类</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../index.html?java/lang/ClassLoader.html" target="_top"><B>框架</B></A>  &nbsp;
&nbsp;<A HREF="ClassLoader.html" target="_top"><B>无框架</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../allclasses-noframe.html"><B>所有类</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../allclasses-noframe.html"><B>所有类</B></A>
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  摘要：&nbsp;嵌套&nbsp;|&nbsp;字段&nbsp;|&nbsp;<A HREF="#constructor_summary">构造方法</A>&nbsp;|&nbsp;<A HREF="#method_summary">方法</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
详细信息：&nbsp;字段&nbsp;|&nbsp;<A HREF="#constructor_detail">构造方法</A>&nbsp;|&nbsp;<A HREF="#method_detail">方法</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_bottom"></A>
<!-- ======== END OF BOTTOM NAVBAR ======= -->

<HR>
<font size="-1"><a href="http://bugs.sun.com/services/bugreport/index.jsp">提交错误或意见</a><br>有关更多的 API 参考资料和开发人员文档，请参阅 <a href="http://java.sun.com/javase/6/webnotes/devdocs-vs-specs.html">Java SE 开发人员文档</a>。该文档包含更详细的、面向开发人员的描述，以及总体概述、术语定义、使用技巧和工作代码示例。 <p>版权所有 2007 Sun Microsystems, Inc. 保留所有权利。 请遵守<a href="http://java.sun.com/javase/6/docs/legal/license.html">许可证条款</a>。另请参阅<a href="http://java.sun.com/docs/redist.html">文档重新分发政策</a>。</font>
</BODY>
</HTML>
