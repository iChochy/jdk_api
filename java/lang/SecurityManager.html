<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc (build 1.6.0-beta2) on Mon Mar 19 18:23:01 CST 2007 -->
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
<TITLE>
SecurityManager (Java Platform SE 6)
</TITLE>

<META NAME="date" CONTENT="2007-03-19">

<LINK REL ="stylesheet" TYPE="text/css" HREF="../../stylesheet.css" TITLE="Style">

<SCRIPT type="text/javascript">
function windowTitle()
{
    if (location.href.indexOf('is-external=true') == -1) {
        parent.document.title="SecurityManager (Java Platform SE 6)";
    }
}
</SCRIPT>
<NOSCRIPT>
</NOSCRIPT>

</HEAD>

<BODY BGCOLOR="white" onload="windowTitle();">
<HR>


<!-- ========= START OF TOP NAVBAR ======= -->
<A NAME="navbar_top"><!-- --></A>
<A HREF="#skip-navbar_top" title="跳过导航链接"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>概述</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>软件包</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>类</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/SecurityManager.html"><FONT CLASS="NavBarFont1"><B>使用</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>树</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>已过时</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>索引</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../help-doc.html"><FONT CLASS="NavBarFont1"><B>帮助</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
<b>Java<sup><font size=-2>TM</font></sup>&nbsp;Platform<br>Standard&nbsp;Ed. 6</b></EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../java/lang/SecurityException.html" title="java.lang 中的类"><B>上一个类</B></A>&nbsp;
&nbsp;<A HREF="../../java/lang/Short.html" title="java.lang 中的类"><B>下一个类</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../index.html?java/lang/SecurityManager.html" target="_top"><B>框架</B></A>  &nbsp;
&nbsp;<A HREF="SecurityManager.html" target="_top"><B>无框架</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../allclasses-noframe.html"><B>所有类</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../allclasses-noframe.html"><B>所有类</B></A>
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  摘要：&nbsp;嵌套&nbsp;|&nbsp;<A HREF="#field_summary">字段</A>&nbsp;|&nbsp;<A HREF="#constructor_summary">构造方法</A>&nbsp;|&nbsp;<A HREF="#method_summary">方法</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
详细信息：&nbsp;<A HREF="#field_detail">字段</A>&nbsp;|&nbsp;<A HREF="#constructor_detail">构造方法</A>&nbsp;|&nbsp;<A HREF="#method_detail">方法</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_top"></A>
<!-- ========= END OF TOP NAVBAR ========= -->

<HR>
<!-- ======== START OF CLASS DATA ======== -->
<H2>
<FONT SIZE="-1">
java.lang</FONT>
<BR>
类 SecurityManager</H2>
<PRE>
<A HREF="../../java/lang/Object.html" title="java.lang 中的类">java.lang.Object</A>
  <IMG SRC="../../resources/inherit.gif" ALT="继承者 "><B>java.lang.SecurityManager</B>
</PRE>
<DL>
<DT><B>直接已知子类：</B> <DD><A HREF="../../java/rmi/RMISecurityManager.html" title="java.rmi 中的类">RMISecurityManager</A></DD>
</DL>
<HR>
<DL>
<DT><PRE>public class <B>SecurityManager</B><DT>extends <A HREF="../../java/lang/Object.html" title="java.lang 中的类">Object</A></DL>
</PRE>

<P>
安全管理器是一个允许应用程序实现安全策略的类。它允许应用程序在执行一个可能不安全或敏感的操作前确定该操作是什么，以及是否是在允许执行该操作的安全上下文中执行它。应用程序可以允许或不允许该操作。
 <p>
<code>SecurityManager</code> 类包含了很多名称以单词 <code>check</code> 开头的方法。Java 库中的各种方法在执行某些潜在的敏感操作前可以调用这些方法。对 <code>check</code> 方法的典型调用如下：
 <p><blockquote><pre>
     SecurityManager security = System.getSecurityManager();
     if (security != null) {
         security.check<i>XXX</i>(argument, &nbsp;.&nbsp;.&nbsp;.&nbsp;);
     }
 </pre></blockquote>
 <p>
因此，安全管理器通过抛出异常来提供阻止操作完成的机会。如果允许执行该操作，则安全管理器例程只是简单地返回，但如果不允许执行该操作，则抛出一个 <code>SecurityException</code>。该约定的唯一例外是 <code>checkTopLevelWindow</code>，它返回 <code>boolean</code> 值。
 <p>
当前的安全管理器由 <code>System</code> 类中的 <code>setSecurityManager</code> 方法设置。当前的安全管理器由 <code>getSecurityManager</code> 方法获得。
 <p> 
特殊方法 <A HREF="../../java/lang/SecurityManager.html#checkPermission(java.security.Permission)"><CODE>checkPermission(java.security.Permission)</CODE></A> 确定是应该允许还是拒绝由指定权限所指示的访问请求。默认的实现调用
 
 <pre>
   AccessController.checkPermission(perm);
 </pre>

 <p> 
如果允许访问请求，则安静地返回 <code>checkPermission</code>。如果拒绝访问请求，则抛出 <code>SecurityException</code>。 
 <p>
从 Java 2 SDK v1.2 开始，<code>SecurityManager</code> 中其他所有 <code>check</code> 方法的默认实现都是调用 <code>SecurityManager checkPermission</code> 方法来确定调用线程是否具有执行所请求操作的权限。
 <p> 
注意，只带有单个权限参数的 <code>checkPermission</code> 方法总是在当前执行的线程上下文中执行安全检查。有时，应该在给定上下文中进行的安全检查实际上需要在<i>不同</i> 的上下文（例如，在一个辅助线程中）中进行。Java 为这种情况提供了包含有上下文参数的 <A HREF="../../java/lang/SecurityManager.html#getSecurityContext()"><CODE>getSecurityContext</CODE></A> 方法和 <A HREF="../../java/lang/SecurityManager.html#checkPermission(java.security.Permission, java.lang.Object)"><CODE>checkPermission</CODE></A> 方法。<code>getSecurityContext</code> 方法返回当前调用上下文的一个&ldquo;快照&rdquo;（默认的实现返回一个 AccessControlContext 对象）。下面是一个示例调用：
 
 <pre>
   Object context = null;
   SecurityManager sm = System.getSecurityManager();
   if (sm != null) context = sm.getSecurityContext(); 
 </pre>
 
 <p>
<code>checkPermission</code> 方法使用一个上下文对象，以及根据该上下文而不是当前执行线程的上下文作出访问决策的权限。因此另一个上下文中的代码可以调用此方法，传递权限和以前保存的上下文对象。下面是一个示例调用，它使用了以前示例中获得的 SecurityManager <code>sm</code>：
 
 <pre>
   if (sm != null) sm.checkPermission(permission, context);
 </pre> 

<p>权限分为以下类别：文件、套接字、网络、安全性、运行时、属性、AWT、反射和可序列化。管理各种权限类别的类是 <code>java.io.FilePermission</code>、<code>java.net.SocketPermission</code>、<code>java.net.NetPermission</code>、<code>java.security.SecurityPermission</code>、<code>java.lang.RuntimePermission</code>、<code>java.util.PropertyPermission</code>、<code>java.awt.AWTPermission</code>、<code>java.lang.reflect.ReflectPermission</code> 和 <code>java.io.SerializablePermission</code>。 
 
<p>除前两个（FilePermission 和 SocketPermission）类以外的所有类都是 <code>java.security.BasicPermission</code> 的子类，而 <code>java.security.BasicPermission</code> 类又是顶级权限类 <code>java.security.Permission</code> 的抽象子类。BasicPermission 定义了所有权限所需的功能，这些功能的名称遵从分层属性命名惯例（例如&ldquo;exitVM&rdquo;、&ldquo;setFactory&rdquo;、&ldquo;queuePrintJob&rdquo;等等）。在名称的末尾可能出现一个星号，前面是&ldquo;.&rdquo;或星号，这表示通配符匹配。例如：&ldquo;a.*&rdquo;、&ldquo;*&rdquo;是有效的，而&ldquo;*a&rdquo;或&ldquo;a*b&rdquo;是无效的。

<p>FilePermission 和 SocketPermission 是顶级权限类 (<code>java.security.Permission</code>) 的子类。像这些命名语法比 BasicPermission 所用的语法更为复杂的类都直接是 Permission 的子类，而不是 BasicPermission 的子类。例如，对于 <code>java.io.FilePermission</code> 对象而言，权限名就是文件（或目录）的路径名。

<p>某些权限类具有一个&ldquo;动作&rdquo;列表，告知允许对象所执行的动作。例如，对于 <code>java.io.FilePermission</code> 对象，动作列表（如&ldquo;读、写&rdquo;）指定了允许对指定文件（或指定目录中的文件）执行哪些动作。
 
<p>其他权限类是&ldquo;指定的&rdquo;权限 - 有名称但没有动作列表的类；您也许有指定的权限，也许没有。
 
<p>注：还有一个暗指所有权限的 <code>java.security.AllPermission</code> 权限。该权限是为了简化系统管理员的工作而存在的，因为管理员可能需要执行很多需要所有（或许多）权限的任务。
 <p>
有关权限相关的信息，请参阅 <a href ="../../../technotes/guides/security/permissions.html">。例如，本文档包括一个列出各种 SecurityManager 的 <code>check</code> 方法和每个方法的默认实现所需的权限表。它还包含了版本 1.2 方法所需权限和每个方法需要哪些权限的表。
 <p>
有关 JDK 中对 <code>SecurityManager</code> 所作更改的更多信息和关于 1.1 风格安全管理器移植的建议，请参阅 <a href="../../../technotes/guides/security/index.html">security documentation</a>。
<P>

<P>
<DL>
<DT><B>从以下版本开始：</B></DT>
  <DD>JDK1.0</DD>
<DT><B>另请参见：</B><DD><A HREF="../../java/lang/ClassLoader.html" title="java.lang 中的类"><CODE>ClassLoader</CODE></A>, 
<A HREF="../../java/lang/SecurityException.html" title="java.lang 中的类"><CODE>SecurityException</CODE></A>, 
<A HREF="../../java/lang/SecurityManager.html#checkTopLevelWindow(java.lang.Object)"><CODE>checkTopLevelWindow</CODE></A>, 
<A HREF="../../java/lang/System.html#getSecurityManager()"><CODE>getSecurityManager</CODE></A>, 
<A HREF="../../java/lang/System.html#setSecurityManager(java.lang.SecurityManager)"><CODE>setSecurityManager</CODE></A>, 
<A HREF="../../java/security/AccessController.html" title="java.security 中的类"><CODE>AccessController</CODE></A>, 
<A HREF="../../java/security/AccessControlContext.html" title="java.security 中的类"><CODE>AccessControlContext</CODE></A>, 
<A HREF="../../java/security/AccessControlException.html" title="java.security 中的类"><CODE>AccessControlException</CODE></A>, 
<A HREF="../../java/security/Permission.html" title="java.security 中的类"><CODE>Permission</CODE></A>, 
<A HREF="../../java/security/BasicPermission.html" title="java.security 中的类"><CODE>BasicPermission</CODE></A>, 
<A HREF="../../java/io/FilePermission.html" title="java.io 中的类"><CODE>FilePermission</CODE></A>, 
<A HREF="../../java/net/SocketPermission.html" title="java.net 中的类"><CODE>SocketPermission</CODE></A>, 
<A HREF="../../java/util/PropertyPermission.html" title="java.util 中的类"><CODE>PropertyPermission</CODE></A>, 
<A HREF="../../java/lang/RuntimePermission.html" title="java.lang 中的类"><CODE>RuntimePermission</CODE></A>, 
<A HREF="../../java/awt/AWTPermission.html" title="java.awt 中的类"><CODE>AWTPermission</CODE></A>, 
<A HREF="../../java/security/Policy.html" title="java.security 中的类"><CODE>Policy</CODE></A>, 
<A HREF="../../java/security/SecurityPermission.html" title="java.security 中的类"><CODE>SecurityPermission</CODE></A>, 
<A HREF="../../java/security/ProtectionDomain.html" title="java.security 中的类"><CODE>ProtectionDomain</CODE></A></DL>
<HR>

<P>
<!-- =========== FIELD SUMMARY =========== -->

<A NAME="field_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>字段摘要</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/SecurityManager.html#inCheck">inCheck</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>已过时。</B>&nbsp;<I>建议不使用该类型的安全检查。建议使用 <code>checkPermission</code> 调用。</I></TD>
</TR>
</TABLE>
&nbsp;
<!-- ======== CONSTRUCTOR SUMMARY ======== -->

<A NAME="constructor_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>构造方法摘要</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../java/lang/SecurityManager.html#SecurityManager()">SecurityManager</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;构造一个新的 <code>SecurityManager</code>。</TD>
</TR>
</TABLE>
&nbsp;
<!-- ========== METHOD SUMMARY =========== -->

<A NAME="method_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>方法摘要</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/SecurityManager.html#checkAccept(java.lang.String, int)">checkAccept</A></B>(<A HREF="../../java/lang/String.html" title="java.lang 中的类">String</A>&nbsp;host,
            int&nbsp;port)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果不允许调用线程从指定的主机和端口号接受套接字连接，则抛出 <code>SecurityException</code>。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/SecurityManager.html#checkAccess(java.lang.Thread)">checkAccess</A></B>(<A HREF="../../java/lang/Thread.html" title="java.lang 中的类">Thread</A>&nbsp;t)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果不允许调用线程修改 thread 参数，则抛出 <code>SecurityException</code>。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/SecurityManager.html#checkAccess(java.lang.ThreadGroup)">checkAccess</A></B>(<A HREF="../../java/lang/ThreadGroup.html" title="java.lang 中的类">ThreadGroup</A>&nbsp;g)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果不允许调用线程修改线程组参数，则抛出 <code>SecurityException</code>。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/SecurityManager.html#checkAwtEventQueueAccess()">checkAwtEventQueueAccess</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果不允许调用线程访问 AWT 事件队列，则抛出 <code>SecurityException</code>。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/SecurityManager.html#checkConnect(java.lang.String, int)">checkConnect</A></B>(<A HREF="../../java/lang/String.html" title="java.lang 中的类">String</A>&nbsp;host,
             int&nbsp;port)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果不允许调用线程打开到指定主机和端口号的套接字连接，则抛出 <code>SecurityException</code>。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/SecurityManager.html#checkConnect(java.lang.String, int, java.lang.Object)">checkConnect</A></B>(<A HREF="../../java/lang/String.html" title="java.lang 中的类">String</A>&nbsp;host,
             int&nbsp;port,
             <A HREF="../../java/lang/Object.html" title="java.lang 中的类">Object</A>&nbsp;context)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果不允许指定的安全上下文打开与指定主机和端口号的套接字连接，则抛出 <code>SecurityException</code>。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/SecurityManager.html#checkCreateClassLoader()">checkCreateClassLoader</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果不允许调用线程创建新的类加载器，则抛出 <code>SecurityException</code>。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/SecurityManager.html#checkDelete(java.lang.String)">checkDelete</A></B>(<A HREF="../../java/lang/String.html" title="java.lang 中的类">String</A>&nbsp;file)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果不允许调用线程删除指定的文件，则抛出 <code>SecurityException</code>。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/SecurityManager.html#checkExec(java.lang.String)">checkExec</A></B>(<A HREF="../../java/lang/String.html" title="java.lang 中的类">String</A>&nbsp;cmd)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果不允许调用线程创建一个子进程，则抛出 <code>SecurityException</code>。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/SecurityManager.html#checkExit(int)">checkExit</A></B>(int&nbsp;status)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果不允许调用线程使用特定的状态码暂停 Java 虚拟机，则抛出 <code>SecurityException</code>。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/SecurityManager.html#checkLink(java.lang.String)">checkLink</A></B>(<A HREF="../../java/lang/String.html" title="java.lang 中的类">String</A>&nbsp;lib)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果不允许调用线程动态链接由字符串参数文件指定的库代码，则抛出 <code>SecurityException</code>。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/SecurityManager.html#checkListen(int)">checkListen</A></B>(int&nbsp;port)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果不允许调用线程等待与指定本地端口号进行连接的请求，则抛出 <code>SecurityException</code>。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/SecurityManager.html#checkMemberAccess(java.lang.Class, int)">checkMemberAccess</A></B>(<A HREF="../../java/lang/Class.html" title="java.lang 中的类">Class</A>&lt;?&gt;&nbsp;clazz,
                  int&nbsp;which)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果不允许调用线程访问程序，则抛出 <code>SecurityException</code>。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/SecurityManager.html#checkMulticast(java.net.InetAddress)">checkMulticast</A></B>(<A HREF="../../java/net/InetAddress.html" title="java.net 中的类">InetAddress</A>&nbsp;maddr)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果不允许调用线程使用（加入/离开/发送/接收）IP 多址广播，则抛出 <code>SecurityException</code>。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/SecurityManager.html#checkMulticast(java.net.InetAddress, byte)">checkMulticast</A></B>(<A HREF="../../java/net/InetAddress.html" title="java.net 中的类">InetAddress</A>&nbsp;maddr,
               byte&nbsp;ttl)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>已过时。</B>&nbsp;<I>由 #checkPermission(java.security.Permission) 取代</I></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/SecurityManager.html#checkPackageAccess(java.lang.String)">checkPackageAccess</A></B>(<A HREF="../../java/lang/String.html" title="java.lang 中的类">String</A>&nbsp;pkg)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果不允许调用线程访问由参数指定的包，则抛出 <code>SecurityException</code>。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/SecurityManager.html#checkPackageDefinition(java.lang.String)">checkPackageDefinition</A></B>(<A HREF="../../java/lang/String.html" title="java.lang 中的类">String</A>&nbsp;pkg)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果不允许调用线程在参数指定的包中定义类，则抛出 <code>SecurityException</code>。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/SecurityManager.html#checkPermission(java.security.Permission)">checkPermission</A></B>(<A HREF="../../java/security/Permission.html" title="java.security 中的类">Permission</A>&nbsp;perm)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果基于当前有效的安全策略，不允许执行根据给定权限所指定的请求访问，则抛出 <code>SecurityException</code>。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/SecurityManager.html#checkPermission(java.security.Permission, java.lang.Object)">checkPermission</A></B>(<A HREF="../../java/security/Permission.html" title="java.security 中的类">Permission</A>&nbsp;perm,
                <A HREF="../../java/lang/Object.html" title="java.lang 中的类">Object</A>&nbsp;context)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果拒绝指定的安全上下文访问由给定权限所指定的资源，则抛出 <code>SecurityException</code>。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/SecurityManager.html#checkPrintJobAccess()">checkPrintJobAccess</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果不允许调用线程发起一个打印作业请求，则抛出 <code>SecurityException</code>。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/SecurityManager.html#checkPropertiesAccess()">checkPropertiesAccess</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果不允许调用线程访问或修改系统属性，则抛出 <code>SecurityException</code>。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/SecurityManager.html#checkPropertyAccess(java.lang.String)">checkPropertyAccess</A></B>(<A HREF="../../java/lang/String.html" title="java.lang 中的类">String</A>&nbsp;key)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果不允许调用线程访问具有指定的 <code>key</code> 名的系统属性，则抛出 <code>SecurityException</code>。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/SecurityManager.html#checkRead(java.io.FileDescriptor)">checkRead</A></B>(<A HREF="../../java/io/FileDescriptor.html" title="java.io 中的类">FileDescriptor</A>&nbsp;fd)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果不允许调用线程从指定的文件描述符进行读取，则抛出 <code>SecurityException</code>。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/SecurityManager.html#checkRead(java.lang.String)">checkRead</A></B>(<A HREF="../../java/lang/String.html" title="java.lang 中的类">String</A>&nbsp;file)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果不允许调用线程读取由字符串参数指定的文件，则抛出 <code>SecurityException</code>。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/SecurityManager.html#checkRead(java.lang.String, java.lang.Object)">checkRead</A></B>(<A HREF="../../java/lang/String.html" title="java.lang 中的类">String</A>&nbsp;file,
          <A HREF="../../java/lang/Object.html" title="java.lang 中的类">Object</A>&nbsp;context)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果不允许指定的安全上下文读取由字符串参数所指定的文件，则抛出 <code>SecurityException</code>。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/SecurityManager.html#checkSecurityAccess(java.lang.String)">checkSecurityAccess</A></B>(<A HREF="../../java/lang/String.html" title="java.lang 中的类">String</A>&nbsp;target)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;确定是应该允许还是拒绝具有指定权限目标名的权限。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/SecurityManager.html#checkSetFactory()">checkSetFactory</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果不允许调用线程设置由 <code>ServerSocket</code> 或 <code>Socket</code> 使用的套接字工厂，或者由 <code>URL</code> 使用的流处理程序工厂，则抛出 <code>SecurityException</code>。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/SecurityManager.html#checkSystemClipboardAccess()">checkSystemClipboardAccess</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果不允许调用线程访问系统剪贴板，则抛出 <code>SecurityException</code>。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/SecurityManager.html#checkTopLevelWindow(java.lang.Object)">checkTopLevelWindow</A></B>(<A HREF="../../java/lang/Object.html" title="java.lang 中的类">Object</A>&nbsp;window)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果不受信任的调用线程调出由 <code>window</code> 参数指出的顶层窗口，则返回 <code>false</code>。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/SecurityManager.html#checkWrite(java.io.FileDescriptor)">checkWrite</A></B>(<A HREF="../../java/io/FileDescriptor.html" title="java.io 中的类">FileDescriptor</A>&nbsp;fd)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果不允许调用线程写入指定的文件描述符，则抛出 <code>SecurityException</code>。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/SecurityManager.html#checkWrite(java.lang.String)">checkWrite</A></B>(<A HREF="../../java/lang/String.html" title="java.lang 中的类">String</A>&nbsp;file)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果不允许调用线程写由字符串参数指定的文件，则抛出 <code>SecurityException</code>。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/SecurityManager.html#classDepth(java.lang.String)">classDepth</A></B>(<A HREF="../../java/lang/String.html" title="java.lang 中的类">String</A>&nbsp;name)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>已过时。</B>&nbsp;<I>建议不使用该类安全检查。建议使用 <code>checkPermission</code> 调用。</I></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/SecurityManager.html#classLoaderDepth()">classLoaderDepth</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>已过时。</B>&nbsp;<I>建议不使用该类安全检查。建议使用 <code>checkPermission</code> 调用。</I></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="../../java/lang/ClassLoader.html" title="java.lang 中的类">ClassLoader</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/SecurityManager.html#currentClassLoader()">currentClassLoader</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>已过时。</B>&nbsp;<I>建议不使用该类安全检查。建议使用 <code>checkPermission</code> 调用。</I></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="../../java/lang/Class.html" title="java.lang 中的类">Class</A>&lt;?&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/SecurityManager.html#currentLoadedClass()">currentLoadedClass</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>已过时。</B>&nbsp;<I>建议不使用该类安全检查。建议使用 <code>checkPermission</code> 调用。</I></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="../../java/lang/Class.html" title="java.lang 中的类">Class</A>[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/SecurityManager.html#getClassContext()">getClassContext</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;以类数组的形式返回当前执行堆栈。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/SecurityManager.html#getInCheck()">getInCheck</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>已过时。</B>&nbsp;<I>建议不使用该类安全检查。建议使用 <code>checkPermission</code> 调用。</I></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/lang/Object.html" title="java.lang 中的类">Object</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/SecurityManager.html#getSecurityContext()">getSecurityContext</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;创建一个封装当前执行环境的对象。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/lang/ThreadGroup.html" title="java.lang 中的类">ThreadGroup</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/SecurityManager.html#getThreadGroup()">getThreadGroup</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;调用此方法时，返回所有新创建的线程实例化后所在的线程组。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/SecurityManager.html#inClass(java.lang.String)">inClass</A></B>(<A HREF="../../java/lang/String.html" title="java.lang 中的类">String</A>&nbsp;name)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>已过时。</B>&nbsp;<I>建议不使用该类安全检查。建议使用 <code>checkPermission</code> 调用。</I></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/SecurityManager.html#inClassLoader()">inClassLoader</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>已过时。</B>&nbsp;<I>建议不使用该类安全检查。建议使用 <code>checkPermission</code> 调用。</I></TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_java.lang.Object"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>从类 java.lang.<A HREF="../../java/lang/Object.html" title="java.lang 中的类">Object</A> 继承的方法</B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><A HREF="../../java/lang/Object.html#clone()">clone</A>, <A HREF="../../java/lang/Object.html#equals(java.lang.Object)">equals</A>, <A HREF="../../java/lang/Object.html#finalize()">finalize</A>, <A HREF="../../java/lang/Object.html#getClass()">getClass</A>, <A HREF="../../java/lang/Object.html#hashCode()">hashCode</A>, <A HREF="../../java/lang/Object.html#notify()">notify</A>, <A HREF="../../java/lang/Object.html#notifyAll()">notifyAll</A>, <A HREF="../../java/lang/Object.html#toString()">toString</A>, <A HREF="../../java/lang/Object.html#wait()">wait</A>, <A HREF="../../java/lang/Object.html#wait(long)">wait</A>, <A HREF="../../java/lang/Object.html#wait(long, int)">wait</A></CODE></TD>
</TR>
</TABLE>
&nbsp;
<P>

<!-- ============ FIELD DETAIL =========== -->

<A NAME="field_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>字段详细信息</B></FONT></TH>
</TR>
</TABLE>

<A NAME="inCheck"><!-- --></A><H3>
inCheck</H3>
<PRE>
<FONT SIZE="-1"><A HREF="../../java/lang/Deprecated.html" title="java.lang 中的注释">@Deprecated</A>
</FONT>protected boolean <B>inCheck</B></PRE>
<DL>
<DD><B>已过时。</B>&nbsp;<I>建议不使用该类型的安全检查。建议使用 <code>checkPermission</code> 调用。</I><DD>如果安全检查正在进行，则该字段为 <code>true</code>；否则为 <code>false</code>。
<P>
<DL>
</DL>
</DL>

<!-- ========= CONSTRUCTOR DETAIL ======== -->

<A NAME="constructor_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>构造方法详细信息</B></FONT></TH>
</TR>
</TABLE>

<A NAME="SecurityManager()"><!-- --></A><H3>
SecurityManager</H3>
<PRE>
public <B>SecurityManager</B>()</PRE>
<DL>
<DD>构造一个新的 <code>SecurityManager</code>。

<p> 如果已经安装了一个安全管理器，则此方法首先用 <code>RuntimePermission("createSecurityManager")</code> 权限调用此安全管理器的 <code>checkPermission</code> 方法，确保调用线程具有创建新安全管理器的权限。这可能导致抛出 <code>SecurityException</code>。
<P>
<DL>

<DT><B>抛出：</B>
<DD><CODE><A HREF="../../java/lang/SecurityException.html" title="java.lang 中的类">SecurityException</A></CODE> - 如果安全管理器已存在，并且其 <code>checkPermission</code> 方法不允许创建新安全管理器。<DT><B>另请参见：</B><DD><A HREF="../../java/lang/System.html#getSecurityManager()"><CODE>System.getSecurityManager()</CODE></A>, 
<A HREF="../../java/lang/SecurityManager.html#checkPermission(java.security.Permission)"><CODE>checkPermission</CODE></A>, 
<A HREF="../../java/lang/RuntimePermission.html" title="java.lang 中的类"><CODE>RuntimePermission</CODE></A></DL>
</DL>

<!-- ============ METHOD DETAIL ========== -->

<A NAME="method_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>方法详细信息</B></FONT></TH>
</TR>
</TABLE>

<A NAME="getInCheck()"><!-- --></A><H3>
getInCheck</H3>
<PRE>
<FONT SIZE="-1"><A HREF="../../java/lang/Deprecated.html" title="java.lang 中的注释">@Deprecated</A>
</FONT>public boolean <B>getInCheck</B>()</PRE>
<DL>
<DD><B>已过时。</B>&nbsp;<I>建议不使用该类安全检查。建议使用 <code>checkPermission</code> 调用。</I>
<P>
<DD>测试安全检查是否正在进行。
<P>
<DD><DL>

<DT><B>返回：</B><DD><code>inCheck</code> 字段的值。如果安全检查正在进行，则该字段应该为 <code>true</code>，否则应该为 <code>false</code>。<DT><B>另请参见：</B><DD><A HREF="../../java/lang/SecurityManager.html#inCheck"><CODE>inCheck</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="getClassContext()"><!-- --></A><H3>
getClassContext</H3>
<PRE>
protected <A HREF="../../java/lang/Class.html" title="java.lang 中的类">Class</A>[] <B>getClassContext</B>()</PRE>
<DL>
<DD>以类数组的形式返回当前执行堆栈。 
 <p>
数组的长度是执行堆栈中的方法数。索引 <code>0</code> 指定的元素是当前执行方法的类，索引 <code>1</code> 指定的元素是该方法调用方的类，依此类推。
<P>
<DD><DL>

<DT><B>返回：</B><DD>执行堆栈。</DL>
</DD>
</DL>
<HR>

<A NAME="currentClassLoader()"><!-- --></A><H3>
currentClassLoader</H3>
<PRE>
<FONT SIZE="-1"><A HREF="../../java/lang/Deprecated.html" title="java.lang 中的注释">@Deprecated</A>
</FONT>protected <A HREF="../../java/lang/ClassLoader.html" title="java.lang 中的类">ClassLoader</A> <B>currentClassLoader</B>()</PRE>
<DL>
<DD><B>已过时。</B>&nbsp;<I>建议不使用该类安全检查。建议使用 <code>checkPermission</code> 调用。</I>
<P>
<DD>返回最近执行的、使用非系统类加载器定义的类方法的类加载器。非系统类加载器被定义为一种不同于系统类加载器（由 <A HREF="../../java/lang/ClassLoader.html#getSystemClassLoader()"><CODE>ClassLoader.getSystemClassLoader()</CODE></A> 返回）或其祖先之一的类加载器。
 <p>
在以下三种情况中，此方法将返回 <code>null</code>：<p>
 <ol>
<li>执行堆栈中的所有方法都来自于使用系统类加载器或其祖先之一所定义的类。

<li>在执行堆栈中，直到第一个&ldquo;特权&rdquo;调用方（参见 <A HREF="../../java/security/AccessController.html#doPrivileged(java.security.PrivilegedAction)"><CODE>AccessController.doPrivileged(java.security.PrivilegedAction<T>)</CODE></A>）为止的所有方法都来自于使用系统类加载器或其祖先之一所定义的类。

<li> 使用 <code>java.security.AllPermission</code> 调用 <code>checkPermission</code> 不会导致 SecurityException。 

 </ol>
<P>
<DD><DL>

<DT><B>返回：</B><DD>最近执行的、使用非系统类加载器定义的类方法堆栈中的类加载器。<DT><B>另请参见：</B><DD><A HREF="../../java/lang/ClassLoader.html#getSystemClassLoader()"><CODE>getSystemClassLoader</CODE></A>, 
<A HREF="../../java/lang/SecurityManager.html#checkPermission(java.security.Permission)"><CODE>checkPermission</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="currentLoadedClass()"><!-- --></A><H3>
currentLoadedClass</H3>
<PRE>
<FONT SIZE="-1"><A HREF="../../java/lang/Deprecated.html" title="java.lang 中的注释">@Deprecated</A>
</FONT>protected <A HREF="../../java/lang/Class.html" title="java.lang 中的类">Class</A>&lt;?&gt; <B>currentLoadedClass</B>()</PRE>
<DL>
<DD><B>已过时。</B>&nbsp;<I>建议不使用该类安全检查。建议使用 <code>checkPermission</code> 调用。</I>
<P>
<DD>返回最近执行的、使用非系统类加载器定义的类方法的类。非系统类加载器被定义为一种不同于系统类加载器（由 <A HREF="../../java/lang/ClassLoader.html#getSystemClassLoader()"><CODE>ClassLoader.getSystemClassLoader()</CODE></A> 返回）或其祖先之一的类加载器。
 <p>
在以下三种情况中，此方法将返回 <code>null</code>：<p>
 <ol>
<li>执行堆栈中的所有方法都来自于使用系统类加载器或其祖先之一所定义的类。

<li>在执行堆栈中，直到第一个&ldquo;特权&rdquo;调用方（参见 <A HREF="../../java/security/AccessController.html#doPrivileged(java.security.PrivilegedAction)"><CODE>AccessController.doPrivileged(java.security.PrivilegedAction<T>)</CODE></A>）为止的所有方法都来自于使用系统类加载器或其祖先之一所定义的类。

<li> 使用 <code>java.security.AllPermission</code> 调用 <code>checkPermission</code> 不会导致 SecurityException。 

 </ol>
<P>
<DD><DL>

<DT><B>返回：</B><DD>最近出现的、使用非系统类加载器定义的类方法堆栈中的类。<DT><B>另请参见：</B><DD><A HREF="../../java/lang/ClassLoader.html#getSystemClassLoader()"><CODE>getSystemClassLoader</CODE></A>, 
<A HREF="../../java/lang/SecurityManager.html#checkPermission(java.security.Permission)"><CODE>checkPermission</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="classDepth(java.lang.String)"><!-- --></A><H3>
classDepth</H3>
<PRE>
<FONT SIZE="-1"><A HREF="../../java/lang/Deprecated.html" title="java.lang 中的注释">@Deprecated</A>
</FONT>protected int <B>classDepth</B>(<A HREF="../../java/lang/String.html" title="java.lang 中的类">String</A>&nbsp;name)</PRE>
<DL>
<DD><B>已过时。</B>&nbsp;<I>建议不使用该类安全检查。建议使用 <code>checkPermission</code> 调用。</I>
<P>
<DD>返回指定类的堆栈深度。
<P>
<DD><DL>
<DT><B>参数：</B><DD><CODE>name</CODE> - 要查找的类的完全限定名。
<DT><B>返回：</B><DD>在指定名称的类中第一个方法出现的堆栈帧深度；如未找到这样的帧，则返回 <code>-1</code>。</DL>
</DD>
</DL>
<HR>

<A NAME="classLoaderDepth()"><!-- --></A><H3>
classLoaderDepth</H3>
<PRE>
<FONT SIZE="-1"><A HREF="../../java/lang/Deprecated.html" title="java.lang 中的注释">@Deprecated</A>
</FONT>protected int <B>classLoaderDepth</B>()</PRE>
<DL>
<DD><B>已过时。</B>&nbsp;<I>建议不使用该类安全检查。建议使用 <code>checkPermission</code> 调用。</I>
<P>
<DD>返回最近执行的、使用非系统类加载器定义的类方法的堆栈深度。非系统类加载器被定义为一种不同于系统类加载器（由 <A HREF="../../java/lang/ClassLoader.html#getSystemClassLoader()"><CODE>ClassLoader.getSystemClassLoader()</CODE></A> 返回）或其祖先之一的类加载器。
 <p>
在以下三种情况中，此方法将返回 -1：<p>
 <ol>
<li>执行堆栈中的所有方法都来自于使用系统类加载器或其祖先之一所定义的类。

<li>在执行堆栈中，直到第一个&ldquo;特权&rdquo;调用方（参见 <A HREF="../../java/security/AccessController.html#doPrivileged(java.security.PrivilegedAction)"><CODE>AccessController.doPrivileged(java.security.PrivilegedAction<T>)</CODE></A>）为止的所有方法都来自于使用系统类加载器或其祖先之一所定义的类。

<li> 使用 <code>java.security.AllPermission</code> 调用 <code>checkPermission</code> 不会导致 SecurityException。

 </ol>
<P>
<DD><DL>

<DT><B>返回：</B><DD>最近出现的、使用非系统类加载器定义的类方法的堆栈帧深度。<DT><B>另请参见：</B><DD><A HREF="../../java/lang/ClassLoader.html#getSystemClassLoader()"><CODE>getSystemClassLoader</CODE></A>, 
<A HREF="../../java/lang/SecurityManager.html#checkPermission(java.security.Permission)"><CODE>checkPermission</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="inClass(java.lang.String)"><!-- --></A><H3>
inClass</H3>
<PRE>
<FONT SIZE="-1"><A HREF="../../java/lang/Deprecated.html" title="java.lang 中的注释">@Deprecated</A>
</FONT>protected boolean <B>inClass</B>(<A HREF="../../java/lang/String.html" title="java.lang 中的类">String</A>&nbsp;name)</PRE>
<DL>
<DD><B>已过时。</B>&nbsp;<I>建议不使用该类安全检查。建议使用 <code>checkPermission</code> 调用。</I>
<P>
<DD>测试具有指定名称的类方法是否处于执行堆栈中。
<P>
<DD><DL>
<DT><B>参数：</B><DD><CODE>name</CODE> - 该类的完全限定名。
<DT><B>返回：</B><DD>如果具有指定名称的类方法处于执行堆栈中，则返回 <code>true</code>；否则返回 <code>false</code>。</DL>
</DD>
</DL>
<HR>

<A NAME="inClassLoader()"><!-- --></A><H3>
inClassLoader</H3>
<PRE>
<FONT SIZE="-1"><A HREF="../../java/lang/Deprecated.html" title="java.lang 中的注释">@Deprecated</A>
</FONT>protected boolean <B>inClassLoader</B>()</PRE>
<DL>
<DD><B>已过时。</B>&nbsp;<I>建议不使用该类安全检查。建议使用 <code>checkPermission</code> 调用。</I>
<P>
<DD>主要是测试某个使用类加载器定义的类方法是否处于执行堆栈中。
<P>
<DD><DL>

<DT><B>返回：</B><DD>如果调用 <code>currentClassLoader</code> 具有非 null 的返回值，则返回 <code>true</code>。<DT><B>另请参见：</B><DD><A HREF="../../java/lang/SecurityManager.html#currentClassLoader()"><CODE>currentClassLoader</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="getSecurityContext()"><!-- --></A><H3>
getSecurityContext</H3>
<PRE>
public <A HREF="../../java/lang/Object.html" title="java.lang 中的类">Object</A> <B>getSecurityContext</B>()</PRE>
<DL>
<DD>创建一个封装当前执行环境的对象。例如，此方法的结果由带有三参数的 <code>checkConnect</code> 方法和带有两参数的 <code>checkRead</code> 方法使用。这些方法是必需的，因为一个受信任的方法可能代表另一方法被调用，以读取一个文件或打开一个套接字。受信任的方法需要确定是否允许另一个方法（可能不受信任）独自执行该操作。   
<p> 此方法的默认实现是返回 <code>AccessControlContext</code> 对象。
<P>
<DD><DL>

<DT><B>返回：</B><DD>一个取决于实现的对象，该对象封装了有关当前执行环境的足够信息，这些信息用于稍后执行某些安全检查。<DT><B>另请参见：</B><DD><A HREF="../../java/lang/SecurityManager.html#checkConnect(java.lang.String, int, java.lang.Object)"><CODE>checkConnect</CODE></A>, 
<A HREF="../../java/lang/SecurityManager.html#checkRead(java.lang.String, java.lang.Object)"><CODE>checkRead</CODE></A>, 
<A HREF="../../java/security/AccessControlContext.html" title="java.security 中的类"><CODE>AccessControlContext</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="checkPermission(java.security.Permission)"><!-- --></A><H3>
checkPermission</H3>
<PRE>
public void <B>checkPermission</B>(<A HREF="../../java/security/Permission.html" title="java.security 中的类">Permission</A>&nbsp;perm)</PRE>
<DL>
<DD>如果基于当前有效的安全策略，不允许执行根据给定权限所指定的请求访问，则抛出 <code>SecurityException</code>。
 <p>
此方法使用给定的权限调用 <code>AccessController.checkPermission</code>。
<P>
<DD><DL>
<DT><B>参数：</B><DD><CODE>perm</CODE> - 请求的权限。
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../java/lang/SecurityException.html" title="java.lang 中的类">SecurityException</A></CODE> - 如果根据当前的安全策略不允许进行访问。
<DD><CODE><A HREF="../../java/lang/NullPointerException.html" title="java.lang 中的类">NullPointerException</A></CODE> - 如果 permission 参数为 <code>null</code>。<DT><B>从以下版本开始：</B></DT>
  <DD>1.2</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="checkPermission(java.security.Permission, java.lang.Object)"><!-- --></A><H3>
checkPermission</H3>
<PRE>
public void <B>checkPermission</B>(<A HREF="../../java/security/Permission.html" title="java.security 中的类">Permission</A>&nbsp;perm,
                            <A HREF="../../java/lang/Object.html" title="java.lang 中的类">Object</A>&nbsp;context)</PRE>
<DL>
<DD>如果拒绝指定的安全上下文访问由给定权限所指定的资源，则抛出 <code>SecurityException</code>。该上下文必须是一个通过以前调用 <code>getSecurityContext</code> 所返回的安全上下文，并且应该根据为该安全上下文所配置的安全策略来作出访问控制决策。
 <p>
如果 <code>context</code> 是 <code>AccessControlContext</code> 的一个实例，则用指定的权限调用 <code>AccessControlContext.checkPermission</code> 方法。
 <p>
如果 <code>context</code> 不是 <code>AccessControlContext</code> 的一个实例，则抛出 <code>SecurityException</code>。
<P>
<DD><DL>
<DT><B>参数：</B><DD><CODE>perm</CODE> - 指定的权限。<DD><CODE>context</CODE> - 一个取决于系统的安全上下文。
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../java/lang/SecurityException.html" title="java.lang 中的类">SecurityException</A></CODE> - 如果指定的安全上下文不是 <code>AccessControlContext</code> 的一个实例（如为 <code>null</code>），或者访问由给定权限所指定的资源时被拒绝。
<DD><CODE><A HREF="../../java/lang/NullPointerException.html" title="java.lang 中的类">NullPointerException</A></CODE> - 如果权限参数为 <code>null</code>。<DT><B>从以下版本开始：</B></DT>
  <DD>1.2</DD>
<DT><B>另请参见：</B><DD><A HREF="../../java/lang/SecurityManager.html#getSecurityContext()"><CODE>getSecurityContext()</CODE></A>, 
<A HREF="../../java/security/AccessControlContext.html#checkPermission(java.security.Permission)"><CODE>AccessControlContext.checkPermission(java.security.Permission)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="checkCreateClassLoader()"><!-- --></A><H3>
checkCreateClassLoader</H3>
<PRE>
public void <B>checkCreateClassLoader</B>()</PRE>
<DL>
<DD>如果不允许调用线程创建新的类加载器，则抛出 <code>SecurityException</code>。 
 <p>
此方法用 <code>RuntimePermission(&quot;createClassLoader&quot;)</code> 权限调用 <code>checkPermission</code>。
 <p>
如果重写此方法，那么应该在已重写方法通常将要抛出异常时调用 <code>super.checkCreateClassLoader</code>。
<P>
<DD><DL>

<DT><B>抛出：</B>
<DD><CODE><A HREF="../../java/lang/SecurityException.html" title="java.lang 中的类">SecurityException</A></CODE> - 如果调用线程没有创建新类加载器的权限。<DT><B>另请参见：</B><DD><A HREF="../../java/lang/ClassLoader.html#ClassLoader()"><CODE>ClassLoader.ClassLoader()</CODE></A>, 
<A HREF="../../java/lang/SecurityManager.html#checkPermission(java.security.Permission)"><CODE>checkPermission</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="checkAccess(java.lang.Thread)"><!-- --></A><H3>
checkAccess</H3>
<PRE>
public void <B>checkAccess</B>(<A HREF="../../java/lang/Thread.html" title="java.lang 中的类">Thread</A>&nbsp;t)</PRE>
<DL>
<DD>如果不允许调用线程修改 thread 参数，则抛出 <code>SecurityException</code>。
 <p>
由 <code>Thread</code> 类的 <code>stop</code>、<code>suspend</code>、<code>resume</code>、<code>setPriority</code>、<code>setName</code> 和 <code>setDaemon</code> 方法为当前的安全管理器调用此方法。
 <p>
如果 thread 参数是一个系统线程（属于具有一个 <code>null</code> 父线程的线程组），那么此方法使用 <code>RuntimePermission(&quot;modifyThread&quot;)</code> 权限调用 <code>checkPermission</code>。如果 thread 参数<i>不</i> 是一个系统线程，则此方法不执行任何操作。
 <p>
希望具有更为严格策略的应用程序应该重写此方法。如果重写此方法，那么重写它的方法应该进行额外的检查，查看调用线程是否具有 <code>RuntimePermission(&quot;modifyThread&quot;)</code> 权限，如果是，则此方法不执行任何操作。这样做是为了确保允许那些被授予该权限的代码（如 JDK 本身）能够操作所有线程。
 <p>
如果重写此方法，那么应该由已重写方法中的第一条语句调用 <code>super.checkAccess</code>，或者应该在已重写方法中放入等效的安全检查代码。
<P>
<DD><DL>
<DT><B>参数：</B><DD><CODE>t</CODE> - 要检查的线程。
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../java/lang/SecurityException.html" title="java.lang 中的类">SecurityException</A></CODE> - 如果调用线程没有修改线程的权限。
<DD><CODE><A HREF="../../java/lang/NullPointerException.html" title="java.lang 中的类">NullPointerException</A></CODE> - 如果线程参数为 <code>null</code>。<DT><B>另请参见：</B><DD><A HREF="../../java/lang/Thread.html#resume()"><CODE>resume</CODE></A>, 
<A HREF="../../java/lang/Thread.html#setDaemon(boolean)"><CODE>setDaemon</CODE></A>, 
<A HREF="../../java/lang/Thread.html#setName(java.lang.String)"><CODE>setName</CODE></A>, 
<A HREF="../../java/lang/Thread.html#setPriority(int)"><CODE>setPriority</CODE></A>, 
<A HREF="../../java/lang/Thread.html#stop()"><CODE>stop</CODE></A>, 
<A HREF="../../java/lang/Thread.html#suspend()"><CODE>suspend</CODE></A>, 
<A HREF="../../java/lang/SecurityManager.html#checkPermission(java.security.Permission)"><CODE>checkPermission</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="checkAccess(java.lang.ThreadGroup)"><!-- --></A><H3>
checkAccess</H3>
<PRE>
public void <B>checkAccess</B>(<A HREF="../../java/lang/ThreadGroup.html" title="java.lang 中的类">ThreadGroup</A>&nbsp;g)</PRE>
<DL>
<DD>如果不允许调用线程修改线程组参数，则抛出 <code>SecurityException</code>。
 <p>
当创建新的子线程或子线程组时，由 <code>ThreadGroup</code> 类的 <code>setDaemon</code>、<code>setMaxPriority</code>、<code>stop</code>、<code>suspend</code>、<code>resume</code> 和 <code>destroy</code> 方法为当前的安全管理器调用此方法。
 <p>
如果该线程组是一个系统线程组（具有 <code>null</code> 父线程），那么此方法使用 <code>RuntimePermission(&quot;modifyThreadGroup&quot;)</code> 权限调用 <code>checkPermission</code>。如果该线程组<i>不</i> 是一个系统线程组，则此方法不执行任何操作。
 <p>
希望具有更为严格策略的应用程序应该重写此方法。如果重写此方法，那么重写它的方法应该进行额外的检查，查看调用线程是否具有 <code>RuntimePermission(&quot;modifyThreadGroup&quot;)</code> 权限，如果是，则此方法不执行任何操作。这样做是为了确保允许那些被授予该权限的代码（如 JDK 本身）能够操作所有线程。
 <p>
如果重写此方法，那么应该由已重写方法中的第一条语句调用 <code>super.checkAccess</code>，或者应该在已重写方法中放入等效的安全检查。
<P>
<DD><DL>
<DT><B>参数：</B><DD><CODE>g</CODE> - 要检查的线程组。
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../java/lang/SecurityException.html" title="java.lang 中的类">SecurityException</A></CODE> - 如果调用线程没有修改线程组的权限。
<DD><CODE><A HREF="../../java/lang/NullPointerException.html" title="java.lang 中的类">NullPointerException</A></CODE> - 如果线程组参数为 <code>null</code>。<DT><B>另请参见：</B><DD><A HREF="../../java/lang/ThreadGroup.html#destroy()"><CODE>destroy</CODE></A>, 
<A HREF="../../java/lang/ThreadGroup.html#resume()"><CODE>resume</CODE></A>, 
<A HREF="../../java/lang/ThreadGroup.html#setDaemon(boolean)"><CODE>setDaemon</CODE></A>, 
<A HREF="../../java/lang/ThreadGroup.html#setMaxPriority(int)"><CODE>setMaxPriority</CODE></A>, 
<A HREF="../../java/lang/ThreadGroup.html#stop()"><CODE>stop</CODE></A>, 
<A HREF="../../java/lang/ThreadGroup.html#suspend()"><CODE>suspend</CODE></A>, 
<A HREF="../../java/lang/SecurityManager.html#checkPermission(java.security.Permission)"><CODE>checkPermission</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="checkExit(int)"><!-- --></A><H3>
checkExit</H3>
<PRE>
public void <B>checkExit</B>(int&nbsp;status)</PRE>
<DL>
<DD>如果不允许调用线程使用特定的状态码暂停 Java 虚拟机，则抛出 <code>SecurityException</code>。
 <p>
由 <code>Runtime</code> 类的 <code>exit</code> 方法为当前的安全管理器调用此方法。状态 <code>0</code> 表示成功，其他值则表示各种错误。
 <p>
此方法用 <code>RuntimePermission("exitVM."+status)</code> 权限调用 <code>checkPermission</code>。
 <p>
如果重写此方法，那么通常应该在已重写方法将要抛出异常时调用 <code>super.checkExit</code>。
<P>
<DD><DL>
<DT><B>参数：</B><DD><CODE>status</CODE> - 退出状态。
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../java/lang/SecurityException.html" title="java.lang 中的类">SecurityException</A></CODE> - 如果调用线程没有用指定的状态暂停 Java 虚拟机的权限。<DT><B>另请参见：</B><DD><A HREF="../../java/lang/Runtime.html#exit(int)"><CODE>exit</CODE></A>, 
<A HREF="../../java/lang/SecurityManager.html#checkPermission(java.security.Permission)"><CODE>checkPermission</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="checkExec(java.lang.String)"><!-- --></A><H3>
checkExec</H3>
<PRE>
public void <B>checkExec</B>(<A HREF="../../java/lang/String.html" title="java.lang 中的类">String</A>&nbsp;cmd)</PRE>
<DL>
<DD>如果不允许调用线程创建一个子进程，则抛出 <code>SecurityException</code>。
 <p>
由 <code>Runtime</code> 类的 <code>exec</code> 方法为当前的安全管理器调用此方法。
 <p>
如果 cmd 是绝对路径，那么此方法使用 <code>FilePermission(cmd,&quot;execute&quot;)</code> 权限调用 <code>checkPermission</code>，否则用 <code>FilePermission(&quot;&lt;&lt;ALL FILES&gt;&gt;&quot;,&quot;execute&quot;)</code> 权限调用 <code>checkPermission</code>。
 <p>
如果重写此方法，那么通常应该在已重写方法将要抛出异常时调用 <code>super.checkExec</code>。
<P>
<DD><DL>
<DT><B>参数：</B><DD><CODE>cmd</CODE> - 指定的系统命令。
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../java/lang/SecurityException.html" title="java.lang 中的类">SecurityException</A></CODE> - 如果调用线程没有创建子进程的权限。
<DD><CODE><A HREF="../../java/lang/NullPointerException.html" title="java.lang 中的类">NullPointerException</A></CODE> - 如果 <code>cmd</code> 参数为 <code>null</code>。<DT><B>另请参见：</B><DD><A HREF="../../java/lang/Runtime.html#exec(java.lang.String)"><CODE>Runtime.exec(java.lang.String)</CODE></A>, 
<A HREF="../../java/lang/Runtime.html#exec(java.lang.String, java.lang.String[])"><CODE>Runtime.exec(java.lang.String, java.lang.String[])</CODE></A>, 
<A HREF="../../java/lang/Runtime.html#exec(java.lang.String[])"><CODE>Runtime.exec(java.lang.String[])</CODE></A>, 
<A HREF="../../java/lang/Runtime.html#exec(java.lang.String[], java.lang.String[])"><CODE>Runtime.exec(java.lang.String[], java.lang.String[])</CODE></A>, 
<A HREF="../../java/lang/SecurityManager.html#checkPermission(java.security.Permission)"><CODE>checkPermission</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="checkLink(java.lang.String)"><!-- --></A><H3>
checkLink</H3>
<PRE>
public void <B>checkLink</B>(<A HREF="../../java/lang/String.html" title="java.lang 中的类">String</A>&nbsp;lib)</PRE>
<DL>
<DD>如果不允许调用线程动态链接由字符串参数文件指定的库代码，则抛出 <code>SecurityException</code>。此方法中的参数可以是一个简单的库名，或者是一个完整的文件名。
 <p>
由 <code>Runtime</code> 类的 <code>load</code> 和 <code>loadLibrary</code> 方法为当前的安全管理器调用此方法。
 <p>
此方法用 <code>RuntimePermission(&quot;loadLibrary.&quot;+lib)</code> 权限调用 <code>checkPermission</code>。
 <p>
如果重写此方法，那么通常应该在已重写方法将要抛出异常时调用 <code>super.checkLink</code>。
<P>
<DD><DL>
<DT><B>参数：</B><DD><CODE>lib</CODE> - 库名。
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../java/lang/SecurityException.html" title="java.lang 中的类">SecurityException</A></CODE> - 如果调用线程没有动态地链接该库的权限。
<DD><CODE><A HREF="../../java/lang/NullPointerException.html" title="java.lang 中的类">NullPointerException</A></CODE> - 如果 <code>lib</code> 参数为 <code>null</code>。<DT><B>另请参见：</B><DD><A HREF="../../java/lang/Runtime.html#load(java.lang.String)"><CODE>Runtime.load(java.lang.String)</CODE></A>, 
<A HREF="../../java/lang/Runtime.html#loadLibrary(java.lang.String)"><CODE>Runtime.loadLibrary(java.lang.String)</CODE></A>, 
<A HREF="../../java/lang/SecurityManager.html#checkPermission(java.security.Permission)"><CODE>checkPermission</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="checkRead(java.io.FileDescriptor)"><!-- --></A><H3>
checkRead</H3>
<PRE>
public void <B>checkRead</B>(<A HREF="../../java/io/FileDescriptor.html" title="java.io 中的类">FileDescriptor</A>&nbsp;fd)</PRE>
<DL>
<DD>如果不允许调用线程从指定的文件描述符进行读取，则抛出 <code>SecurityException</code>。
 <p>
此方法用 <code>RuntimePermission(&quot;readFileDescriptor&quot;)</code> 权限调用 <code>checkPermission</code>。
 <p>
如果重写此方法，那么通常应该在已重写方法将要抛出异常时调用 <code>super.checkRead</code>。
<P>
<DD><DL>
<DT><B>参数：</B><DD><CODE>fd</CODE> - 取决于系统的文件描述符。
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../java/lang/SecurityException.html" title="java.lang 中的类">SecurityException</A></CODE> - 如果调用线程没有访问指定文件描述符的权限。
<DD><CODE><A HREF="../../java/lang/NullPointerException.html" title="java.lang 中的类">NullPointerException</A></CODE> - 如果文件描述符参数为 <code>null</code>。<DT><B>另请参见：</B><DD><A HREF="../../java/io/FileDescriptor.html" title="java.io 中的类"><CODE>FileDescriptor</CODE></A>, 
<A HREF="../../java/lang/SecurityManager.html#checkPermission(java.security.Permission)"><CODE>checkPermission</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="checkRead(java.lang.String)"><!-- --></A><H3>
checkRead</H3>
<PRE>
public void <B>checkRead</B>(<A HREF="../../java/lang/String.html" title="java.lang 中的类">String</A>&nbsp;file)</PRE>
<DL>
<DD>如果不允许调用线程读取由字符串参数指定的文件，则抛出 <code>SecurityException</code>。
 <p>
此方法用 <code>FilePermission(file,&quot;read&quot;)</code> 权限调用 <code>checkPermission</code>。
 <p>
如果重写此方法，那么通常应该在已重写方法将要抛出异常时调用 <code>super.checkRead</code>。
<P>
<DD><DL>
<DT><B>参数：</B><DD><CODE>file</CODE> - 取决于系统的文件名。
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../java/lang/SecurityException.html" title="java.lang 中的类">SecurityException</A></CODE> - 如果调用线程没有访问指定文件的权限。
<DD><CODE><A HREF="../../java/lang/NullPointerException.html" title="java.lang 中的类">NullPointerException</A></CODE> - 如果 <code>file</code> 参数为 <code>null</code>。<DT><B>另请参见：</B><DD><A HREF="../../java/lang/SecurityManager.html#checkPermission(java.security.Permission)"><CODE>checkPermission</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="checkRead(java.lang.String, java.lang.Object)"><!-- --></A><H3>
checkRead</H3>
<PRE>
public void <B>checkRead</B>(<A HREF="../../java/lang/String.html" title="java.lang 中的类">String</A>&nbsp;file,
                      <A HREF="../../java/lang/Object.html" title="java.lang 中的类">Object</A>&nbsp;context)</PRE>
<DL>
<DD>如果不允许指定的安全上下文读取由字符串参数所指定的文件，则抛出 <code>SecurityException</code>。该上下文必须是以前调用 <code>getSecurityContext</code> 所返回的安全上下文。 
<p> 如果 <code>context</code> 是 <code>AccessControlContext</code> 的一个实例，则用 <code>FilePermission(file,&quot;read&quot;)</code> 权限调用 <code>AccessControlContext.checkPermission</code> 方法。
<p> 如果 <code>context</code> 不是 <code>AccessControlContext</code> 的一个实例，则抛出 <code>SecurityException</code>。
 <p>
如果重写此方法，那么通常应该在已重写方法将要抛出异常时调用 <code>super.checkRead</code>。
<P>
<DD><DL>
<DT><B>参数：</B><DD><CODE>file</CODE> - 取决于系统的文件名。<DD><CODE>context</CODE> - 取决于系统的安全上下文。
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../java/lang/SecurityException.html" title="java.lang 中的类">SecurityException</A></CODE> - 如果指定的安全上下文不是 <code>AccessControlContext</code> 的一个实例（如为 <code>null</code>），或者没有读取指定文件的权限。
<DD><CODE><A HREF="../../java/lang/NullPointerException.html" title="java.lang 中的类">NullPointerException</A></CODE> - 如果 <code>file</code> 参数为 <code>null</code>。<DT><B>另请参见：</B><DD><A HREF="../../java/lang/SecurityManager.html#getSecurityContext()"><CODE>getSecurityContext()</CODE></A>, 
<A HREF="../../java/security/AccessControlContext.html#checkPermission(java.security.Permission)"><CODE>AccessControlContext.checkPermission(java.security.Permission)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="checkWrite(java.io.FileDescriptor)"><!-- --></A><H3>
checkWrite</H3>
<PRE>
public void <B>checkWrite</B>(<A HREF="../../java/io/FileDescriptor.html" title="java.io 中的类">FileDescriptor</A>&nbsp;fd)</PRE>
<DL>
<DD>如果不允许调用线程写入指定的文件描述符，则抛出 <code>SecurityException</code>。
 <p>
此方法用 <code>RuntimePermission(&quot;writeFileDescriptor&quot;)</code> 权限调用 <code>checkPermission</code>。
 <p>
如果重写此方法，那么通常应该在已重写方法将要抛出异常时调用 <code>super.checkWrite</code>。
<P>
<DD><DL>
<DT><B>参数：</B><DD><CODE>fd</CODE> - 取决于系统的文件描述符。
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../java/lang/SecurityException.html" title="java.lang 中的类">SecurityException</A></CODE> - 如果调用的方法没有访问指定文件描述符的权限。
<DD><CODE><A HREF="../../java/lang/NullPointerException.html" title="java.lang 中的类">NullPointerException</A></CODE> - 如果文件描述符参数为 <code>null</code>。<DT><B>另请参见：</B><DD><A HREF="../../java/io/FileDescriptor.html" title="java.io 中的类"><CODE>FileDescriptor</CODE></A>, 
<A HREF="../../java/lang/SecurityManager.html#checkPermission(java.security.Permission)"><CODE>checkPermission</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="checkWrite(java.lang.String)"><!-- --></A><H3>
checkWrite</H3>
<PRE>
public void <B>checkWrite</B>(<A HREF="../../java/lang/String.html" title="java.lang 中的类">String</A>&nbsp;file)</PRE>
<DL>
<DD>如果不允许调用线程写由字符串参数指定的文件，则抛出 <code>SecurityException</code>。
 <p>
此方法用 <code>FilePermission(file,&quot;write&quot;)</code> 权限调用 <code>checkPermission</code>。
 <p>
如果重写此方法，那么通常应该在已重写方法将要抛出异常时调用 <code>super.checkWrite</code>。
<P>
<DD><DL>
<DT><B>参数：</B><DD><CODE>file</CODE> - 取决于系统的文件名。
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../java/lang/SecurityException.html" title="java.lang 中的类">SecurityException</A></CODE> - 如果调用线程没有访问指定文件的权限。
<DD><CODE><A HREF="../../java/lang/NullPointerException.html" title="java.lang 中的类">NullPointerException</A></CODE> - 如果 <code>file</code> 参数为 <code>null</code>。<DT><B>另请参见：</B><DD><A HREF="../../java/lang/SecurityManager.html#checkPermission(java.security.Permission)"><CODE>checkPermission</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="checkDelete(java.lang.String)"><!-- --></A><H3>
checkDelete</H3>
<PRE>
public void <B>checkDelete</B>(<A HREF="../../java/lang/String.html" title="java.lang 中的类">String</A>&nbsp;file)</PRE>
<DL>
<DD>如果不允许调用线程删除指定的文件，则抛出 <code>SecurityException</code>。
 <p>
由 <code>File</code> 类的 <code>delete</code> 方法为当前的安全管理器调用此方法。
 <p>
此方法用 <code>FilePermission(file,&quot;delete&quot;)</code> 权限调用 <code>checkPermission</code>。
 <p>
如果重写此方法，那么通常应该在已重写方法将要抛出异常时调用 <code>super.checkDelete</code>。
<P>
<DD><DL>
<DT><B>参数：</B><DD><CODE>file</CODE> - 取决于系统的文件名。
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../java/lang/SecurityException.html" title="java.lang 中的类">SecurityException</A></CODE> - 如果调用线程没有删除文件的权限。
<DD><CODE><A HREF="../../java/lang/NullPointerException.html" title="java.lang 中的类">NullPointerException</A></CODE> - 如果 <code>file</code> 参数为 <code>null</code>。<DT><B>另请参见：</B><DD><A HREF="../../java/io/File.html#delete()"><CODE>File.delete()</CODE></A>, 
<A HREF="../../java/lang/SecurityManager.html#checkPermission(java.security.Permission)"><CODE>checkPermission</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="checkConnect(java.lang.String, int)"><!-- --></A><H3>
checkConnect</H3>
<PRE>
public void <B>checkConnect</B>(<A HREF="../../java/lang/String.html" title="java.lang 中的类">String</A>&nbsp;host,
                         int&nbsp;port)</PRE>
<DL>
<DD>如果不允许调用线程打开到指定主机和端口号的套接字连接，则抛出 <code>SecurityException</code>。
 <p>
端口号 <code>-1</code> 表示调用的方法正在试图确定指定主机名的 IP 地址。
 <p>
如果端口号不等于 -1，则此方法用 <code>SocketPermission(host+&quot;:&quot;+port,&quot;connect&quot;)</code> 权限调用 <code>checkPermission</code>。如果端口号等于 -1，则用 <code>SocketPermission(host,&quot;resolve&quot;)</code> 权限调用 <code>checkPermission</code>。
 <p>
如果重写此方法，那么通常应该在已重写方法将要抛出异常时调用 <code>super.checkConnect</code>。
<P>
<DD><DL>
<DT><B>参数：</B><DD><CODE>host</CODE> - 要连接的主机名端口。<DD><CODE>port</CODE> - 要连接的协议端口。
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../java/lang/SecurityException.html" title="java.lang 中的类">SecurityException</A></CODE> - 如果不允许调用线程打开与指定 <code>host</code> 和 <code>port</code> 的套接字连接。
<DD><CODE><A HREF="../../java/lang/NullPointerException.html" title="java.lang 中的类">NullPointerException</A></CODE> - 如果 <code>host</code> 参数为 <code>null</code>。<DT><B>另请参见：</B><DD><A HREF="../../java/lang/SecurityManager.html#checkPermission(java.security.Permission)"><CODE>checkPermission</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="checkConnect(java.lang.String, int, java.lang.Object)"><!-- --></A><H3>
checkConnect</H3>
<PRE>
public void <B>checkConnect</B>(<A HREF="../../java/lang/String.html" title="java.lang 中的类">String</A>&nbsp;host,
                         int&nbsp;port,
                         <A HREF="../../java/lang/Object.html" title="java.lang 中的类">Object</A>&nbsp;context)</PRE>
<DL>
<DD>如果不允许指定的安全上下文打开与指定主机和端口号的套接字连接，则抛出 <code>SecurityException</code>。
 <p>
端口号 <code>-1</code> 表示调用的方法正试图确定指定主机名的 IP 地址。
<p> 如果 <code>context</code> 不是 <code>AccessControlContext</code> 的一个实例，则抛出 <code>SecurityException</code>。
 <p>
否则就检查端口号。如果端口号不等于 -1，则用 <code>SocketPermission(host+&quot;:&quot;+port,&quot;connect&quot;)</code> 权限调用 <code>context</code> 的 <code>checkPermission</code> 方法。如果端口号等于 -1，则用 <code>SocketPermission(host,&quot;resolve&quot;)</code> 权限调用 <code>context</code> 的 <code>checkPermission</code> 方法。
 <p>
如果重写此方法，那么通常应该在已重写方法将要抛出异常时调用 <code>super.checkConnect</code>。
<P>
<DD><DL>
<DT><B>参数：</B><DD><CODE>host</CODE> - 要连接的主机名端口。<DD><CODE>port</CODE> - 要连接的协议端口。<DD><CODE>context</CODE> - 取决于系统的安全上下文。
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../java/lang/SecurityException.html" title="java.lang 中的类">SecurityException</A></CODE> - 如果指定的安全上下文不是 <code>AccessControlContext</code>的一个实例（如为 <code>null</code>），或者不允许打开与指定 <code>host</code> 和 <code>port</code> 套接字连接。
<DD><CODE><A HREF="../../java/lang/NullPointerException.html" title="java.lang 中的类">NullPointerException</A></CODE> - 如果 <code>host</code> 参数为 <code>null</code>。<DT><B>另请参见：</B><DD><A HREF="../../java/lang/SecurityManager.html#getSecurityContext()"><CODE>getSecurityContext()</CODE></A>, 
<A HREF="../../java/security/AccessControlContext.html#checkPermission(java.security.Permission)"><CODE>AccessControlContext.checkPermission(java.security.Permission)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="checkListen(int)"><!-- --></A><H3>
checkListen</H3>
<PRE>
public void <B>checkListen</B>(int&nbsp;port)</PRE>
<DL>
<DD>如果不允许调用线程等待与指定本地端口号进行连接的请求，则抛出 <code>SecurityException</code>。
 <p>
如果端口号不是 0，则此方法用 <code>SocketPermission(&quot;localhost:&quot;+port,&quot;listen&quot;)</code> 调用 <code>checkPermission</code>。如果端口号是 0，则此方法用 <code>SocketPermission(&quot;localhost:1024-&quot;,&quot;listen&quot;)</code> 调用 <code>checkPermission</code>。
 <p>
如果重写此方法，那么通常应该在已重写方法将要抛出异常时调用 <code>super.checkListen</code>。
<P>
<DD><DL>
<DT><B>参数：</B><DD><CODE>port</CODE> - 本地端口。
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../java/lang/SecurityException.html" title="java.lang 中的类">SecurityException</A></CODE> - 如果调用的方法没有侦听指定端口的权限。<DT><B>另请参见：</B><DD><A HREF="../../java/lang/SecurityManager.html#checkPermission(java.security.Permission)"><CODE>checkPermission</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="checkAccept(java.lang.String, int)"><!-- --></A><H3>
checkAccept</H3>
<PRE>
public void <B>checkAccept</B>(<A HREF="../../java/lang/String.html" title="java.lang 中的类">String</A>&nbsp;host,
                        int&nbsp;port)</PRE>
<DL>
<DD>如果不允许调用线程从指定的主机和端口号接受套接字连接，则抛出 <code>SecurityException</code>。
 <p>
由 <code>ServerSocket</code> 类的 <code>accept</code> 方法为当前的安全管理器调用此方法。
 <p>
此方法用 <code>SocketPermission(host+&quot;:&quot;+port,&quot;accept&quot;)</code> 权限调用 <code>checkPermission</code>。
 <p>
如果重写此方法，那么通常应该在已重写方法将要抛出异常时调用 <code>super.checkAccept</code>。
<P>
<DD><DL>
<DT><B>参数：</B><DD><CODE>host</CODE> - 套接字连接的主机名。<DD><CODE>port</CODE> - 套接字连接的端口号。
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../java/lang/SecurityException.html" title="java.lang 中的类">SecurityException</A></CODE> - 如果调用线程没有接受连接的权限。
<DD><CODE><A HREF="../../java/lang/NullPointerException.html" title="java.lang 中的类">NullPointerException</A></CODE> - 如果 <code>host</code> 参数为 <code>null</code>。<DT><B>另请参见：</B><DD><A HREF="../../java/net/ServerSocket.html#accept()"><CODE>ServerSocket.accept()</CODE></A>, 
<A HREF="../../java/lang/SecurityManager.html#checkPermission(java.security.Permission)"><CODE>checkPermission</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="checkMulticast(java.net.InetAddress)"><!-- --></A><H3>
checkMulticast</H3>
<PRE>
public void <B>checkMulticast</B>(<A HREF="../../java/net/InetAddress.html" title="java.net 中的类">InetAddress</A>&nbsp;maddr)</PRE>
<DL>
<DD>如果不允许调用线程使用（加入/离开/发送/接收）IP 多址广播，则抛出 <code>SecurityException</code>。
 <p>
此方法使用 <code>java.net.SocketPermission(maddr.getHostAddress(), &quot;accept,connect&quot;)</code> 权限调用 <code>checkPermission</code>。
 <p>
如果重写此方法，那么通常应该在已重写方法将要抛出异常时调用 <code>super.checkMulticast</code>。
<P>
<DD><DL>
<DT><B>参数：</B><DD><CODE>maddr</CODE> - 要使用的 Internet 组地址。
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../java/lang/SecurityException.html" title="java.lang 中的类">SecurityException</A></CODE> - 如果不允许调用线程使用（加入/离开/发送/接收）IP 多址广播。
<DD><CODE><A HREF="../../java/lang/NullPointerException.html" title="java.lang 中的类">NullPointerException</A></CODE> - 如果地址参数为 <code>null</code>。<DT><B>从以下版本开始：</B></DT>
  <DD>JDK1.1</DD>
<DT><B>另请参见：</B><DD><A HREF="../../java/lang/SecurityManager.html#checkPermission(java.security.Permission)"><CODE>checkPermission</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="checkMulticast(java.net.InetAddress, byte)"><!-- --></A><H3>
checkMulticast</H3>
<PRE>
<FONT SIZE="-1"><A HREF="../../java/lang/Deprecated.html" title="java.lang 中的注释">@Deprecated</A>
</FONT>public void <B>checkMulticast</B>(<A HREF="../../java/net/InetAddress.html" title="java.net 中的类">InetAddress</A>&nbsp;maddr,
                                      byte&nbsp;ttl)</PRE>
<DL>
<DD><B>已过时。</B>&nbsp;<I>由 #checkPermission(java.security.Permission) 取代</I>
<P>
<DD>如果不允许调用线程使用（加入/离开/发送/接收）IP 多址广播，则抛出 <code>SecurityException</code>。
 <p>
此方法用 <code>java.net.SocketPermission(maddr.getHostAddress(), &quot;accept,connect&quot;)</code> 权限调用 <code>checkPermission</code>。 
 <p>
如果重写此方法，那么通常应该在已重写方法将要抛出异常时调用 <code>super.checkMulticast</code>。
<P>
<DD><DL>
<DT><B>参数：</B><DD><CODE>maddr</CODE> - 要使用的 Internet 组地址。<DD><CODE>ttl</CODE> - 正在使用的值，如果是用多址广播发送的话。注：此特定实现不使用 ttl 参数。
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../java/lang/SecurityException.html" title="java.lang 中的类">SecurityException</A></CODE> - 如果不允许调用线程使用（加入/离开/发送/接收）IP 多址广播。
<DD><CODE><A HREF="../../java/lang/NullPointerException.html" title="java.lang 中的类">NullPointerException</A></CODE> - 如果地址参数为 <code>null</code>。<DT><B>从以下版本开始：</B></DT>
  <DD>JDK1.1</DD>
<DT><B>另请参见：</B><DD><A HREF="../../java/lang/SecurityManager.html#checkPermission(java.security.Permission)"><CODE>checkPermission</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="checkPropertiesAccess()"><!-- --></A><H3>
checkPropertiesAccess</H3>
<PRE>
public void <B>checkPropertiesAccess</B>()</PRE>
<DL>
<DD>如果不允许调用线程访问或修改系统属性，则抛出 <code>SecurityException</code>。
 <p>
由 <code>System</code> 类的 <code>getProperties</code> 和 <code>setProperties</code> 方法使用此方法。
 <p>
此方法用 <code>PropertyPermission(&quot;*&quot;, &quot;read,write&quot;)</code> 权限调用 <code>checkPermission</code>。
 <p>
如果重写此方法，那么通常应该在已重写方法将要抛出异常时调用 <code>super.checkPropertiesAccess</code>。
 <p>
<P>
<DD><DL>

<DT><B>抛出：</B>
<DD><CODE><A HREF="../../java/lang/SecurityException.html" title="java.lang 中的类">SecurityException</A></CODE> - 如果调用线程没有访问或修改系统属性的权限。<DT><B>另请参见：</B><DD><A HREF="../../java/lang/System.html#getProperties()"><CODE>System.getProperties()</CODE></A>, 
<A HREF="../../java/lang/System.html#setProperties(java.util.Properties)"><CODE>System.setProperties(java.util.Properties)</CODE></A>, 
<A HREF="../../java/lang/SecurityManager.html#checkPermission(java.security.Permission)"><CODE>checkPermission</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="checkPropertyAccess(java.lang.String)"><!-- --></A><H3>
checkPropertyAccess</H3>
<PRE>
public void <B>checkPropertyAccess</B>(<A HREF="../../java/lang/String.html" title="java.lang 中的类">String</A>&nbsp;key)</PRE>
<DL>
<DD>如果不允许调用线程访问具有指定的 <code>key</code> 名的系统属性，则抛出 <code>SecurityException</code>。
 <p>
由 <code>System</code> 类的 <code>getProperty</code> 方法使用此方法。
 <p>
此方法用 <code>PropertyPermission(key, &quot;read&quot;)</code> 权限调用 <code>checkPermission</code>。
 <p>
 <p>
如果重写此方法，那么通常应该在已重写方法将要抛出异常时调用 <code>super.checkPropertyAccess</code>。
<P>
<DD><DL>
<DT><B>参数：</B><DD><CODE>key</CODE> - 系统属性键。
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../java/lang/SecurityException.html" title="java.lang 中的类">SecurityException</A></CODE> - 如果调用线程没有访问指定系统属性的权限。
<DD><CODE><A HREF="../../java/lang/NullPointerException.html" title="java.lang 中的类">NullPointerException</A></CODE> - 如果 <code>key</code> 参数为 <code>null</code>。
<DD><CODE><A HREF="../../java/lang/IllegalArgumentException.html" title="java.lang 中的类">IllegalArgumentException</A></CODE> - 如果 <code>key</code> 为空。<DT><B>另请参见：</B><DD><A HREF="../../java/lang/System.html#getProperty(java.lang.String)"><CODE>System.getProperty(java.lang.String)</CODE></A>, 
<A HREF="../../java/lang/SecurityManager.html#checkPermission(java.security.Permission)"><CODE>checkPermission</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="checkTopLevelWindow(java.lang.Object)"><!-- --></A><H3>
checkTopLevelWindow</H3>
<PRE>
public boolean <B>checkTopLevelWindow</B>(<A HREF="../../java/lang/Object.html" title="java.lang 中的类">Object</A>&nbsp;window)</PRE>
<DL>
<DD>如果不受信任的调用线程调出由 <code>window</code> 参数指出的顶层窗口，则返回 <code>false</code>。在这种情况下，调用方仍然可以决定显示窗口，但窗口应包括某些可视的警告。如果此方法返回 <code>true</code>，则窗口的显示没有任何特殊的限制。
 <p>
有关受信任和不受信任窗口的更多信息，请参见 <code>Window</code> 类。
 <p>
此方法用 <code>AWTPermission(&quot;showWindowWithoutWarningBanner&quot;)</code> 权限调用 <code>checkPermission</code>，并且如果未抛出 SecurityException，则返回 <code>true</code>，否则返回 <code>false</code>。
 <p>
如果重写此方法，那么通常应该在已重写方法将要返回 <code>false</code> 时调用 <code>super.checkTopLevelWindow</code>，并且应该返回 <code>super.checkTopLevelWindow</code> 值。
<P>
<DD><DL>
<DT><B>参数：</B><DD><CODE>window</CODE> - 所创建的新窗口。
<DT><B>返回：</B><DD>如果信任的调用线程弹出顶层窗口，则返回 <code>true</code>，否则返回 <code>false</code>。
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../java/lang/NullPointerException.html" title="java.lang 中的类">NullPointerException</A></CODE> - 如果 <code>window</code> 参数为 <code>null</code>。<DT><B>另请参见：</B><DD><A HREF="../../java/awt/Window.html" title="java.awt 中的类"><CODE>Window</CODE></A>, 
<A HREF="../../java/lang/SecurityManager.html#checkPermission(java.security.Permission)"><CODE>checkPermission</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="checkPrintJobAccess()"><!-- --></A><H3>
checkPrintJobAccess</H3>
<PRE>
public void <B>checkPrintJobAccess</B>()</PRE>
<DL>
<DD>如果不允许调用线程发起一个打印作业请求，则抛出 <code>SecurityException</code>。
 <p>
此方法用 <code>RuntimePermission(&quot;queuePrintJob&quot;)</code> 权限调用 <code>checkPermission</code>。
 <p>
如果重写此方法，那么通常应该在已重写方法将要抛出异常时调用 <code>super.checkPrintJobAccess</code>。
 <p>
<P>
<DD><DL>

<DT><B>抛出：</B>
<DD><CODE><A HREF="../../java/lang/SecurityException.html" title="java.lang 中的类">SecurityException</A></CODE> - 如果调用线程没有发起打印作业请求的权限。<DT><B>从以下版本开始：</B></DT>
  <DD>JDK1.1</DD>
<DT><B>另请参见：</B><DD><A HREF="../../java/lang/SecurityManager.html#checkPermission(java.security.Permission)"><CODE>checkPermission</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="checkSystemClipboardAccess()"><!-- --></A><H3>
checkSystemClipboardAccess</H3>
<PRE>
public void <B>checkSystemClipboardAccess</B>()</PRE>
<DL>
<DD>如果不允许调用线程访问系统剪贴板，则抛出 <code>SecurityException</code>。
 <p>
此方法用 <code>AWTPermission(&quot;accessClipboard&quot;)</code> 权限调用 <code>checkPermission</code>。
 <p>
如果重写此方法，那么通常应该在已重写方法将要抛出异常时调用 <code>super.checkSystemClipboardAccess</code>。
<P>
<DD><DL>

<DT><B>抛出：</B>
<DD><CODE><A HREF="../../java/lang/SecurityException.html" title="java.lang 中的类">SecurityException</A></CODE> - 如果调用线程没有访问系统剪贴板的权限。<DT><B>从以下版本开始：</B></DT>
  <DD>JDK1.1</DD>
<DT><B>另请参见：</B><DD><A HREF="../../java/lang/SecurityManager.html#checkPermission(java.security.Permission)"><CODE>checkPermission</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="checkAwtEventQueueAccess()"><!-- --></A><H3>
checkAwtEventQueueAccess</H3>
<PRE>
public void <B>checkAwtEventQueueAccess</B>()</PRE>
<DL>
<DD>如果不允许调用线程访问 AWT 事件队列，则抛出 <code>SecurityException</code>。
 <p>
此方法用 <code>AWTPermission(&quot;accessEventQueue&quot;)</code> 权限调用 <code>checkPermission</code>。
 <p>
如果重写此方法，那么通常应该在已重写方法将要抛出异常时调用 <code>super.checkAwtEventQueueAccess</code>。
<P>
<DD><DL>

<DT><B>抛出：</B>
<DD><CODE><A HREF="../../java/lang/SecurityException.html" title="java.lang 中的类">SecurityException</A></CODE> - 如果调用线程没有访问 AWT 事件队列的权限。<DT><B>从以下版本开始：</B></DT>
  <DD>JDK1.1</DD>
<DT><B>另请参见：</B><DD><A HREF="../../java/lang/SecurityManager.html#checkPermission(java.security.Permission)"><CODE>checkPermission</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="checkPackageAccess(java.lang.String)"><!-- --></A><H3>
checkPackageAccess</H3>
<PRE>
public void <B>checkPackageAccess</B>(<A HREF="../../java/lang/String.html" title="java.lang 中的类">String</A>&nbsp;pkg)</PRE>
<DL>
<DD>如果不允许调用线程访问由参数指定的包，则抛出 <code>SecurityException</code>。
 <p>
由类加载器的 <code>loadClass</code> 方法使用此方法。
 <p>
此方法首先获取受限制包的列表，方法是从对 <code>java.security.Security.getProperty(&quot;package.access&quot;)</code> 的调用中获得一个逗号分隔的列表，并查看受限制包是否以 <code>pkg</code> 开头或等于该字符。如果是，则用 <code>RuntimePermission(&quot;accessClassInPackage.&quot;+pkg)</code> 权限调用 <code>checkPermission</code>。
 <p>
如果重写了此方法，则应在已重写方法的首行调用 <code>super.checkPackageAccess</code>。
<P>
<DD><DL>
<DT><B>参数：</B><DD><CODE>pkg</CODE> - 包名。
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../java/lang/SecurityException.html" title="java.lang 中的类">SecurityException</A></CODE> - 如果调用线程没有访问指定包的权限。
<DD><CODE><A HREF="../../java/lang/NullPointerException.html" title="java.lang 中的类">NullPointerException</A></CODE> - 如果包名参数为 <code>null</code>。<DT><B>另请参见：</B><DD><A HREF="../../java/lang/ClassLoader.html#loadClass(java.lang.String, boolean)"><CODE>loadClass</CODE></A>, 
<A HREF="../../java/security/Security.html#getProperty(java.lang.String)"><CODE>getProperty</CODE></A>, 
<A HREF="../../java/lang/SecurityManager.html#checkPermission(java.security.Permission)"><CODE>checkPermission</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="checkPackageDefinition(java.lang.String)"><!-- --></A><H3>
checkPackageDefinition</H3>
<PRE>
public void <B>checkPackageDefinition</B>(<A HREF="../../java/lang/String.html" title="java.lang 中的类">String</A>&nbsp;pkg)</PRE>
<DL>
<DD>如果不允许调用线程在参数指定的包中定义类，则抛出 <code>SecurityException</code>。
 <p>
由类加载器的 <code>loadClass</code> 方法使用此方法。
 <p>
此方法首先获取受限制包的列表，方法是从对 <code>java.security.Security.getProperty(&quot;package.definition&quot;)</code> 的调用中获得一个逗号分隔的列表，并查看受限制包是否以 <code>pkg</code> 开头或等于该字符。如果是，则用 <code>RuntimePermission(&quot;defineClassInPackage.&quot;+pkg)</code> 权限调用 <code>checkPermission</code>。
 <p>
如果重写了此方法，则应在已重写方法的首行调用 <code>super.checkPackageDefinition</code>。
<P>
<DD><DL>
<DT><B>参数：</B><DD><CODE>pkg</CODE> - 包名。
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../java/lang/SecurityException.html" title="java.lang 中的类">SecurityException</A></CODE> - 如果调用线程没有在指定包中定义类的权限。<DT><B>另请参见：</B><DD><A HREF="../../java/lang/ClassLoader.html#loadClass(java.lang.String, boolean)"><CODE>ClassLoader.loadClass(java.lang.String, boolean)</CODE></A>, 
<A HREF="../../java/security/Security.html#getProperty(java.lang.String)"><CODE>getProperty</CODE></A>, 
<A HREF="../../java/lang/SecurityManager.html#checkPermission(java.security.Permission)"><CODE>checkPermission</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="checkSetFactory()"><!-- --></A><H3>
checkSetFactory</H3>
<PRE>
public void <B>checkSetFactory</B>()</PRE>
<DL>
<DD>如果不允许调用线程设置由 <code>ServerSocket</code> 或 <code>Socket</code> 使用的套接字工厂，或者由 <code>URL</code> 使用的流处理程序工厂，则抛出 <code>SecurityException</code>。
 <p>
此方法用 <code>RuntimePermission(&quot;setFactory&quot;)</code> 权限调用 <code>checkPermission</code>。
 <p>
如果重写此方法，那么通常应该在已重写方法将要抛出异常时调用 <code>super.checkSetFactory</code>。
 <p>
<P>
<DD><DL>

<DT><B>抛出：</B>
<DD><CODE><A HREF="../../java/lang/SecurityException.html" title="java.lang 中的类">SecurityException</A></CODE> - 如果调用线程没有指定套接字工厂或流处理程序工厂的权限。<DT><B>另请参见：</B><DD><A HREF="../../java/net/ServerSocket.html#setSocketFactory(java.net.SocketImplFactory)"><CODE>setSocketFactory</CODE></A>, 
<A HREF="../../java/net/Socket.html#setSocketImplFactory(java.net.SocketImplFactory)"><CODE>setSocketImplFactory</CODE></A>, 
<A HREF="../../java/net/URL.html#setURLStreamHandlerFactory(java.net.URLStreamHandlerFactory)"><CODE>setURLStreamHandlerFactory</CODE></A>, 
<A HREF="../../java/lang/SecurityManager.html#checkPermission(java.security.Permission)"><CODE>checkPermission</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="checkMemberAccess(java.lang.Class, int)"><!-- --></A><H3>
checkMemberAccess</H3>
<PRE>
public void <B>checkMemberAccess</B>(<A HREF="../../java/lang/Class.html" title="java.lang 中的类">Class</A>&lt;?&gt;&nbsp;clazz,
                              int&nbsp;which)</PRE>
<DL>
<DD>如果不允许调用线程访问程序，则抛出 <code>SecurityException</code>。
 <p>
默认的策略是允许访问 PUBLIC 成员，以及访问具有与调用方相同类加载器的类。在所有其他情况下，此方法用 <code>RuntimePermission(&quot;accessDeclaredMembers&quot;)</code> 权限调用 <code>checkPermission</code>。
 <p>
如果重写此方法，则不能调用 <code>super.checkMemberAccess</code>，因为 <code>checkMemberAccess</code> 的默认实现依赖于堆栈深度为 4 时检查的代码。
<P>
<DD><DL>
<DT><B>参数：</B><DD><CODE>clazz</CODE> - 要执行反射的类。<DD><CODE>which</CODE> - 访问类型，PUBLIC 或 DECLARED。
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../java/lang/SecurityException.html" title="java.lang 中的类">SecurityException</A></CODE> - 如果调用方没有访问成员的权限。
<DD><CODE><A HREF="../../java/lang/NullPointerException.html" title="java.lang 中的类">NullPointerException</A></CODE> - 如果 <code>clazz</code> 参数为 <code>null</code>。<DT><B>从以下版本开始：</B></DT>
  <DD>JDK1.1</DD>
<DT><B>另请参见：</B><DD><A HREF="../../java/lang/reflect/Member.html" title="java.lang.reflect 中的接口"><CODE>Member</CODE></A>, 
<A HREF="../../java/lang/SecurityManager.html#checkPermission(java.security.Permission)"><CODE>checkPermission</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="checkSecurityAccess(java.lang.String)"><!-- --></A><H3>
checkSecurityAccess</H3>
<PRE>
public void <B>checkSecurityAccess</B>(<A HREF="../../java/lang/String.html" title="java.lang 中的类">String</A>&nbsp;target)</PRE>
<DL>
<DD>确定是应该允许还是拒绝具有指定权限目标名的权限。

<p> 如果允许请求的权限，则此方法不执行任何操作。如果拒绝，则引发 SecurityException。

<p> 此方法为给定权限的目标名创建一个 <code>SecurityPermission</code> 对象并用该对象调用 <code>checkPermission</code> 。

<p> 有关可用权限目标名的列表，请参阅 <code><A HREF="../../java/security/SecurityPermission.html" title="java.security 中的类"><CODE>SecurityPermission</CODE></A></code> 的文档。
 
<p> 如果重写此方法，那么通常应该在已重写方法将要抛出异常时调用 <code>super.checkSecurityAccess</code>。
<P>
<DD><DL>
<DT><B>参数：</B><DD><CODE>target</CODE> - <code>SecurityPermission</code> 的目标名。
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../java/lang/SecurityException.html" title="java.lang 中的类">SecurityException</A></CODE> - 如果调用线程没有所请求访问的权限。
<DD><CODE><A HREF="../../java/lang/NullPointerException.html" title="java.lang 中的类">NullPointerException</A></CODE> - 如果 <code>target</code> 为 null。
<DD><CODE><A HREF="../../java/lang/IllegalArgumentException.html" title="java.lang 中的类">IllegalArgumentException</A></CODE> - 如果 <code>target</code> 为空。<DT><B>从以下版本开始：</B></DT>
  <DD>JDK1.1</DD>
<DT><B>另请参见：</B><DD><A HREF="../../java/lang/SecurityManager.html#checkPermission(java.security.Permission)"><CODE>checkPermission</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="getThreadGroup()"><!-- --></A><H3>
getThreadGroup</H3>
<PRE>
public <A HREF="../../java/lang/ThreadGroup.html" title="java.lang 中的类">ThreadGroup</A> <B>getThreadGroup</B>()</PRE>
<DL>
<DD>调用此方法时，返回所有新创建的线程实例化后所在的线程组。默认情况下，返回当前线程所在的线程组。应该由指定的安全管理器重写此方法，以返回适当的线程组。
<P>
<DD><DL>

<DT><B>返回：</B><DD>ThreadGroup 新线程被实例化后所在的线程组<DT><B>从以下版本开始：</B></DT>
  <DD>JDK1.1</DD>
<DT><B>另请参见：</B><DD><A HREF="../../java/lang/ThreadGroup.html" title="java.lang 中的类"><CODE>ThreadGroup</CODE></A></DL>
</DD>
</DL>
<!-- ========= END OF CLASS DATA ========= -->
<HR>


<!-- ======= START OF BOTTOM NAVBAR ====== -->
<A NAME="navbar_bottom"><!-- --></A>
<A HREF="#skip-navbar_bottom" title="跳过导航链接"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>概述</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>软件包</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>类</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/SecurityManager.html"><FONT CLASS="NavBarFont1"><B>使用</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>树</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>已过时</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>索引</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../help-doc.html"><FONT CLASS="NavBarFont1"><B>帮助</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
<b>Java<sup><font size=-2>TM</font></sup>&nbsp;Platform<br>Standard&nbsp;Ed. 6</b></EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../java/lang/SecurityException.html" title="java.lang 中的类"><B>上一个类</B></A>&nbsp;
&nbsp;<A HREF="../../java/lang/Short.html" title="java.lang 中的类"><B>下一个类</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../index.html?java/lang/SecurityManager.html" target="_top"><B>框架</B></A>  &nbsp;
&nbsp;<A HREF="SecurityManager.html" target="_top"><B>无框架</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../allclasses-noframe.html"><B>所有类</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../allclasses-noframe.html"><B>所有类</B></A>
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  摘要：&nbsp;嵌套&nbsp;|&nbsp;<A HREF="#field_summary">字段</A>&nbsp;|&nbsp;<A HREF="#constructor_summary">构造方法</A>&nbsp;|&nbsp;<A HREF="#method_summary">方法</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
详细信息：&nbsp;<A HREF="#field_detail">字段</A>&nbsp;|&nbsp;<A HREF="#constructor_detail">构造方法</A>&nbsp;|&nbsp;<A HREF="#method_detail">方法</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_bottom"></A>
<!-- ======== END OF BOTTOM NAVBAR ======= -->

<HR>
<font size="-1"><a href="http://bugs.sun.com/services/bugreport/index.jsp">提交错误或意见</a><br>有关更多的 API 参考资料和开发人员文档，请参阅 <a href="http://java.sun.com/javase/6/webnotes/devdocs-vs-specs.html">Java SE 开发人员文档</a>。该文档包含更详细的、面向开发人员的描述，以及总体概述、术语定义、使用技巧和工作代码示例。 <p>版权所有 2007 Sun Microsystems, Inc. 保留所有权利。 请遵守<a href="http://java.sun.com/javase/6/docs/legal/license.html">许可证条款</a>。另请参阅<a href="http://java.sun.com/docs/redist.html">文档重新分发政策</a>。</font>
</BODY>
</HTML>
