<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc (build 1.6.0-beta2) on Mon Mar 19 18:16:27 CST 2007 -->
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
<TITLE>
Container (Java Platform SE 6)
</TITLE>

<META NAME="date" CONTENT="2007-03-19">

<LINK REL ="stylesheet" TYPE="text/css" HREF="../../stylesheet.css" TITLE="Style">

<SCRIPT type="text/javascript">
function windowTitle()
{
    if (location.href.indexOf('is-external=true') == -1) {
        parent.document.title="Container (Java Platform SE 6)";
    }
}
</SCRIPT>
<NOSCRIPT>
</NOSCRIPT>

</HEAD>

<BODY BGCOLOR="white" onload="windowTitle();">
<HR>


<!-- ========= START OF TOP NAVBAR ======= -->
<A NAME="navbar_top"><!-- --></A>
<A HREF="#skip-navbar_top" title="跳过导航链接"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>概述</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>软件包</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>类</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/Container.html"><FONT CLASS="NavBarFont1"><B>使用</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>树</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>已过时</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>索引</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../help-doc.html"><FONT CLASS="NavBarFont1"><B>帮助</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
<b>Java<sup><font size=-2>TM</font></sup>&nbsp;Platform<br>Standard&nbsp;Ed. 6</b></EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../java/awt/CompositeContext.html" title="java.awt 中的接口"><B>上一个类</B></A>&nbsp;
&nbsp;<A HREF="../../java/awt/Container.AccessibleAWTContainer.html" title="java.awt 中的类"><B>下一个类</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../index.html?java/awt/Container.html" target="_top"><B>框架</B></A>  &nbsp;
&nbsp;<A HREF="Container.html" target="_top"><B>无框架</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../allclasses-noframe.html"><B>所有类</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../allclasses-noframe.html"><B>所有类</B></A>
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  摘要：&nbsp;<A HREF="#nested_class_summary">嵌套</A>&nbsp;|&nbsp;<A HREF="#fields_inherited_from_class_java.awt.Component">字段</A>&nbsp;|&nbsp;<A HREF="#constructor_summary">构造方法</A>&nbsp;|&nbsp;<A HREF="#method_summary">方法</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
详细信息：&nbsp;字段&nbsp;|&nbsp;<A HREF="#constructor_detail">构造方法</A>&nbsp;|&nbsp;<A HREF="#method_detail">方法</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_top"></A>
<!-- ========= END OF TOP NAVBAR ========= -->

<HR>
<!-- ======== START OF CLASS DATA ======== -->
<H2>
<FONT SIZE="-1">
java.awt</FONT>
<BR>
类 Container</H2>
<PRE>
<A HREF="../../java/lang/Object.html" title="java.lang 中的类">java.lang.Object</A>
  <IMG SRC="../../resources/inherit.gif" ALT="继承者 "><A HREF="../../java/awt/Component.html" title="java.awt 中的类">java.awt.Component</A>
      <IMG SRC="../../resources/inherit.gif" ALT="继承者 "><B>java.awt.Container</B>
</PRE>
<DL>
<DT><B>所有已实现的接口：</B> <DD><A HREF="../../java/awt/image/ImageObserver.html" title="java.awt.image 中的接口">ImageObserver</A>, <A HREF="../../java/awt/MenuContainer.html" title="java.awt 中的接口">MenuContainer</A>, <A HREF="../../java/io/Serializable.html" title="java.io 中的接口">Serializable</A></DD>
</DL>
<DL>
<DT><B>直接已知子类：</B> <DD><A HREF="../../javax/swing/plaf/basic/BasicSplitPaneDivider.html" title="javax.swing.plaf.basic 中的类">BasicSplitPaneDivider</A>, <A HREF="../../javax/swing/CellRendererPane.html" title="javax.swing 中的类">CellRendererPane</A>, <A HREF="../../javax/swing/tree/DefaultTreeCellEditor.EditorContainer.html" title="javax.swing.tree 中的类">DefaultTreeCellEditor.EditorContainer</A>, <A HREF="../../javax/swing/JComponent.html" title="javax.swing 中的类">JComponent</A>, <A HREF="../../java/awt/Panel.html" title="java.awt 中的类">Panel</A>, <A HREF="../../java/awt/ScrollPane.html" title="java.awt 中的类">ScrollPane</A>, <A HREF="../../java/awt/Window.html" title="java.awt 中的类">Window</A></DD>
</DL>
<HR>
<DL>
<DT><PRE>public class <B>Container</B><DT>extends <A HREF="../../java/awt/Component.html" title="java.awt 中的类">Component</A></DL>
</PRE>

<P>
一般的 Abstract Window Toolkit(AWT) 容器对象是一个可包含其他 AWT 组件的组件。
 <p>
添加到容器中的组件放在一个列表中。列表的顺序将定义组件在容器内的正向堆栈顺序。如果将组件添加到容器中时未指定索引，则该索引将被添加到列表尾部（此后它位于堆栈顺序的底部）。
 <p>
<b>注</b>：有关焦点子系统的详细信息，请参阅 <em>The Java Tutorial</em> 中 <a href="http://java.sun.com/docs/books/tutorial/uiswing/misc/focus.html">How to Use the Focus Subsystem</a> 一节，要获得更多的信息，请参阅 <a href="../../java/awt/doc-files/FocusSpec.html">Focus Specification</a>。
<P>

<P>
<DL>
<DT><B>从以下版本开始：</B></DT>
  <DD>JDK1.0</DD>
<DT><B>另请参见：</B><DD><A HREF="../../java/awt/Container.html#add(java.awt.Component, int)"><CODE>add(java.awt.Component, int)</CODE></A>, 
<A HREF="../../java/awt/Container.html#getComponent(int)"><CODE>getComponent(int)</CODE></A>, 
<A HREF="../../java/awt/LayoutManager.html" title="java.awt 中的接口"><CODE>LayoutManager</CODE></A>, 
<A HREF="../../serialized-form.html#java.awt.Container">序列化表格</A></DL>
<HR>

<P>
<!-- ======== NESTED CLASS SUMMARY ======== -->

<A NAME="nested_class_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>嵌套类摘要</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;class</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/awt/Container.AccessibleAWTContainer.html" title="java.awt 中的类">Container.AccessibleAWTContainer</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;用于对可访问性提供默认支持的 Container 内部类。</TD>
</TR>
</TABLE>
&nbsp;<A NAME="nested_classes_inherited_from_class_java.awt.Component"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>从类 java.awt.<A HREF="../../java/awt/Component.html" title="java.awt 中的类">Component</A> 继承的嵌套类/接口</B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><A HREF="../../java/awt/Component.AccessibleAWTComponent.html" title="java.awt 中的类">Component.AccessibleAWTComponent</A>, <A HREF="../../java/awt/Component.BaselineResizeBehavior.html" title="java.awt 中的枚举">Component.BaselineResizeBehavior</A>, <A HREF="../../java/awt/Component.BltBufferStrategy.html" title="java.awt 中的类">Component.BltBufferStrategy</A>, <A HREF="../../java/awt/Component.FlipBufferStrategy.html" title="java.awt 中的类">Component.FlipBufferStrategy</A></CODE></TD>
</TR>
</TABLE>
&nbsp;
<!-- =========== FIELD SUMMARY =========== -->

<A NAME="field_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>字段摘要</B></FONT></TH>
</TR>
</TABLE>
&nbsp;<A NAME="fields_inherited_from_class_java.awt.Component"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>从类 java.awt.<A HREF="../../java/awt/Component.html" title="java.awt 中的类">Component</A> 继承的字段</B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><A HREF="../../java/awt/Component.html#BOTTOM_ALIGNMENT">BOTTOM_ALIGNMENT</A>, <A HREF="../../java/awt/Component.html#CENTER_ALIGNMENT">CENTER_ALIGNMENT</A>, <A HREF="../../java/awt/Component.html#LEFT_ALIGNMENT">LEFT_ALIGNMENT</A>, <A HREF="../../java/awt/Component.html#RIGHT_ALIGNMENT">RIGHT_ALIGNMENT</A>, <A HREF="../../java/awt/Component.html#TOP_ALIGNMENT">TOP_ALIGNMENT</A></CODE></TD>
</TR>
</TABLE>
&nbsp;<A NAME="fields_inherited_from_class_java.awt.image.ImageObserver"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>从接口 java.awt.image.<A HREF="../../java/awt/image/ImageObserver.html" title="java.awt.image 中的接口">ImageObserver</A> 继承的字段</B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><A HREF="../../java/awt/image/ImageObserver.html#ABORT">ABORT</A>, <A HREF="../../java/awt/image/ImageObserver.html#ALLBITS">ALLBITS</A>, <A HREF="../../java/awt/image/ImageObserver.html#ERROR">ERROR</A>, <A HREF="../../java/awt/image/ImageObserver.html#FRAMEBITS">FRAMEBITS</A>, <A HREF="../../java/awt/image/ImageObserver.html#HEIGHT">HEIGHT</A>, <A HREF="../../java/awt/image/ImageObserver.html#PROPERTIES">PROPERTIES</A>, <A HREF="../../java/awt/image/ImageObserver.html#SOMEBITS">SOMEBITS</A>, <A HREF="../../java/awt/image/ImageObserver.html#WIDTH">WIDTH</A></CODE></TD>
</TR>
</TABLE>
&nbsp;
<!-- ======== CONSTRUCTOR SUMMARY ======== -->

<A NAME="constructor_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>构造方法摘要</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../java/awt/Container.html#Container()">Container</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;构造一个新的 Container。</TD>
</TR>
</TABLE>
&nbsp;
<!-- ========== METHOD SUMMARY =========== -->

<A NAME="method_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>方法摘要</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/awt/Component.html" title="java.awt 中的类">Component</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/awt/Container.html#add(java.awt.Component)">add</A></B>(<A HREF="../../java/awt/Component.html" title="java.awt 中的类">Component</A>&nbsp;comp)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;将指定组件追加到此容器的尾部。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/awt/Component.html" title="java.awt 中的类">Component</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/awt/Container.html#add(java.awt.Component, int)">add</A></B>(<A HREF="../../java/awt/Component.html" title="java.awt 中的类">Component</A>&nbsp;comp,
    int&nbsp;index)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;将指定组件添加到此容器的给定位置上。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/awt/Container.html#add(java.awt.Component, java.lang.Object)">add</A></B>(<A HREF="../../java/awt/Component.html" title="java.awt 中的类">Component</A>&nbsp;comp,
    <A HREF="../../java/lang/Object.html" title="java.lang 中的类">Object</A>&nbsp;constraints)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;将指定的组件添加到此容器的尾部。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/awt/Container.html#add(java.awt.Component, java.lang.Object, int)">add</A></B>(<A HREF="../../java/awt/Component.html" title="java.awt 中的类">Component</A>&nbsp;comp,
    <A HREF="../../java/lang/Object.html" title="java.lang 中的类">Object</A>&nbsp;constraints,
    int&nbsp;index)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;使用指定约束，将指定组件添加到此容器的指定索引所在的位置上。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/awt/Component.html" title="java.awt 中的类">Component</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/awt/Container.html#add(java.lang.String, java.awt.Component)">add</A></B>(<A HREF="../../java/lang/String.html" title="java.lang 中的类">String</A>&nbsp;name,
    <A HREF="../../java/awt/Component.html" title="java.awt 中的类">Component</A>&nbsp;comp)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;将指定组件添加到此容器中。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/awt/Container.html#addContainerListener(java.awt.event.ContainerListener)">addContainerListener</A></B>(<A HREF="../../java/awt/event/ContainerListener.html" title="java.awt.event 中的接口">ContainerListener</A>&nbsp;l)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;添加指定容器的侦听器，以接收来自此容器的容器事件。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/awt/Container.html#addImpl(java.awt.Component, java.lang.Object, int)">addImpl</A></B>(<A HREF="../../java/awt/Component.html" title="java.awt 中的类">Component</A>&nbsp;comp,
        <A HREF="../../java/lang/Object.html" title="java.lang 中的类">Object</A>&nbsp;constraints,
        int&nbsp;index)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;将指定组件添加到此容器的指定索引所在的位置上。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/awt/Container.html#addNotify()">addNotify</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通过将这个 Container 连接到本机屏幕资源，使其可以显示。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/awt/Container.html#addPropertyChangeListener(java.beans.PropertyChangeListener)">addPropertyChangeListener</A></B>(<A HREF="../../java/beans/PropertyChangeListener.html" title="java.beans 中的接口">PropertyChangeListener</A>&nbsp;listener)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;将一个 PropertyChangeListener 添加到侦听器列表中。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/awt/Container.html#addPropertyChangeListener(java.lang.String, java.beans.PropertyChangeListener)">addPropertyChangeListener</A></B>(<A HREF="../../java/lang/String.html" title="java.lang 中的类">String</A>&nbsp;propertyName,
                          <A HREF="../../java/beans/PropertyChangeListener.html" title="java.beans 中的接口">PropertyChangeListener</A>&nbsp;listener)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;将一个 PropertyChangeListener 添加到某个指定属性的侦听器列表中。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/awt/Container.html#applyComponentOrientation(java.awt.ComponentOrientation)">applyComponentOrientation</A></B>(<A HREF="../../java/awt/ComponentOrientation.html" title="java.awt 中的类">ComponentOrientation</A>&nbsp;o)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;设置此容器和其中包含的所有组件的 <code>ComponentOrientation</code> 属性。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/awt/Container.html#areFocusTraversalKeysSet(int)">areFocusTraversalKeysSet</A></B>(int&nbsp;id)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;返回是否已经为此 Container 明确定义了用于给定焦点遍历操作的焦点遍历键的 Set。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/awt/Container.html#countComponents()">countComponents</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>已过时。</B>&nbsp;<I>从 JDK version 1.1 开始，用 etComponentCount() 取代。</I></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/awt/Container.html#deliverEvent(java.awt.Event)">deliverEvent</A></B>(<A HREF="../../java/awt/Event.html" title="java.awt 中的类">Event</A>&nbsp;e)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>已过时。</B>&nbsp;<I>从 JDK version 1.1 开始，用 <code>dispatchEvent(AWTEvent e)</code> 取代</I></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/awt/Container.html#doLayout()">doLayout</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;使此容器布置其组件。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/awt/Component.html" title="java.awt 中的类">Component</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/awt/Container.html#findComponentAt(int, int)">findComponentAt</A></B>(int&nbsp;x,
                int&nbsp;y)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对包含指定位置的可视子组件进行定位。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/awt/Component.html" title="java.awt 中的类">Component</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/awt/Container.html#findComponentAt(java.awt.Point)">findComponentAt</A></B>(<A HREF="../../java/awt/Point.html" title="java.awt 中的类">Point</A>&nbsp;p)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对包含指定点的可视子组件进行定位。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;float</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/awt/Container.html#getAlignmentX()">getAlignmentX</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;返回沿 x 轴的对齐方式。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;float</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/awt/Container.html#getAlignmentY()">getAlignmentY</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;返回沿 y 轴的对齐方式。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/awt/Component.html" title="java.awt 中的类">Component</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/awt/Container.html#getComponent(int)">getComponent</A></B>(int&nbsp;n)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;获取此容器中的第 n 个组件。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/awt/Component.html" title="java.awt 中的类">Component</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/awt/Container.html#getComponentAt(int, int)">getComponentAt</A></B>(int&nbsp;x,
               int&nbsp;y)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对包含 x，y 位置的组件进行定位。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/awt/Component.html" title="java.awt 中的类">Component</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/awt/Container.html#getComponentAt(java.awt.Point)">getComponentAt</A></B>(<A HREF="../../java/awt/Point.html" title="java.awt 中的类">Point</A>&nbsp;p)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;获取包含指定点的组件。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/awt/Container.html#getComponentCount()">getComponentCount</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;获取此面板中的组件数。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/awt/Component.html" title="java.awt 中的类">Component</A>[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/awt/Container.html#getComponents()">getComponents</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;获取此容器中的所有组件。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/awt/Container.html#getComponentZOrder(java.awt.Component)">getComponentZOrder</A></B>(<A HREF="../../java/awt/Component.html" title="java.awt 中的类">Component</A>&nbsp;comp)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;返回容器内组件的 z 顺序索引。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/awt/event/ContainerListener.html" title="java.awt.event 中的接口">ContainerListener</A>[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/awt/Container.html#getContainerListeners()">getContainerListeners</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;返回已在此容器上注册的所有容器侦听器的数组。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/util/Set.html" title="java.util 中的接口">Set</A>&lt;<A HREF="../../java/awt/AWTKeyStroke.html" title="java.awt 中的类">AWTKeyStroke</A>&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/awt/Container.html#getFocusTraversalKeys(int)">getFocusTraversalKeys</A></B>(int&nbsp;id)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;为此 Container 的给定遍历操作返回焦点遍历键的 Set。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/awt/FocusTraversalPolicy.html" title="java.awt 中的类">FocusTraversalPolicy</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/awt/Container.html#getFocusTraversalPolicy()">getFocusTraversalPolicy</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;返回焦点遍历策略，用于管理此 Container 子组件的键盘遍历；如果此 Container 不是一个焦点循环根，则返回 null。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/awt/Insets.html" title="java.awt 中的类">Insets</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/awt/Container.html#getInsets()">getInsets</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;确定此容器的 insets，它指示容器边框的大小。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/awt/LayoutManager.html" title="java.awt 中的接口">LayoutManager</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/awt/Container.html#getLayout()">getLayout</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;获取此容器的布局管理器。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T extends <A HREF="../../java/util/EventListener.html" title="java.util 中的接口">EventListener</A>&gt; 
<BR>
T[]</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/awt/Container.html#getListeners(java.lang.Class)">getListeners</A></B>(<A HREF="../../java/lang/Class.html" title="java.lang 中的类">Class</A>&lt;T&gt;&nbsp;listenerType)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;返回当前已在此 <code>Container</code> 上注册为 <code><em>Foo</em>Listener</code> 的所有对象的数组。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/awt/Dimension.html" title="java.awt 中的类">Dimension</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/awt/Container.html#getMaximumSize()">getMaximumSize</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;返回此容器的最大大小。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/awt/Dimension.html" title="java.awt 中的类">Dimension</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/awt/Container.html#getMinimumSize()">getMinimumSize</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;返回此容器的最小大小。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/awt/Point.html" title="java.awt 中的类">Point</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/awt/Container.html#getMousePosition(boolean)">getMousePosition</A></B>(boolean&nbsp;allowChildren)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果 <code>Container</code> 位于鼠标指针下，则返回鼠标指针在此 <code>Container</code> 的坐标中的位置，否则返回 <code>null</code>。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/awt/Dimension.html" title="java.awt 中的类">Dimension</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/awt/Container.html#getPreferredSize()">getPreferredSize</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;返回此容器的首选大小。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/awt/Insets.html" title="java.awt 中的类">Insets</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/awt/Container.html#insets()">insets</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>已过时。</B>&nbsp;<I>从 JDK version 1.1 开始，用 <code>getInsets()</code> 取代。</I></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/awt/Container.html#invalidate()">invalidate</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;使容器失效。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/awt/Container.html#isAncestorOf(java.awt.Component)">isAncestorOf</A></B>(<A HREF="../../java/awt/Component.html" title="java.awt 中的类">Component</A>&nbsp;c)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;检查该组件是否包含在此容器的组件层次结构中。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/awt/Container.html#isFocusCycleRoot()">isFocusCycleRoot</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;返回此 Container 是否是某个焦点遍历循环的根。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/awt/Container.html#isFocusCycleRoot(java.awt.Container)">isFocusCycleRoot</A></B>(<A HREF="../../java/awt/Container.html" title="java.awt 中的类">Container</A>&nbsp;container)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;返回指定的 Container 是否是此 Container 的焦点遍历循环的焦点循环根。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/awt/Container.html#isFocusTraversalPolicyProvider()">isFocusTraversalPolicyProvider</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;返回此容器是否提供焦点遍历策略。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/awt/Container.html#isFocusTraversalPolicySet()">isFocusTraversalPolicySet</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;返回是否为此 Container 明确设置焦点遍历策略。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/awt/Container.html#layout()">layout</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>已过时。</B>&nbsp;<I>从 JDK version 1.1，用 <code>doLayout()</code> 取代。</I></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/awt/Container.html#list(java.io.PrintStream, int)">list</A></B>(<A HREF="../../java/io/PrintStream.html" title="java.io 中的类">PrintStream</A>&nbsp;out,
     int&nbsp;indent)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;将此容器的清单打印到指定输出流。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/awt/Container.html#list(java.io.PrintWriter, int)">list</A></B>(<A HREF="../../java/io/PrintWriter.html" title="java.io 中的类">PrintWriter</A>&nbsp;out,
     int&nbsp;indent)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;将一个列表打印到指定打印编写器，从指定缩排位置开始。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/awt/Component.html" title="java.awt 中的类">Component</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/awt/Container.html#locate(int, int)">locate</A></B>(int&nbsp;x,
       int&nbsp;y)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>已过时。</B>&nbsp;<I>从 JDK version 1.1 开始，用 <code>getComponentAt(int, int)</code> 取代。</I></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/awt/Dimension.html" title="java.awt 中的类">Dimension</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/awt/Container.html#minimumSize()">minimumSize</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>已过时。</B>&nbsp;<I>从 JDK version 1.1 开始，用 <code>getMinimumSize()</code> 取代。</I></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/awt/Container.html#paint(java.awt.Graphics)">paint</A></B>(<A HREF="../../java/awt/Graphics.html" title="java.awt 中的类">Graphics</A>&nbsp;g)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;绘制容器。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/awt/Container.html#paintComponents(java.awt.Graphics)">paintComponents</A></B>(<A HREF="../../java/awt/Graphics.html" title="java.awt 中的类">Graphics</A>&nbsp;g)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;绘制此容器中的每个组件。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="../../java/lang/String.html" title="java.lang 中的类">String</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/awt/Container.html#paramString()">paramString</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;返回表示此 <code>Container</code> 的状态的字符串。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/awt/Dimension.html" title="java.awt 中的类">Dimension</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/awt/Container.html#preferredSize()">preferredSize</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>已过时。</B>&nbsp;<I>从 JDK version 1.1 开始，用 <code>getPreferredSize()</code> 取代。</I></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/awt/Container.html#print(java.awt.Graphics)">print</A></B>(<A HREF="../../java/awt/Graphics.html" title="java.awt 中的类">Graphics</A>&nbsp;g)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;打印容器。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/awt/Container.html#printComponents(java.awt.Graphics)">printComponents</A></B>(<A HREF="../../java/awt/Graphics.html" title="java.awt 中的类">Graphics</A>&nbsp;g)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;打印此容器中的每个组件。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/awt/Container.html#processContainerEvent(java.awt.event.ContainerEvent)">processContainerEvent</A></B>(<A HREF="../../java/awt/event/ContainerEvent.html" title="java.awt.event 中的类">ContainerEvent</A>&nbsp;e)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通过将发生在此容器上的容器事件指派给所有已注册的 ContainerListener 对象来处理这些事件。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/awt/Container.html#processEvent(java.awt.AWTEvent)">processEvent</A></B>(<A HREF="../../java/awt/AWTEvent.html" title="java.awt 中的类">AWTEvent</A>&nbsp;e)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;处理关于此容器的事件。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/awt/Container.html#remove(java.awt.Component)">remove</A></B>(<A HREF="../../java/awt/Component.html" title="java.awt 中的类">Component</A>&nbsp;comp)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;从此容器中移除指定组件。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/awt/Container.html#remove(int)">remove</A></B>(int&nbsp;index)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;从此容器中移除 <code>index</code> 指定的组件。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/awt/Container.html#removeAll()">removeAll</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;从此容器中移除所有组件。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/awt/Container.html#removeContainerListener(java.awt.event.ContainerListener)">removeContainerListener</A></B>(<A HREF="../../java/awt/event/ContainerListener.html" title="java.awt.event 中的接口">ContainerListener</A>&nbsp;l)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;移除指定容器的侦听器，从而不再接收来自此容器的容器事件。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/awt/Container.html#removeNotify()">removeNotify</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通过移除此 Container 到其本机屏幕资源的连接，使其不可显示。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/awt/Container.html#setComponentZOrder(java.awt.Component, int)">setComponentZOrder</A></B>(<A HREF="../../java/awt/Component.html" title="java.awt 中的类">Component</A>&nbsp;comp,
                   int&nbsp;index)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;将指定组件移动到容器中指定的 z 顺序索引。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/awt/Container.html#setFocusCycleRoot(boolean)">setFocusCycleRoot</A></B>(boolean&nbsp;focusCycleRoot)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;设置此 Container 是否是某个焦点遍历循环的根。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/awt/Container.html#setFocusTraversalKeys(int, java.util.Set)">setFocusTraversalKeys</A></B>(int&nbsp;id,
                      <A HREF="../../java/util/Set.html" title="java.util 中的接口">Set</A>&lt;? extends <A HREF="../../java/awt/AWTKeyStroke.html" title="java.awt 中的类">AWTKeyStroke</A>&gt;&nbsp;keystrokes)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;为此 Container 的给定遍历操作设置焦点遍历键。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/awt/Container.html#setFocusTraversalPolicy(java.awt.FocusTraversalPolicy)">setFocusTraversalPolicy</A></B>(<A HREF="../../java/awt/FocusTraversalPolicy.html" title="java.awt 中的类">FocusTraversalPolicy</A>&nbsp;policy)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果此 Container 是一个焦点循环根，则设置将管理此 Container 的子代的键盘遍历的焦点遍历策略。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/awt/Container.html#setFocusTraversalPolicyProvider(boolean)">setFocusTraversalPolicyProvider</A></B>(boolean&nbsp;provider)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;设置是否将用此容器提供焦点遍历策略。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/awt/Container.html#setFont(java.awt.Font)">setFont</A></B>(<A HREF="../../java/awt/Font.html" title="java.awt 中的类">Font</A>&nbsp;f)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;设置此容器的字体。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/awt/Container.html#setLayout(java.awt.LayoutManager)">setLayout</A></B>(<A HREF="../../java/awt/LayoutManager.html" title="java.awt 中的接口">LayoutManager</A>&nbsp;mgr)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;设置此容器的布局管理器。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/awt/Container.html#transferFocusBackward()">transferFocusBackward</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;将焦点转移到前一个组件，就好像此 Component 曾是焦点所有者。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/awt/Container.html#transferFocusDownCycle()">transferFocusDownCycle</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;将焦点向下传输一个焦点遍历循环。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/awt/Container.html#update(java.awt.Graphics)">update</A></B>(<A HREF="../../java/awt/Graphics.html" title="java.awt 中的类">Graphics</A>&nbsp;g)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;更新容器。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/awt/Container.html#validate()">validate</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;验证此容器及其所有子组件。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/awt/Container.html#validateTree()">validateTree</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;递归继承容器树，对于所有被标记为需要重新计算布局的子树（标记为无效的那些子树）重新计算布局。</TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_java.awt.Component"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>从类 java.awt.<A HREF="../../java/awt/Component.html" title="java.awt 中的类">Component</A> 继承的方法</B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><A HREF="../../java/awt/Component.html#action(java.awt.Event, java.lang.Object)">action</A>, <A HREF="../../java/awt/Component.html#add(java.awt.PopupMenu)">add</A>, <A HREF="../../java/awt/Component.html#addComponentListener(java.awt.event.ComponentListener)">addComponentListener</A>, <A HREF="../../java/awt/Component.html#addFocusListener(java.awt.event.FocusListener)">addFocusListener</A>, <A HREF="../../java/awt/Component.html#addHierarchyBoundsListener(java.awt.event.HierarchyBoundsListener)">addHierarchyBoundsListener</A>, <A HREF="../../java/awt/Component.html#addHierarchyListener(java.awt.event.HierarchyListener)">addHierarchyListener</A>, <A HREF="../../java/awt/Component.html#addInputMethodListener(java.awt.event.InputMethodListener)">addInputMethodListener</A>, <A HREF="../../java/awt/Component.html#addKeyListener(java.awt.event.KeyListener)">addKeyListener</A>, <A HREF="../../java/awt/Component.html#addMouseListener(java.awt.event.MouseListener)">addMouseListener</A>, <A HREF="../../java/awt/Component.html#addMouseMotionListener(java.awt.event.MouseMotionListener)">addMouseMotionListener</A>, <A HREF="../../java/awt/Component.html#addMouseWheelListener(java.awt.event.MouseWheelListener)">addMouseWheelListener</A>, <A HREF="../../java/awt/Component.html#bounds()">bounds</A>, <A HREF="../../java/awt/Component.html#checkImage(java.awt.Image, java.awt.image.ImageObserver)">checkImage</A>, <A HREF="../../java/awt/Component.html#checkImage(java.awt.Image, int, int, java.awt.image.ImageObserver)">checkImage</A>, <A HREF="../../java/awt/Component.html#coalesceEvents(java.awt.AWTEvent, java.awt.AWTEvent)">coalesceEvents</A>, <A HREF="../../java/awt/Component.html#contains(int, int)">contains</A>, <A HREF="../../java/awt/Component.html#contains(java.awt.Point)">contains</A>, <A HREF="../../java/awt/Component.html#createImage(java.awt.image.ImageProducer)">createImage</A>, <A HREF="../../java/awt/Component.html#createImage(int, int)">createImage</A>, <A HREF="../../java/awt/Component.html#createVolatileImage(int, int)">createVolatileImage</A>, <A HREF="../../java/awt/Component.html#createVolatileImage(int, int, java.awt.ImageCapabilities)">createVolatileImage</A>, <A HREF="../../java/awt/Component.html#disable()">disable</A>, <A HREF="../../java/awt/Component.html#disableEvents(long)">disableEvents</A>, <A HREF="../../java/awt/Component.html#dispatchEvent(java.awt.AWTEvent)">dispatchEvent</A>, <A HREF="../../java/awt/Component.html#enable()">enable</A>, <A HREF="../../java/awt/Component.html#enable(boolean)">enable</A>, <A HREF="../../java/awt/Component.html#enableEvents(long)">enableEvents</A>, <A HREF="../../java/awt/Component.html#enableInputMethods(boolean)">enableInputMethods</A>, <A HREF="../../java/awt/Component.html#firePropertyChange(java.lang.String, boolean, boolean)">firePropertyChange</A>, <A HREF="../../java/awt/Component.html#firePropertyChange(java.lang.String, byte, byte)">firePropertyChange</A>, <A HREF="../../java/awt/Component.html#firePropertyChange(java.lang.String, char, char)">firePropertyChange</A>, <A HREF="../../java/awt/Component.html#firePropertyChange(java.lang.String, double, double)">firePropertyChange</A>, <A HREF="../../java/awt/Component.html#firePropertyChange(java.lang.String, float, float)">firePropertyChange</A>, <A HREF="../../java/awt/Component.html#firePropertyChange(java.lang.String, int, int)">firePropertyChange</A>, <A HREF="../../java/awt/Component.html#firePropertyChange(java.lang.String, long, long)">firePropertyChange</A>, <A HREF="../../java/awt/Component.html#firePropertyChange(java.lang.String, java.lang.Object, java.lang.Object)">firePropertyChange</A>, <A HREF="../../java/awt/Component.html#firePropertyChange(java.lang.String, short, short)">firePropertyChange</A>, <A HREF="../../java/awt/Component.html#getAccessibleContext()">getAccessibleContext</A>, <A HREF="../../java/awt/Component.html#getBackground()">getBackground</A>, <A HREF="../../java/awt/Component.html#getBaseline(int, int)">getBaseline</A>, <A HREF="../../java/awt/Component.html#getBaselineResizeBehavior()">getBaselineResizeBehavior</A>, <A HREF="../../java/awt/Component.html#getBounds()">getBounds</A>, <A HREF="../../java/awt/Component.html#getBounds(java.awt.Rectangle)">getBounds</A>, <A HREF="../../java/awt/Component.html#getColorModel()">getColorModel</A>, <A HREF="../../java/awt/Component.html#getComponentListeners()">getComponentListeners</A>, <A HREF="../../java/awt/Component.html#getComponentOrientation()">getComponentOrientation</A>, <A HREF="../../java/awt/Component.html#getCursor()">getCursor</A>, <A HREF="../../java/awt/Component.html#getDropTarget()">getDropTarget</A>, <A HREF="../../java/awt/Component.html#getFocusCycleRootAncestor()">getFocusCycleRootAncestor</A>, <A HREF="../../java/awt/Component.html#getFocusListeners()">getFocusListeners</A>, <A HREF="../../java/awt/Component.html#getFocusTraversalKeysEnabled()">getFocusTraversalKeysEnabled</A>, <A HREF="../../java/awt/Component.html#getFont()">getFont</A>, <A HREF="../../java/awt/Component.html#getFontMetrics(java.awt.Font)">getFontMetrics</A>, <A HREF="../../java/awt/Component.html#getForeground()">getForeground</A>, <A HREF="../../java/awt/Component.html#getGraphics()">getGraphics</A>, <A HREF="../../java/awt/Component.html#getGraphicsConfiguration()">getGraphicsConfiguration</A>, <A HREF="../../java/awt/Component.html#getHeight()">getHeight</A>, <A HREF="../../java/awt/Component.html#getHierarchyBoundsListeners()">getHierarchyBoundsListeners</A>, <A HREF="../../java/awt/Component.html#getHierarchyListeners()">getHierarchyListeners</A>, <A HREF="../../java/awt/Component.html#getIgnoreRepaint()">getIgnoreRepaint</A>, <A HREF="../../java/awt/Component.html#getInputContext()">getInputContext</A>, <A HREF="../../java/awt/Component.html#getInputMethodListeners()">getInputMethodListeners</A>, <A HREF="../../java/awt/Component.html#getInputMethodRequests()">getInputMethodRequests</A>, <A HREF="../../java/awt/Component.html#getKeyListeners()">getKeyListeners</A>, <A HREF="../../java/awt/Component.html#getLocale()">getLocale</A>, <A HREF="../../java/awt/Component.html#getLocation()">getLocation</A>, <A HREF="../../java/awt/Component.html#getLocation(java.awt.Point)">getLocation</A>, <A HREF="../../java/awt/Component.html#getLocationOnScreen()">getLocationOnScreen</A>, <A HREF="../../java/awt/Component.html#getMouseListeners()">getMouseListeners</A>, <A HREF="../../java/awt/Component.html#getMouseMotionListeners()">getMouseMotionListeners</A>, <A HREF="../../java/awt/Component.html#getMousePosition()">getMousePosition</A>, <A HREF="../../java/awt/Component.html#getMouseWheelListeners()">getMouseWheelListeners</A>, <A HREF="../../java/awt/Component.html#getName()">getName</A>, <A HREF="../../java/awt/Component.html#getParent()">getParent</A>, <A HREF="../../java/awt/Component.html#getPeer()">getPeer</A>, <A HREF="../../java/awt/Component.html#getPropertyChangeListeners()">getPropertyChangeListeners</A>, <A HREF="../../java/awt/Component.html#getPropertyChangeListeners(java.lang.String)">getPropertyChangeListeners</A>, <A HREF="../../java/awt/Component.html#getSize()">getSize</A>, <A HREF="../../java/awt/Component.html#getSize(java.awt.Dimension)">getSize</A>, <A HREF="../../java/awt/Component.html#getToolkit()">getToolkit</A>, <A HREF="../../java/awt/Component.html#getTreeLock()">getTreeLock</A>, <A HREF="../../java/awt/Component.html#getWidth()">getWidth</A>, <A HREF="../../java/awt/Component.html#getX()">getX</A>, <A HREF="../../java/awt/Component.html#getY()">getY</A>, <A HREF="../../java/awt/Component.html#gotFocus(java.awt.Event, java.lang.Object)">gotFocus</A>, <A HREF="../../java/awt/Component.html#handleEvent(java.awt.Event)">handleEvent</A>, <A HREF="../../java/awt/Component.html#hasFocus()">hasFocus</A>, <A HREF="../../java/awt/Component.html#hide()">hide</A>, <A HREF="../../java/awt/Component.html#imageUpdate(java.awt.Image, int, int, int, int, int)">imageUpdate</A>, <A HREF="../../java/awt/Component.html#inside(int, int)">inside</A>, <A HREF="../../java/awt/Component.html#isBackgroundSet()">isBackgroundSet</A>, <A HREF="../../java/awt/Component.html#isCursorSet()">isCursorSet</A>, <A HREF="../../java/awt/Component.html#isDisplayable()">isDisplayable</A>, <A HREF="../../java/awt/Component.html#isDoubleBuffered()">isDoubleBuffered</A>, <A HREF="../../java/awt/Component.html#isEnabled()">isEnabled</A>, <A HREF="../../java/awt/Component.html#isFocusable()">isFocusable</A>, <A HREF="../../java/awt/Component.html#isFocusOwner()">isFocusOwner</A>, <A HREF="../../java/awt/Component.html#isFocusTraversable()">isFocusTraversable</A>, <A HREF="../../java/awt/Component.html#isFontSet()">isFontSet</A>, <A HREF="../../java/awt/Component.html#isForegroundSet()">isForegroundSet</A>, <A HREF="../../java/awt/Component.html#isLightweight()">isLightweight</A>, <A HREF="../../java/awt/Component.html#isMaximumSizeSet()">isMaximumSizeSet</A>, <A HREF="../../java/awt/Component.html#isMinimumSizeSet()">isMinimumSizeSet</A>, <A HREF="../../java/awt/Component.html#isOpaque()">isOpaque</A>, <A HREF="../../java/awt/Component.html#isPreferredSizeSet()">isPreferredSizeSet</A>, <A HREF="../../java/awt/Component.html#isShowing()">isShowing</A>, <A HREF="../../java/awt/Component.html#isValid()">isValid</A>, <A HREF="../../java/awt/Component.html#isVisible()">isVisible</A>, <A HREF="../../java/awt/Component.html#keyDown(java.awt.Event, int)">keyDown</A>, <A HREF="../../java/awt/Component.html#keyUp(java.awt.Event, int)">keyUp</A>, <A HREF="../../java/awt/Component.html#list()">list</A>, <A HREF="../../java/awt/Component.html#list(java.io.PrintStream)">list</A>, <A HREF="../../java/awt/Component.html#list(java.io.PrintWriter)">list</A>, <A HREF="../../java/awt/Component.html#location()">location</A>, <A HREF="../../java/awt/Component.html#lostFocus(java.awt.Event, java.lang.Object)">lostFocus</A>, <A HREF="../../java/awt/Component.html#mouseDown(java.awt.Event, int, int)">mouseDown</A>, <A HREF="../../java/awt/Component.html#mouseDrag(java.awt.Event, int, int)">mouseDrag</A>, <A HREF="../../java/awt/Component.html#mouseEnter(java.awt.Event, int, int)">mouseEnter</A>, <A HREF="../../java/awt/Component.html#mouseExit(java.awt.Event, int, int)">mouseExit</A>, <A HREF="../../java/awt/Component.html#mouseMove(java.awt.Event, int, int)">mouseMove</A>, <A HREF="../../java/awt/Component.html#mouseUp(java.awt.Event, int, int)">mouseUp</A>, <A HREF="../../java/awt/Component.html#move(int, int)">move</A>, <A HREF="../../java/awt/Component.html#nextFocus()">nextFocus</A>, <A HREF="../../java/awt/Component.html#paintAll(java.awt.Graphics)">paintAll</A>, <A HREF="../../java/awt/Component.html#postEvent(java.awt.Event)">postEvent</A>, <A HREF="../../java/awt/Component.html#prepareImage(java.awt.Image, java.awt.image.ImageObserver)">prepareImage</A>, <A HREF="../../java/awt/Component.html#prepareImage(java.awt.Image, int, int, java.awt.image.ImageObserver)">prepareImage</A>, <A HREF="../../java/awt/Component.html#printAll(java.awt.Graphics)">printAll</A>, <A HREF="../../java/awt/Component.html#processComponentEvent(java.awt.event.ComponentEvent)">processComponentEvent</A>, <A HREF="../../java/awt/Component.html#processFocusEvent(java.awt.event.FocusEvent)">processFocusEvent</A>, <A HREF="../../java/awt/Component.html#processHierarchyBoundsEvent(java.awt.event.HierarchyEvent)">processHierarchyBoundsEvent</A>, <A HREF="../../java/awt/Component.html#processHierarchyEvent(java.awt.event.HierarchyEvent)">processHierarchyEvent</A>, <A HREF="../../java/awt/Component.html#processInputMethodEvent(java.awt.event.InputMethodEvent)">processInputMethodEvent</A>, <A HREF="../../java/awt/Component.html#processKeyEvent(java.awt.event.KeyEvent)">processKeyEvent</A>, <A HREF="../../java/awt/Component.html#processMouseEvent(java.awt.event.MouseEvent)">processMouseEvent</A>, <A HREF="../../java/awt/Component.html#processMouseMotionEvent(java.awt.event.MouseEvent)">processMouseMotionEvent</A>, <A HREF="../../java/awt/Component.html#processMouseWheelEvent(java.awt.event.MouseWheelEvent)">processMouseWheelEvent</A>, <A HREF="../../java/awt/Component.html#remove(java.awt.MenuComponent)">remove</A>, <A HREF="../../java/awt/Component.html#removeComponentListener(java.awt.event.ComponentListener)">removeComponentListener</A>, <A HREF="../../java/awt/Component.html#removeFocusListener(java.awt.event.FocusListener)">removeFocusListener</A>, <A HREF="../../java/awt/Component.html#removeHierarchyBoundsListener(java.awt.event.HierarchyBoundsListener)">removeHierarchyBoundsListener</A>, <A HREF="../../java/awt/Component.html#removeHierarchyListener(java.awt.event.HierarchyListener)">removeHierarchyListener</A>, <A HREF="../../java/awt/Component.html#removeInputMethodListener(java.awt.event.InputMethodListener)">removeInputMethodListener</A>, <A HREF="../../java/awt/Component.html#removeKeyListener(java.awt.event.KeyListener)">removeKeyListener</A>, <A HREF="../../java/awt/Component.html#removeMouseListener(java.awt.event.MouseListener)">removeMouseListener</A>, <A HREF="../../java/awt/Component.html#removeMouseMotionListener(java.awt.event.MouseMotionListener)">removeMouseMotionListener</A>, <A HREF="../../java/awt/Component.html#removeMouseWheelListener(java.awt.event.MouseWheelListener)">removeMouseWheelListener</A>, <A HREF="../../java/awt/Component.html#removePropertyChangeListener(java.beans.PropertyChangeListener)">removePropertyChangeListener</A>, <A HREF="../../java/awt/Component.html#removePropertyChangeListener(java.lang.String, java.beans.PropertyChangeListener)">removePropertyChangeListener</A>, <A HREF="../../java/awt/Component.html#repaint()">repaint</A>, <A HREF="../../java/awt/Component.html#repaint(int, int, int, int)">repaint</A>, <A HREF="../../java/awt/Component.html#repaint(long)">repaint</A>, <A HREF="../../java/awt/Component.html#repaint(long, int, int, int, int)">repaint</A>, <A HREF="../../java/awt/Component.html#requestFocus()">requestFocus</A>, <A HREF="../../java/awt/Component.html#requestFocus(boolean)">requestFocus</A>, <A HREF="../../java/awt/Component.html#requestFocusInWindow()">requestFocusInWindow</A>, <A HREF="../../java/awt/Component.html#requestFocusInWindow(boolean)">requestFocusInWindow</A>, <A HREF="../../java/awt/Component.html#reshape(int, int, int, int)">reshape</A>, <A HREF="../../java/awt/Component.html#resize(java.awt.Dimension)">resize</A>, <A HREF="../../java/awt/Component.html#resize(int, int)">resize</A>, <A HREF="../../java/awt/Component.html#setBackground(java.awt.Color)">setBackground</A>, <A HREF="../../java/awt/Component.html#setBounds(int, int, int, int)">setBounds</A>, <A HREF="../../java/awt/Component.html#setBounds(java.awt.Rectangle)">setBounds</A>, <A HREF="../../java/awt/Component.html#setComponentOrientation(java.awt.ComponentOrientation)">setComponentOrientation</A>, <A HREF="../../java/awt/Component.html#setCursor(java.awt.Cursor)">setCursor</A>, <A HREF="../../java/awt/Component.html#setDropTarget(java.awt.dnd.DropTarget)">setDropTarget</A>, <A HREF="../../java/awt/Component.html#setEnabled(boolean)">setEnabled</A>, <A HREF="../../java/awt/Component.html#setFocusable(boolean)">setFocusable</A>, <A HREF="../../java/awt/Component.html#setFocusTraversalKeysEnabled(boolean)">setFocusTraversalKeysEnabled</A>, <A HREF="../../java/awt/Component.html#setForeground(java.awt.Color)">setForeground</A>, <A HREF="../../java/awt/Component.html#setIgnoreRepaint(boolean)">setIgnoreRepaint</A>, <A HREF="../../java/awt/Component.html#setLocale(java.util.Locale)">setLocale</A>, <A HREF="../../java/awt/Component.html#setLocation(int, int)">setLocation</A>, <A HREF="../../java/awt/Component.html#setLocation(java.awt.Point)">setLocation</A>, <A HREF="../../java/awt/Component.html#setMaximumSize(java.awt.Dimension)">setMaximumSize</A>, <A HREF="../../java/awt/Component.html#setMinimumSize(java.awt.Dimension)">setMinimumSize</A>, <A HREF="../../java/awt/Component.html#setName(java.lang.String)">setName</A>, <A HREF="../../java/awt/Component.html#setPreferredSize(java.awt.Dimension)">setPreferredSize</A>, <A HREF="../../java/awt/Component.html#setSize(java.awt.Dimension)">setSize</A>, <A HREF="../../java/awt/Component.html#setSize(int, int)">setSize</A>, <A HREF="../../java/awt/Component.html#setVisible(boolean)">setVisible</A>, <A HREF="../../java/awt/Component.html#show()">show</A>, <A HREF="../../java/awt/Component.html#show(boolean)">show</A>, <A HREF="../../java/awt/Component.html#size()">size</A>, <A HREF="../../java/awt/Component.html#toString()">toString</A>, <A HREF="../../java/awt/Component.html#transferFocus()">transferFocus</A>, <A HREF="../../java/awt/Component.html#transferFocusUpCycle()">transferFocusUpCycle</A></CODE></TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_java.lang.Object"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>从类 java.lang.<A HREF="../../java/lang/Object.html" title="java.lang 中的类">Object</A> 继承的方法</B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><A HREF="../../java/lang/Object.html#clone()">clone</A>, <A HREF="../../java/lang/Object.html#equals(java.lang.Object)">equals</A>, <A HREF="../../java/lang/Object.html#finalize()">finalize</A>, <A HREF="../../java/lang/Object.html#getClass()">getClass</A>, <A HREF="../../java/lang/Object.html#hashCode()">hashCode</A>, <A HREF="../../java/lang/Object.html#notify()">notify</A>, <A HREF="../../java/lang/Object.html#notifyAll()">notifyAll</A>, <A HREF="../../java/lang/Object.html#wait()">wait</A>, <A HREF="../../java/lang/Object.html#wait(long)">wait</A>, <A HREF="../../java/lang/Object.html#wait(long, int)">wait</A></CODE></TD>
</TR>
</TABLE>
&nbsp;
<P>

<!-- ========= CONSTRUCTOR DETAIL ======== -->

<A NAME="constructor_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>构造方法详细信息</B></FONT></TH>
</TR>
</TABLE>

<A NAME="Container()"><!-- --></A><H3>
Container</H3>
<PRE>
public <B>Container</B>()</PRE>
<DL>
<DD>构造一个新的 Container。可以直接扩展 Container，但在这种情况下是轻量级的，并且它必须被位于本机组件树中更高处的某一个父容器包含。（比如说 Frame）。
<P>
</DL>

<!-- ============ METHOD DETAIL ========== -->

<A NAME="method_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>方法详细信息</B></FONT></TH>
</TR>
</TABLE>

<A NAME="getComponentCount()"><!-- --></A><H3>
getComponentCount</H3>
<PRE>
public int <B>getComponentCount</B>()</PRE>
<DL>
<DD>获取此面板中的组件数。
<P>
<DD><DL>

<DT><B>返回：</B><DD>此面板中的组件数。<DT><B>从以下版本开始：</B></DT>
  <DD>JDK1.1</DD>
<DT><B>另请参见：</B><DD><A HREF="../../java/awt/Container.html#getComponent(int)"><CODE>getComponent(int)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="countComponents()"><!-- --></A><H3>
countComponents</H3>
<PRE>
<FONT SIZE="-1"><A HREF="../../java/lang/Deprecated.html" title="java.lang 中的注释">@Deprecated</A>
</FONT>public int <B>countComponents</B>()</PRE>
<DL>
<DD><B>已过时。</B>&nbsp;<I>从 JDK version 1.1 开始，用 etComponentCount() 取代。</I>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="getComponent(int)"><!-- --></A><H3>
getComponent</H3>
<PRE>
public <A HREF="../../java/awt/Component.html" title="java.awt 中的类">Component</A> <B>getComponent</B>(int&nbsp;n)</PRE>
<DL>
<DD>获取此容器中的第 n 个组件。
<P>
<DD><DL>
<DT><B>参数：</B><DD><CODE>n</CODE> - 要获取的组件的索引。
<DT><B>返回：</B><DD>此容器中的 n<sup>th</sup> 组件。
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../java/lang/ArrayIndexOutOfBoundsException.html" title="java.lang 中的类">ArrayIndexOutOfBoundsException</A></CODE> - 如果 n<sup>th</sup> 值不存在。</DL>
</DD>
</DL>
<HR>

<A NAME="getComponents()"><!-- --></A><H3>
getComponents</H3>
<PRE>
public <A HREF="../../java/awt/Component.html" title="java.awt 中的类">Component</A>[] <B>getComponents</B>()</PRE>
<DL>
<DD>获取此容器中的所有组件。
<P>
<DD><DL>

<DT><B>返回：</B><DD>此容器中的所有组件的数组。</DL>
</DD>
</DL>
<HR>

<A NAME="getInsets()"><!-- --></A><H3>
getInsets</H3>
<PRE>
public <A HREF="../../java/awt/Insets.html" title="java.awt 中的类">Insets</A> <B>getInsets</B>()</PRE>
<DL>
<DD>确定此容器的 insets，它指示容器边框的大小。 
 <p>
例如，<code>Frame</code> 对象有一个顶端 inset，它对应于窗体的标题栏的高度。
<P>
<DD><DL>

<DT><B>返回：</B><DD>此容器的 inset。<DT><B>从以下版本开始：</B></DT>
  <DD>JDK1.1</DD>
<DT><B>另请参见：</B><DD><A HREF="../../java/awt/Insets.html" title="java.awt 中的类"><CODE>Insets</CODE></A>, 
<A HREF="../../java/awt/LayoutManager.html" title="java.awt 中的接口"><CODE>LayoutManager</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="insets()"><!-- --></A><H3>
insets</H3>
<PRE>
<FONT SIZE="-1"><A HREF="../../java/lang/Deprecated.html" title="java.lang 中的注释">@Deprecated</A>
</FONT>public <A HREF="../../java/awt/Insets.html" title="java.awt 中的类">Insets</A> <B>insets</B>()</PRE>
<DL>
<DD><B>已过时。</B>&nbsp;<I>从 JDK version 1.1 开始，用 <code>getInsets()</code> 取代。</I>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="add(java.awt.Component)"><!-- --></A><H3>
add</H3>
<PRE>
public <A HREF="../../java/awt/Component.html" title="java.awt 中的类">Component</A> <B>add</B>(<A HREF="../../java/awt/Component.html" title="java.awt 中的类">Component</A>&nbsp;comp)</PRE>
<DL>
<DD>将指定组件追加到此容器的尾部。这是一个适用于 <A HREF="../../java/awt/Container.html#addImpl(java.awt.Component, java.lang.Object, int)"><CODE>addImpl(java.awt.Component, java.lang.Object, int)</CODE></A> 的便捷方法。
 <p>
注：如果已经将某个组件添加到显示的容器中，则必须在此容器上调用 <code>validate</code>，以显示新的组件。如果添加多个组件，那么可以在添加所有组件之后，通过只调用一次 <code>validate</code> 来提高效率。
<P>
<DD><DL>
<DT><B>参数：</B><DD><CODE>comp</CODE> - 要添加的组件
<DT><B>返回：</B><DD>component 参数
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../java/lang/NullPointerException.html" title="java.lang 中的类">NullPointerException</A></CODE> - 如果 <code>comp</code> 为 <code>null</code><DT><B>另请参见：</B><DD><A HREF="../../java/awt/Container.html#addImpl(java.awt.Component, java.lang.Object, int)"><CODE>addImpl(java.awt.Component, java.lang.Object, int)</CODE></A>, 
<A HREF="../../java/awt/Container.html#validate()"><CODE>validate()</CODE></A>, 
<A HREF="../../javax/swing/JComponent.html#revalidate()"><CODE>JComponent.revalidate()</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="add(java.lang.String, java.awt.Component)"><!-- --></A><H3>
add</H3>
<PRE>
public <A HREF="../../java/awt/Component.html" title="java.awt 中的类">Component</A> <B>add</B>(<A HREF="../../java/lang/String.html" title="java.lang 中的类">String</A>&nbsp;name,
                     <A HREF="../../java/awt/Component.html" title="java.awt 中的类">Component</A>&nbsp;comp)</PRE>
<DL>
<DD>将指定组件添加到此容器中。这是一个适用于 <A HREF="../../java/awt/Container.html#addImpl(java.awt.Component, java.lang.Object, int)"><CODE>addImpl(java.awt.Component, java.lang.Object, int)</CODE></A> 的便捷方法。
 <p>
从 JDK version 1.1 开始，此方法已过时。请使用 <code>add(Component, Object)</code> 方法代替。
<P>
<DD><DL>

<DT><B>抛出：</B>
<DD><CODE><A HREF="../../java/lang/NullPointerException.html" title="java.lang 中的类">NullPointerException</A></CODE> - 如果 <code>comp</code> 为 <code>null</code><DT><B>另请参见：</B><DD><A HREF="../../java/awt/Container.html#add(java.awt.Component, java.lang.Object)"><CODE>add(Component, Object)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="add(java.awt.Component, int)"><!-- --></A><H3>
add</H3>
<PRE>
public <A HREF="../../java/awt/Component.html" title="java.awt 中的类">Component</A> <B>add</B>(<A HREF="../../java/awt/Component.html" title="java.awt 中的类">Component</A>&nbsp;comp,
                     int&nbsp;index)</PRE>
<DL>
<DD>将指定组件添加到此容器的给定位置上。这是一个适用于 <A HREF="../../java/awt/Container.html#addImpl(java.awt.Component, java.lang.Object, int)"><CODE>addImpl(java.awt.Component, java.lang.Object, int)</CODE></A> 的便捷方法。
 <p>
注：如果已经将某个组件添加到显示的容器中，则必须在此容器上调用 <code>validate</code>，以显示新的组件。如果添加多个组件，那么可以在添加所有组件之后，通过只调用一次 <code>validate</code> 来提高效率。
<P>
<DD><DL>
<DT><B>参数：</B><DD><CODE>comp</CODE> - 要添加的组件<DD><CODE>index</CODE> - 插入组件的位置，<code>-1</code> 表示将组件追加到尾部
<DT><B>返回：</B><DD>组件 <code>comp</code>
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../java/lang/NullPointerException.html" title="java.lang 中的类">NullPointerException</A></CODE> - 如果 <code>comp</code> 为 <code>null</code>
<DD><CODE><A HREF="../../java/lang/IllegalArgumentException.html" title="java.lang 中的类">IllegalArgumentException</A></CODE> - 如果 <code>index</code> 无效（有关细节请参阅 <A HREF="../../java/awt/Container.html#addImpl(java.awt.Component, java.lang.Object, int)"><CODE>addImpl(java.awt.Component, java.lang.Object, int)</CODE></A>）<DT><B>另请参见：</B><DD><A HREF="../../java/awt/Container.html#addImpl(java.awt.Component, java.lang.Object, int)"><CODE>addImpl(java.awt.Component, java.lang.Object, int)</CODE></A>, 
<A HREF="../../java/awt/Container.html#remove(int)"><CODE>remove(int)</CODE></A>, 
<A HREF="../../java/awt/Container.html#validate()"><CODE>validate()</CODE></A>, 
<A HREF="../../javax/swing/JComponent.html#revalidate()"><CODE>JComponent.revalidate()</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="setComponentZOrder(java.awt.Component, int)"><!-- --></A><H3>
setComponentZOrder</H3>
<PRE>
public void <B>setComponentZOrder</B>(<A HREF="../../java/awt/Component.html" title="java.awt 中的类">Component</A>&nbsp;comp,
                               int&nbsp;index)</PRE>
<DL>
<DD>将指定组件移动到容器中指定的 z 顺序索引。z 顺序确定了绘制组件的顺序；具有最高 z 顺序的组件将第一个绘制，而具有最低 z 顺序的组件将最后一个绘制。在组件重叠的地方，具有较低 z 顺序的组件将覆盖具有较高 z 顺序的组件。
 <p>
如果组件是其他某个 container 的子组件，则在将它添加到此容器之前，从该容器中移除它。此方法与 <code>java.awt.Container.add(Component, int)</code> 之间的重要不同是，在将组件从其以前的容器中移除时，此方法不对该组件调用 <code>removeNotify</code>，除非有此必要，并且基础本机窗口系统允许这样做。因此，如果组件拥有键盘焦点，那么在移动到新的位置上时，它会维持该焦点。
 <p>
要保证此属性只应用于轻量级的非 <code>Container</code> 组件。
 <p>
<b>注</b>：并不是所有的平台都支持在不调用 <code>removeNotify</code> 的情况下，将重量级组件的 z 顺序从一个容器更改到另一个容器中。无法检测某个平台是否支持这一点，因此开发人员不应该作出任何假设。
<P>
<DD><DL>
<DT><B>参数：</B><DD><CODE>comp</CODE> - 要移动的组件<DD><CODE>index</CODE> - 在容器的列表中插入组件的位置，其中 <code>getComponentCount()</code> 指追加到尾部
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../java/lang/NullPointerException.html" title="java.lang 中的类">NullPointerException</A></CODE> - 如果 <code>comp</code> 为 <code>null</code>
<DD><CODE><A HREF="../../java/lang/IllegalArgumentException.html" title="java.lang 中的类">IllegalArgumentException</A></CODE> - 如果 <code>comp</code> 是该容器的父容器之一
<DD><CODE><A HREF="../../java/lang/IllegalArgumentException.html" title="java.lang 中的类">IllegalArgumentException</A></CODE> - 如果在容器间移动的 <code>index</code> 不在 <code>[0, getComponentCount()]</code> 范围内，或者在容器内移动的 <code>index</code> 不在 <code>[0, getComponentCount()-1]</code> 范围内
<DD><CODE><A HREF="../../java/lang/IllegalArgumentException.html" title="java.lang 中的类">IllegalArgumentException</A></CODE> - 如果将一个容器添加给其自身
<DD><CODE><A HREF="../../java/lang/IllegalArgumentException.html" title="java.lang 中的类">IllegalArgumentException</A></CODE> - 如果将 <code>Window</code> 添加到容器中<DT><B>从以下版本开始：</B></DT>
  <DD>1.5</DD>
<DT><B>另请参见：</B><DD><A HREF="../../java/awt/Container.html#getComponentZOrder(java.awt.Component)"><CODE>getComponentZOrder(java.awt.Component)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="getComponentZOrder(java.awt.Component)"><!-- --></A><H3>
getComponentZOrder</H3>
<PRE>
public int <B>getComponentZOrder</B>(<A HREF="../../java/awt/Component.html" title="java.awt 中的类">Component</A>&nbsp;comp)</PRE>
<DL>
<DD>返回容器内组件的 z 顺序索引。组件在 z 顺序层次结构中所处的位置越高，它的索引就越低。具有最低 z 顺序索引的组件最后一个被绘制，而它在层次结构中高于其他所有子组件。
<P>
<DD><DL>
<DT><B>参数：</B><DD><CODE>comp</CODE> - 正查询的组件
<DT><B>返回：</B><DD>组件的 z 顺序索引；如果 component 为 <code>null</code> 或者不属于该容器，则返回 -1<DT><B>从以下版本开始：</B></DT>
  <DD>1.5</DD>
<DT><B>另请参见：</B><DD><A HREF="../../java/awt/Container.html#setComponentZOrder(java.awt.Component, int)"><CODE>setComponentZOrder(java.awt.Component, int)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="add(java.awt.Component, java.lang.Object)"><!-- --></A><H3>
add</H3>
<PRE>
public void <B>add</B>(<A HREF="../../java/awt/Component.html" title="java.awt 中的类">Component</A>&nbsp;comp,
                <A HREF="../../java/lang/Object.html" title="java.lang 中的类">Object</A>&nbsp;constraints)</PRE>
<DL>
<DD>将指定的组件添加到此容器的尾部。同时通知布局管理器使用指定的 constraints 对象将组件添加到此容器的布局中。这是一个适用于 <A HREF="../../java/awt/Container.html#addImpl(java.awt.Component, java.lang.Object, int)"><CODE>addImpl(java.awt.Component, java.lang.Object, int)</CODE></A> 的便捷方法。
 <p>
注：如果已经将某个组件添加到显示的容器中，则必须在此容器上调用 <code>validate</code>，以显示新的组件。如果添加多个组件，那么可以在添加所有组件之后，通过只调用一次 <code>validate</code> 来提高效率。
<P>
<DD><DL>
<DT><B>参数：</B><DD><CODE>comp</CODE> - 要添加的组件<DD><CODE>constraints</CODE> - 表示此组件的布局约束的对象
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../java/lang/NullPointerException.html" title="java.lang 中的类">NullPointerException</A></CODE> - 如果 <code>comp</code> 为 <code>null</code><DT><B>从以下版本开始：</B></DT>
  <DD>JDK1.1</DD>
<DT><B>另请参见：</B><DD><A HREF="../../java/awt/Container.html#addImpl(java.awt.Component, java.lang.Object, int)"><CODE>addImpl(java.awt.Component, java.lang.Object, int)</CODE></A>, 
<A HREF="../../java/awt/Container.html#validate()"><CODE>validate()</CODE></A>, 
<A HREF="../../javax/swing/JComponent.html#revalidate()"><CODE>JComponent.revalidate()</CODE></A>, 
<A HREF="../../java/awt/LayoutManager.html" title="java.awt 中的接口"><CODE>LayoutManager</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="add(java.awt.Component, java.lang.Object, int)"><!-- --></A><H3>
add</H3>
<PRE>
public void <B>add</B>(<A HREF="../../java/awt/Component.html" title="java.awt 中的类">Component</A>&nbsp;comp,
                <A HREF="../../java/lang/Object.html" title="java.lang 中的类">Object</A>&nbsp;constraints,
                int&nbsp;index)</PRE>
<DL>
<DD>使用指定约束，将指定组件添加到此容器的指定索引所在的位置上。还要通知布局管理器，使用指定的约束对象将组件添加到此容器的布局中。这是一个适用于 <A HREF="../../java/awt/Container.html#addImpl(java.awt.Component, java.lang.Object, int)"><CODE>addImpl(java.awt.Component, java.lang.Object, int)</CODE></A> 的便捷方法。
 <p>
注：如果已经将某个组件添加到显示的容器中，则必须在此容器上调用 <code>validate</code>，以显示新的组件。如果添加多个组件，那么可以在添加所有组件之后，通过只调用一次 <code>validate</code> 来提高效率。
<P>
<DD><DL>
<DT><B>参数：</B><DD><CODE>comp</CODE> - 要添加的组件<DD><CODE>constraints</CODE> - 表示此组件的布局约束的对象<DD><CODE>index</CODE> - 容器列表中插入组件的位置；<code>-1</code> 表示将组件插入尾部
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../java/lang/NullPointerException.html" title="java.lang 中的类">NullPointerException</A></CODE> - 如果 <code>comp</code> 为 <code>null</code>
<DD><CODE><A HREF="../../java/lang/IllegalArgumentException.html" title="java.lang 中的类">IllegalArgumentException</A></CODE> - 如果 <code>index</code> 无效（有关细节请参阅 <A HREF="../../java/awt/Container.html#addImpl(java.awt.Component, java.lang.Object, int)"><CODE>addImpl(java.awt.Component, java.lang.Object, int)</CODE></A>）<DT><B>另请参见：</B><DD><A HREF="../../java/awt/Container.html#addImpl(java.awt.Component, java.lang.Object, int)"><CODE>addImpl(java.awt.Component, java.lang.Object, int)</CODE></A>, 
<A HREF="../../java/awt/Container.html#validate()"><CODE>validate()</CODE></A>, 
<A HREF="../../javax/swing/JComponent.html#revalidate()"><CODE>JComponent.revalidate()</CODE></A>, 
<A HREF="../../java/awt/Container.html#remove(int)"><CODE>remove(int)</CODE></A>, 
<A HREF="../../java/awt/LayoutManager.html" title="java.awt 中的接口"><CODE>LayoutManager</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="addImpl(java.awt.Component, java.lang.Object, int)"><!-- --></A><H3>
addImpl</H3>
<PRE>
protected void <B>addImpl</B>(<A HREF="../../java/awt/Component.html" title="java.awt 中的类">Component</A>&nbsp;comp,
                       <A HREF="../../java/lang/Object.html" title="java.lang 中的类">Object</A>&nbsp;constraints,
                       int&nbsp;index)</PRE>
<DL>
<DD>将指定组件添加到此容器的指定索引所在的位置上。此方法还通知布局管理器，通过 <code>addLayoutComponent</code> 方法，使用指定的约束对象将组件添加到此容器的布局中。
 <p>
这些约束是由正使用的特定布局管理器定义的。例如，<code>BorderLayout</code> 类定义了五个约束：<code>BorderLayout.NORTH</code>、<code>BorderLayout.SOUTH</code>、<code>BorderLayout.EAST</code>、<code>BorderLayout.WEST</code> 和 <code>BorderLayout.CENTER</code>。
 <p>
<code>GridBagLayout</code> 类需要一个 <code>GridBagConstraints</code> 对象。如果传递正确的约束对象类型时失败，则会导致 <code>IllegalArgumentException</code>。
 <p>
如果当前布局管理器实现了 <code>LayoutManager2</code>，则在其上调用 <A HREF="../../java/awt/LayoutManager2.html#addLayoutComponent(java.awt.Component, java.lang.Object)"><CODE>LayoutManager2.addLayoutComponent(Component,Object)</CODE></A>。如果当前布局管理器没有实现 <code>LayoutManager2</code>，并且约束是一个 <code>String</code>，则在其上调用 <A HREF="../../java/awt/LayoutManager.html#addLayoutComponent(java.lang.String, java.awt.Component)"><CODE>LayoutManager.addLayoutComponent(String,Component)</CODE></A>。
 <p>
 如果该组件不是此容器的祖先容器，并且有一个非 null 父组件，则在将该组件添加到此容器之前，从其当前父组件中移除它。
 <p>
在其他所有添加方法引用此方法时，如果某个程序需要追踪每个添加到容器的请求，那么这就是要重写的方法。被重写的方法通常应该包括一个对该方法的超类版本的调用：
 <p>
 <blockquote>
 <code>super.addImpl(comp, constraints, index)</code>
 </blockquote>
 <p>
<P>
<DD><DL>
<DT><B>参数：</B><DD><CODE>comp</CODE> - 要添加的组件<DD><CODE>constraints</CODE> - 表示此组件的布局约束的对象<DD><CODE>容器列表中插入组件的位置；其中</CODE> - <code>-1</code> 表示将组件追加到尾部
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../java/lang/IllegalArgumentException.html" title="java.lang 中的类">IllegalArgumentException</A></CODE> - 如果 <code>index</code> 无效；如果 <code>comp</code> 是此容器的子容器，则有效范围是 <code>[-1, getComponentCount()-1]</code>；如果组件不是此容器的子容器，则有效范围是 <code>[-1, getComponentCount()]</code>
<DD><CODE><A HREF="../../java/lang/IllegalArgumentException.html" title="java.lang 中的类">IllegalArgumentException</A></CODE> - 如果 <code>comp</code> 是此容器的祖先容器
<DD><CODE><A HREF="../../java/lang/IllegalArgumentException.html" title="java.lang 中的类">IllegalArgumentException</A></CODE> - 如果向容器添加一个窗口
<DD><CODE><A HREF="../../java/lang/NullPointerException.html" title="java.lang 中的类">NullPointerException</A></CODE> - 如果 <code>comp</code> 为 <code>null</code><DT><B>从以下版本开始：</B></DT>
  <DD>JDK1.1</DD>
<DT><B>另请参见：</B><DD><A HREF="../../java/awt/Container.html#add(java.awt.Component)"><CODE>add(Component)</CODE></A>, 
<A HREF="../../java/awt/Container.html#add(java.awt.Component, int)"><CODE>add(Component, int)</CODE></A>, 
<A HREF="../../java/awt/Container.html#add(java.awt.Component, java.lang.Object)"><CODE>add(Component, java.lang.Object)</CODE></A>, 
<A HREF="../../java/awt/LayoutManager.html" title="java.awt 中的接口"><CODE>LayoutManager</CODE></A>, 
<A HREF="../../java/awt/LayoutManager2.html" title="java.awt 中的接口"><CODE>LayoutManager2</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="remove(int)"><!-- --></A><H3>
remove</H3>
<PRE>
public void <B>remove</B>(int&nbsp;index)</PRE>
<DL>
<DD>从此容器中移除 <code>index</code> 指定的组件。此方法还通知布局管理器，通过 <code>removeLayoutComponent</code> 方法从此容器的布局中移除该组件。

<p>
注：如果已经从已显示的容器中移除一个组件，则必须在该容器上调用 <A HREF="../../java/awt/Container.html#validate()"><CODE>validate()</CODE></A> 来反映更改。如果移除多个组件，那么可以在移除所有组件之后，通过只调用一次 <A HREF="../../java/awt/Container.html#validate()"><CODE>validate()</CODE></A> 来提高效率。
<P>
<DD><DL>
<DT><B>参数：</B><DD><CODE>index</CODE> - 要移除的组件的索引
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../java/lang/ArrayIndexOutOfBoundsException.html" title="java.lang 中的类">ArrayIndexOutOfBoundsException</A></CODE> - 如果 <code>index</code> 不在范围 <code>[0, getComponentCount()-1]</code> 内<DT><B>从以下版本开始：</B></DT>
  <DD>JDK1.1</DD>
<DT><B>另请参见：</B><DD><A HREF="../../java/awt/Container.html#add(java.awt.Component)"><CODE>add(java.awt.Component)</CODE></A>, 
<A HREF="../../java/awt/Container.html#validate()"><CODE>validate()</CODE></A>, 
<A HREF="../../java/awt/Container.html#getComponentCount()"><CODE>getComponentCount()</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="remove(java.awt.Component)"><!-- --></A><H3>
remove</H3>
<PRE>
public void <B>remove</B>(<A HREF="../../java/awt/Component.html" title="java.awt 中的类">Component</A>&nbsp;comp)</PRE>
<DL>
<DD>从此容器中移除指定组件。此方法还通知布局管理器，通过 <code>removeLayoutComponent</code> 方法从此容器的布局中移除该组件。

<p>
 注：如果已经从已显示的容器中移除一个组件，则必须在该容器上调用 <A HREF="../../java/awt/Container.html#validate()"><CODE>validate()</CODE></A> 来反映更改。如果移除多个组件，那么可以在移除所有组件之后，通过只调用一次 <A HREF="../../java/awt/Container.html#validate()"><CODE>validate()</CODE></A> 来提高效率。
<P>
<DD><DL>
<DT><B>参数：</B><DD><CODE>comp</CODE> - 要移除的组件<DT><B>另请参见：</B><DD><A HREF="../../java/awt/Container.html#add(java.awt.Component)"><CODE>add(java.awt.Component)</CODE></A>, 
<A HREF="../../java/awt/Container.html#validate()"><CODE>validate()</CODE></A>, 
<A HREF="../../java/awt/Container.html#remove(int)"><CODE>remove(int)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="removeAll()"><!-- --></A><H3>
removeAll</H3>
<PRE>
public void <B>removeAll</B>()</PRE>
<DL>
<DD>从此容器中移除所有组件。此方法还通知布局管理器，通过 <code>removeLayoutComponent</code> 方法从此容器的布局中移除这些组件。
<P>
<DD><DL>
<DT><B>另请参见：</B><DD><A HREF="../../java/awt/Container.html#add(java.awt.Component)"><CODE>add(java.awt.Component)</CODE></A>, 
<A HREF="../../java/awt/Container.html#remove(int)"><CODE>remove(int)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="getLayout()"><!-- --></A><H3>
getLayout</H3>
<PRE>
public <A HREF="../../java/awt/LayoutManager.html" title="java.awt 中的接口">LayoutManager</A> <B>getLayout</B>()</PRE>
<DL>
<DD>获取此容器的布局管理器。
<P>
<DD><DL>
<DT><B>另请参见：</B><DD><A HREF="../../java/awt/Container.html#doLayout()"><CODE>doLayout()</CODE></A>, 
<A HREF="../../java/awt/Container.html#setLayout(java.awt.LayoutManager)"><CODE>setLayout(java.awt.LayoutManager)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="setLayout(java.awt.LayoutManager)"><!-- --></A><H3>
setLayout</H3>
<PRE>
public void <B>setLayout</B>(<A HREF="../../java/awt/LayoutManager.html" title="java.awt 中的接口">LayoutManager</A>&nbsp;mgr)</PRE>
<DL>
<DD>设置此容器的布局管理器。
<P>
<DD><DL>
<DT><B>参数：</B><DD><CODE>mgr</CODE> - 指定的布局管理器<DT><B>另请参见：</B><DD><A HREF="../../java/awt/Container.html#doLayout()"><CODE>doLayout()</CODE></A>, 
<A HREF="../../java/awt/Container.html#getLayout()"><CODE>getLayout()</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="doLayout()"><!-- --></A><H3>
doLayout</H3>
<PRE>
public void <B>doLayout</B>()</PRE>
<DL>
<DD>使此容器布置其组件。大部分程序不应该直接调用此方法，而是应该调用 <code>validate</code> 方法。
<P>
<DD><DL>
<DT><B>覆盖：</B><DD>类 <CODE><A HREF="../../java/awt/Component.html" title="java.awt 中的类">Component</A></CODE> 中的 <CODE><A HREF="../../java/awt/Component.html#doLayout()">doLayout</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>从以下版本开始：</B></DT>
  <DD>JDK1.1</DD>
<DT><B>另请参见：</B><DD><A HREF="../../java/awt/LayoutManager.html#layoutContainer(java.awt.Container)"><CODE>LayoutManager.layoutContainer(java.awt.Container)</CODE></A>, 
<A HREF="../../java/awt/Container.html#setLayout(java.awt.LayoutManager)"><CODE>setLayout(java.awt.LayoutManager)</CODE></A>, 
<A HREF="../../java/awt/Container.html#validate()"><CODE>validate()</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="layout()"><!-- --></A><H3>
layout</H3>
<PRE>
<FONT SIZE="-1"><A HREF="../../java/lang/Deprecated.html" title="java.lang 中的注释">@Deprecated</A>
</FONT>public void <B>layout</B>()</PRE>
<DL>
<DD><B>已过时。</B>&nbsp;<I>从 JDK version 1.1，用 <code>doLayout()</code> 取代。</I>
<P>
<DD><DL>
<DT><B>覆盖：</B><DD>类 <CODE><A HREF="../../java/awt/Component.html" title="java.awt 中的类">Component</A></CODE> 中的 <CODE><A HREF="../../java/awt/Component.html#layout()">layout</A></CODE></DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="invalidate()"><!-- --></A><H3>
invalidate</H3>
<PRE>
public void <B>invalidate</B>()</PRE>
<DL>
<DD>使容器失效。该容器及其之上的所有父容器被标记为需要重新布置。此方法经常被调用，所以必须快速执行它。
<p>如果在此容器上安装的 <code>LayoutManager</code> 是一个 <code>LayoutManager2</code> 实例，则在该实例上调用 <A HREF="../../java/awt/LayoutManager2.html#invalidateLayout(java.awt.Container)"><CODE>LayoutManager2.invalidateLayout(Container)</CODE></A>，并提供此 <code>Container</code> 作为参数。
<P>
<DD><DL>
<DT><B>覆盖：</B><DD>类 <CODE><A HREF="../../java/awt/Component.html" title="java.awt 中的类">Component</A></CODE> 中的 <CODE><A HREF="../../java/awt/Component.html#invalidate()">invalidate</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>另请参见：</B><DD><A HREF="../../java/awt/Container.html#validate()"><CODE>validate()</CODE></A>, 
<A HREF="../../java/awt/Container.html#layout()"><CODE>layout()</CODE></A>, 
<A HREF="../../java/awt/LayoutManager.html" title="java.awt 中的接口"><CODE>LayoutManager</CODE></A>, 
<A HREF="../../java/awt/LayoutManager2.html#invalidateLayout(java.awt.Container)"><CODE>LayoutManager2.invalidateLayout(Container)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="validate()"><!-- --></A><H3>
validate</H3>
<PRE>
public void <B>validate</B>()</PRE>
<DL>
<DD>验证此容器及其所有子组件。
 <p>
使用 <code>validate</code> 方法会使容器再次布置其子组件。已经显示容器后，在修改此容器的子组件的时候（在容器中添加或移除组件，或者更改与布局相关的信息），应该调用上述方法。

<p>如果此 <code>Container</code> 无效，则此方法将调用 <code>validateTree</code> 方法，并将此 <code>Container</code> 标记为有效。否则不执行任何动作。
<P>
<DD><DL>
<DT><B>覆盖：</B><DD>类 <CODE><A HREF="../../java/awt/Component.html" title="java.awt 中的类">Component</A></CODE> 中的 <CODE><A HREF="../../java/awt/Component.html#validate()">validate</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>另请参见：</B><DD><A HREF="../../java/awt/Container.html#add(java.awt.Component)"><CODE>add(java.awt.Component)</CODE></A>, 
<A HREF="../../java/awt/Component.html#invalidate()"><CODE>Component.invalidate()</CODE></A>, 
<A HREF="../../javax/swing/JComponent.html#revalidate()"><CODE>JComponent.revalidate()</CODE></A>, 
<A HREF="../../java/awt/Container.html#validateTree()"><CODE>validateTree()</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="validateTree()"><!-- --></A><H3>
validateTree</H3>
<PRE>
protected void <B>validateTree</B>()</PRE>
<DL>
<DD>递归继承容器树，对于所有被标记为需要重新计算布局的子树（标记为无效的那些子树）重新计算布局。同步应该由调用本方法的方法 (<code>validate</code>) 提供。
<P>
<DD><DL>
<DT><B>另请参见：</B><DD><A HREF="../../java/awt/Container.html#doLayout()"><CODE>doLayout()</CODE></A>, 
<A HREF="../../java/awt/Container.html#validate()"><CODE>validate()</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="setFont(java.awt.Font)"><!-- --></A><H3>
setFont</H3>
<PRE>
public void <B>setFont</B>(<A HREF="../../java/awt/Font.html" title="java.awt 中的类">Font</A>&nbsp;f)</PRE>
<DL>
<DD>设置此容器的字体。
<P>
<DD><DL>
<DT><B>覆盖：</B><DD>类 <CODE><A HREF="../../java/awt/Component.html" title="java.awt 中的类">Component</A></CODE> 中的 <CODE><A HREF="../../java/awt/Component.html#setFont(java.awt.Font)">setFont</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>参数：</B><DD><CODE>f</CODE> - 将成为此容器的字体的字体。<DT><B>从以下版本开始：</B></DT>
  <DD>JDK1.0</DD>
<DT><B>另请参见：</B><DD><A HREF="../../java/awt/Component.html#getFont()"><CODE>Component.getFont()</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="getPreferredSize()"><!-- --></A><H3>
getPreferredSize</H3>
<PRE>
public <A HREF="../../java/awt/Dimension.html" title="java.awt 中的类">Dimension</A> <B>getPreferredSize</B>()</PRE>
<DL>
<DD>返回此容器的首选大小。如果尚未通过 <A HREF="../../java/awt/Component.html#setPreferredSize(java.awt.Dimension)"><CODE>Component.setPreferredSize(Dimension)</CODE></A> 显式设置首选大小，并且此 <code>Container</code> 有一个 <code>non-null</code> <A HREF="../../java/awt/LayoutManager.html" title="java.awt 中的接口"><CODE>LayoutManager</CODE></A>，则使用 <A HREF="../../java/awt/LayoutManager.html#preferredLayoutSize(java.awt.Container)"><CODE>LayoutManager.preferredLayoutSize(Container)</CODE></A> 来计算首选大小。

 <p>注：一些实现可能缓存从 <code>LayoutManager</code> 返回的值。每次调用此方法时，这些缓存实现不需要在 <code>LayoutManager</code> 上调用 <code>preferredLayoutSize</code>，而是只在 <code>Container</code> 变得无效之后查询 <code>LayoutManager</code>。
<P>
<DD><DL>
<DT><B>覆盖：</B><DD>类 <CODE><A HREF="../../java/awt/Component.html" title="java.awt 中的类">Component</A></CODE> 中的 <CODE><A HREF="../../java/awt/Component.html#getPreferredSize()">getPreferredSize</A></CODE></DL>
</DD>
<DD><DL>

<DT><B>返回：</B><DD>表示此容器的首选大小的 <code>Dimension</code> 实例。<DT><B>另请参见：</B><DD><A HREF="../../java/awt/Container.html#getMinimumSize()"><CODE>getMinimumSize()</CODE></A>, 
<A HREF="../../java/awt/Container.html#getMaximumSize()"><CODE>getMaximumSize()</CODE></A>, 
<A HREF="../../java/awt/Container.html#getLayout()"><CODE>getLayout()</CODE></A>, 
<A HREF="../../java/awt/LayoutManager.html#preferredLayoutSize(java.awt.Container)"><CODE>LayoutManager.preferredLayoutSize(Container)</CODE></A>, 
<A HREF="../../java/awt/Component.html#getPreferredSize()"><CODE>Component.getPreferredSize()</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="preferredSize()"><!-- --></A><H3>
preferredSize</H3>
<PRE>
<FONT SIZE="-1"><A HREF="../../java/lang/Deprecated.html" title="java.lang 中的注释">@Deprecated</A>
</FONT>public <A HREF="../../java/awt/Dimension.html" title="java.awt 中的类">Dimension</A> <B>preferredSize</B>()</PRE>
<DL>
<DD><B>已过时。</B>&nbsp;<I>从 JDK version 1.1 开始，用 <code>getPreferredSize()</code> 取代。</I>
<P>
<DD><DL>
<DT><B>覆盖：</B><DD>类 <CODE><A HREF="../../java/awt/Component.html" title="java.awt 中的类">Component</A></CODE> 中的 <CODE><A HREF="../../java/awt/Component.html#preferredSize()">preferredSize</A></CODE></DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="getMinimumSize()"><!-- --></A><H3>
getMinimumSize</H3>
<PRE>
public <A HREF="../../java/awt/Dimension.html" title="java.awt 中的类">Dimension</A> <B>getMinimumSize</B>()</PRE>
<DL>
<DD>返回此容器的最小大小。如果尚未通过 <A HREF="../../java/awt/Component.html#setMinimumSize(java.awt.Dimension)"><CODE>Component.setMinimumSize(Dimension)</CODE></A> 显式设置最小大小，并且此 <code>Container</code> 有一个 <code>non-null</code> <A HREF="../../java/awt/LayoutManager.html" title="java.awt 中的接口"><CODE>LayoutManager</CODE></A>，则使用 <A HREF="../../java/awt/LayoutManager.html#minimumLayoutSize(java.awt.Container)"><CODE>LayoutManager.minimumLayoutSize(Container)</CODE></A> 来计算最小大小。

 <p>注：一些实现可能缓存从 <code>LayoutManager</code> 返回的值。每次调用此方法时，这些缓存实现不需要在 <code>LayoutManager</code> 上调用 <code>minimumLayoutSize</code>，而是只在 <code>Container</code> 变得无效之后查询 <code>LayoutManager</code>。
<P>
<DD><DL>
<DT><B>覆盖：</B><DD>类 <CODE><A HREF="../../java/awt/Component.html" title="java.awt 中的类">Component</A></CODE> 中的 <CODE><A HREF="../../java/awt/Component.html#getMinimumSize()">getMinimumSize</A></CODE></DL>
</DD>
<DD><DL>

<DT><B>返回：</B><DD>表示此容器的最小大小的 <code>Dimension</code> 实例。<DT><B>从以下版本开始：</B></DT>
  <DD>JDK1.1</DD>
<DT><B>另请参见：</B><DD><A HREF="../../java/awt/Container.html#getPreferredSize()"><CODE>getPreferredSize()</CODE></A>, 
<A HREF="../../java/awt/Container.html#getMaximumSize()"><CODE>getMaximumSize()</CODE></A>, 
<A HREF="../../java/awt/Container.html#getLayout()"><CODE>getLayout()</CODE></A>, 
<A HREF="../../java/awt/LayoutManager.html#minimumLayoutSize(java.awt.Container)"><CODE>LayoutManager.minimumLayoutSize(Container)</CODE></A>, 
<A HREF="../../java/awt/Component.html#getMinimumSize()"><CODE>Component.getMinimumSize()</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="minimumSize()"><!-- --></A><H3>
minimumSize</H3>
<PRE>
<FONT SIZE="-1"><A HREF="../../java/lang/Deprecated.html" title="java.lang 中的注释">@Deprecated</A>
</FONT>public <A HREF="../../java/awt/Dimension.html" title="java.awt 中的类">Dimension</A> <B>minimumSize</B>()</PRE>
<DL>
<DD><B>已过时。</B>&nbsp;<I>从 JDK version 1.1 开始，用 <code>getMinimumSize()</code> 取代。</I>
<P>
<DD><DL>
<DT><B>覆盖：</B><DD>类 <CODE><A HREF="../../java/awt/Component.html" title="java.awt 中的类">Component</A></CODE> 中的 <CODE><A HREF="../../java/awt/Component.html#minimumSize()">minimumSize</A></CODE></DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="getMaximumSize()"><!-- --></A><H3>
getMaximumSize</H3>
<PRE>
public <A HREF="../../java/awt/Dimension.html" title="java.awt 中的类">Dimension</A> <B>getMaximumSize</B>()</PRE>
<DL>
<DD>返回此容器的最大大小。如果尚未通过 <A HREF="../../java/awt/Component.html#setMaximumSize(java.awt.Dimension)"><CODE>Component.setMaximumSize(Dimension)</CODE></A> 显式设置最大大小，并且在此 <code>Container</code> 上安装的 <A HREF="../../java/awt/LayoutManager.html" title="java.awt 中的接口"><CODE>LayoutManager</CODE></A> 是一个 <A HREF="../../java/awt/LayoutManager2.html" title="java.awt 中的接口"><CODE>LayoutManager2</CODE></A> 实例，则使用 <A HREF="../../java/awt/LayoutManager2.html#maximumLayoutSize(java.awt.Container)"><CODE>LayoutManager2.maximumLayoutSize(Container)</CODE></A> 来计算最大大小。

 <p>注：一些实现可能缓存从 <code>LayoutManager2</code> 返回的值。每次调用此方法时，这些缓存实现不需要在 <code>LayoutManager2</code> 上调用 <code>maximumLayoutSize</code>，而是只在 <code>Container</code> 变得无效之后查询 <code>LayoutManager2</code>。
<P>
<DD><DL>
<DT><B>覆盖：</B><DD>类 <CODE><A HREF="../../java/awt/Component.html" title="java.awt 中的类">Component</A></CODE> 中的 <CODE><A HREF="../../java/awt/Component.html#getMaximumSize()">getMaximumSize</A></CODE></DL>
</DD>
<DD><DL>

<DT><B>返回：</B><DD>表示此容器最大大小的 <code>Dimension</code> 实例。<DT><B>另请参见：</B><DD><A HREF="../../java/awt/Container.html#getPreferredSize()"><CODE>getPreferredSize()</CODE></A>, 
<A HREF="../../java/awt/Container.html#getMinimumSize()"><CODE>getMinimumSize()</CODE></A>, 
<A HREF="../../java/awt/Container.html#getLayout()"><CODE>getLayout()</CODE></A>, 
<A HREF="../../java/awt/LayoutManager2.html#maximumLayoutSize(java.awt.Container)"><CODE>LayoutManager2.maximumLayoutSize(Container)</CODE></A>, 
<A HREF="../../java/awt/Component.html#getMaximumSize()"><CODE>Component.getMaximumSize()</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="getAlignmentX()"><!-- --></A><H3>
getAlignmentX</H3>
<PRE>
public float <B>getAlignmentX</B>()</PRE>
<DL>
<DD>返回沿 x 轴的对齐方式。这指出了相对于其他组件将如何对齐该组件。该值应该在 0 到 1 之间，其中，0 表示根据原点进行对齐，1 表示根据距原点最远的地方对齐，0.5 表示从中间对齐等等。
<P>
<DD><DL>
<DT><B>覆盖：</B><DD>类 <CODE><A HREF="../../java/awt/Component.html" title="java.awt 中的类">Component</A></CODE> 中的 <CODE><A HREF="../../java/awt/Component.html#getAlignmentX()">getAlignmentX</A></CODE></DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="getAlignmentY()"><!-- --></A><H3>
getAlignmentY</H3>
<PRE>
public float <B>getAlignmentY</B>()</PRE>
<DL>
<DD>返回沿 y 轴的对齐方式。这指出相对于其他组件将如何排列该组件。该值应该在 0 到 1 之间，其中，0 表示根据原点进行对齐，1 表示根据距原点最远的地方对齐，0.5 表示从中间对齐等等。
<P>
<DD><DL>
<DT><B>覆盖：</B><DD>类 <CODE><A HREF="../../java/awt/Component.html" title="java.awt 中的类">Component</A></CODE> 中的 <CODE><A HREF="../../java/awt/Component.html#getAlignmentY()">getAlignmentY</A></CODE></DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="paint(java.awt.Graphics)"><!-- --></A><H3>
paint</H3>
<PRE>
public void <B>paint</B>(<A HREF="../../java/awt/Graphics.html" title="java.awt 中的类">Graphics</A>&nbsp;g)</PRE>
<DL>
<DD>绘制容器。该方法将 paint 转发给任意一个此容器子组件的轻量级组件。如果重新实现此方法，那么应该调用 super.paint(g) 方法，从而可以正确地呈现轻量级组件。如果通过 g 中的当前剪切设置完全剪切某个子组件，则不会将 paint() 转发给这个子组件。
<P>
<DD><DL>
<DT><B>覆盖：</B><DD>类 <CODE><A HREF="../../java/awt/Component.html" title="java.awt 中的类">Component</A></CODE> 中的 <CODE><A HREF="../../java/awt/Component.html#paint(java.awt.Graphics)">paint</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>参数：</B><DD><CODE>g</CODE> - 指定的 Graphics 窗口<DT><B>另请参见：</B><DD><A HREF="../../java/awt/Component.html#update(java.awt.Graphics)"><CODE>Component.update(Graphics)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="update(java.awt.Graphics)"><!-- --></A><H3>
update</H3>
<PRE>
public void <B>update</B>(<A HREF="../../java/awt/Graphics.html" title="java.awt 中的类">Graphics</A>&nbsp;g)</PRE>
<DL>
<DD>更新容器。该方法将 update 方法转发给任意一个此容器子组件的轻量级组件。如果重新实现此方法，那么应该调用 super.update(g) 方法，从而可以正确地呈现轻量级组件。如果通过 g 中的当前剪切设置完全剪切某个子组件，则不会将 update() 转发给这个子组件。
<P>
<DD><DL>
<DT><B>覆盖：</B><DD>类 <CODE><A HREF="../../java/awt/Component.html" title="java.awt 中的类">Component</A></CODE> 中的 <CODE><A HREF="../../java/awt/Component.html#update(java.awt.Graphics)">update</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>参数：</B><DD><CODE>g</CODE> - 指定的 Graphics 窗口<DT><B>另请参见：</B><DD><A HREF="../../java/awt/Component.html#update(java.awt.Graphics)"><CODE>Component.update(Graphics)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="print(java.awt.Graphics)"><!-- --></A><H3>
print</H3>
<PRE>
public void <B>print</B>(<A HREF="../../java/awt/Graphics.html" title="java.awt 中的类">Graphics</A>&nbsp;g)</PRE>
<DL>
<DD>打印容器。该方法将 print 方法转发给任意一个此容器子组件的轻量级组件。如果重新实现此方法，那么应该调用 super.print(g) 方法，从而可以正确地呈现轻量级组件。如果通过 g 中的当前剪切设置完全剪切某个子组件，则不会将 print() 转发给这个子组件。
<P>
<DD><DL>
<DT><B>覆盖：</B><DD>类 <CODE><A HREF="../../java/awt/Component.html" title="java.awt 中的类">Component</A></CODE> 中的 <CODE><A HREF="../../java/awt/Component.html#print(java.awt.Graphics)">print</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>参数：</B><DD><CODE>g</CODE> - 指定的 Graphics 窗口<DT><B>另请参见：</B><DD><A HREF="../../java/awt/Component.html#update(java.awt.Graphics)"><CODE>Component.update(Graphics)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="paintComponents(java.awt.Graphics)"><!-- --></A><H3>
paintComponents</H3>
<PRE>
public void <B>paintComponents</B>(<A HREF="../../java/awt/Graphics.html" title="java.awt 中的类">Graphics</A>&nbsp;g)</PRE>
<DL>
<DD>绘制此容器中的每个组件。
<P>
<DD><DL>
<DT><B>参数：</B><DD><CODE>g</CODE> - 图形上下文。<DT><B>另请参见：</B><DD><A HREF="../../java/awt/Component.html#paint(java.awt.Graphics)"><CODE>Component.paint(java.awt.Graphics)</CODE></A>, 
<A HREF="../../java/awt/Component.html#paintAll(java.awt.Graphics)"><CODE>Component.paintAll(java.awt.Graphics)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="printComponents(java.awt.Graphics)"><!-- --></A><H3>
printComponents</H3>
<PRE>
public void <B>printComponents</B>(<A HREF="../../java/awt/Graphics.html" title="java.awt 中的类">Graphics</A>&nbsp;g)</PRE>
<DL>
<DD>打印此容器中的每个组件。
<P>
<DD><DL>
<DT><B>参数：</B><DD><CODE>g</CODE> - 图形上下文。<DT><B>另请参见：</B><DD><A HREF="../../java/awt/Component.html#print(java.awt.Graphics)"><CODE>Component.print(java.awt.Graphics)</CODE></A>, 
<A HREF="../../java/awt/Component.html#printAll(java.awt.Graphics)"><CODE>Component.printAll(java.awt.Graphics)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="addContainerListener(java.awt.event.ContainerListener)"><!-- --></A><H3>
addContainerListener</H3>
<PRE>
public void <B>addContainerListener</B>(<A HREF="../../java/awt/event/ContainerListener.html" title="java.awt.event 中的接口">ContainerListener</A>&nbsp;l)</PRE>
<DL>
<DD>添加指定容器的侦听器，以接收来自此容器的容器事件。如果 l 为 null，则不会抛出异常，并且不执行任何动作。
有关 AWT 的线程模型的细节信息，请参阅 <a href="doc-files/AWTThreadIssues.html#ListenersThreads"  >AWT 线程问题</a>。
<P>
<DD><DL>
<DT><B>参数：</B><DD><CODE>l</CODE> - 容器侦听器<DT><B>另请参见：</B><DD><A HREF="../../java/awt/Container.html#removeContainerListener(java.awt.event.ContainerListener)"><CODE>removeContainerListener(java.awt.event.ContainerListener)</CODE></A>, 
<A HREF="../../java/awt/Container.html#getContainerListeners()"><CODE>getContainerListeners()</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="removeContainerListener(java.awt.event.ContainerListener)"><!-- --></A><H3>
removeContainerListener</H3>
<PRE>
public void <B>removeContainerListener</B>(<A HREF="../../java/awt/event/ContainerListener.html" title="java.awt.event 中的接口">ContainerListener</A>&nbsp;l)</PRE>
<DL>
<DD>移除指定容器的侦听器，从而不再接收来自此容器的容器事件。如果 l 为 null，则不会抛出异常，并且不执行任何动作。
有关 AWT 的线程模型的细节信息，请参阅 <a href="doc-files/AWTThreadIssues.html#ListenersThreads"  >AWT 线程问题</a>。
<P>
<DD><DL>
<DT><B>参数：</B><DD><CODE>l</CODE> - 容器侦听器<DT><B>另请参见：</B><DD><A HREF="../../java/awt/Container.html#addContainerListener(java.awt.event.ContainerListener)"><CODE>addContainerListener(java.awt.event.ContainerListener)</CODE></A>, 
<A HREF="../../java/awt/Container.html#getContainerListeners()"><CODE>getContainerListeners()</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="getContainerListeners()"><!-- --></A><H3>
getContainerListeners</H3>
<PRE>
public <A HREF="../../java/awt/event/ContainerListener.html" title="java.awt.event 中的接口">ContainerListener</A>[] <B>getContainerListeners</B>()</PRE>
<DL>
<DD>返回已在此容器上注册的所有容器侦听器的数组。
<P>
<DD><DL>

<DT><B>返回：</B><DD>此容器的所有 <code>ContainerListener</code>，如果没有当前已注册的容器侦听器，则返回一个空数组<DT><B>从以下版本开始：</B></DT>
  <DD>1.4</DD>
<DT><B>另请参见：</B><DD><A HREF="../../java/awt/Container.html#addContainerListener(java.awt.event.ContainerListener)"><CODE>addContainerListener(java.awt.event.ContainerListener)</CODE></A>, 
<A HREF="../../java/awt/Container.html#removeContainerListener(java.awt.event.ContainerListener)"><CODE>removeContainerListener(java.awt.event.ContainerListener)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="getListeners(java.lang.Class)"><!-- --></A><H3>
getListeners</H3>
<PRE>
public &lt;T extends <A HREF="../../java/util/EventListener.html" title="java.util 中的接口">EventListener</A>&gt; T[] <B>getListeners</B>(<A HREF="../../java/lang/Class.html" title="java.lang 中的类">Class</A>&lt;T&gt;&nbsp;listenerType)</PRE>
<DL>
<DD>返回当前已在此 <code>Container</code> 上注册为 <code><em>Foo</em>Listener</code> 的所有对象的数组。<code><em>Foo</em>Listener</code> 是使用 <code>add<em>Foo</em>Listener</code> 方法注册的。

 <p>
可以用一个类字面值（比如 <code><em>Foo</em>Listener.class</code>）指定 <code>listenerType</code> 参数。例如，可以使用以下代码查询 <code>Container</code> <code>c</code>，以获得该容器的侦听器：

 <pre>ContainerListener[] cls = (ContainerListener[])(c.getListeners(ContainerListener.class));</pre>

如果不存在这样的侦听器，则此方法将返回一个空数组。
<P>
<DD><DL>
<DT><B>覆盖：</B><DD>类 <CODE><A HREF="../../java/awt/Component.html" title="java.awt 中的类">Component</A></CODE> 中的 <CODE><A HREF="../../java/awt/Component.html#getListeners(java.lang.Class)">getListeners</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>参数：</B><DD><CODE>listenerType</CODE> - 所请求侦听器的类型；该参数应该指定一个从 <code>java.util.EventListener</code> 继承的接口
<DT><B>返回：</B><DD>在此容器上注册为 <code><em>Foo</em>Listener</code> 的所有对象的数组，如果没有添加这样的侦听器，则返回一个空数组
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../java/lang/ClassCastException.html" title="java.lang 中的类">ClassCastException</A></CODE> - 如果 <code>listenerType</code> 没有指定实现 <code>java.util.EventListener</code> 的类或接口<DT><B>从以下版本开始：</B></DT>
  <DD>1.3</DD>
<DT><B>另请参见：</B><DD><A HREF="../../java/awt/Container.html#getContainerListeners()"><CODE>getContainerListeners()</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="processEvent(java.awt.AWTEvent)"><!-- --></A><H3>
processEvent</H3>
<PRE>
protected void <B>processEvent</B>(<A HREF="../../java/awt/AWTEvent.html" title="java.awt 中的类">AWTEvent</A>&nbsp;e)</PRE>
<DL>
<DD>处理关于此容器的事件。如果事件是一个 <code>ContainerEvent</code>，那么将调用 <code>processContainerEvent</code> 方法，否则将调用其超类的 <code>processEvent</code> 方法。
<p>注意，如果事件参数为 <code>null</code>，则行为是不确定的，并且可能导致异常。
<P>
<DD><DL>
<DT><B>覆盖：</B><DD>类 <CODE><A HREF="../../java/awt/Component.html" title="java.awt 中的类">Component</A></CODE> 中的 <CODE><A HREF="../../java/awt/Component.html#processEvent(java.awt.AWTEvent)">processEvent</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>参数：</B><DD><CODE>e</CODE> - 事件<DT><B>另请参见：</B><DD><A HREF="../../java/awt/Component.html#processComponentEvent(java.awt.event.ComponentEvent)"><CODE>Component.processComponentEvent(java.awt.event.ComponentEvent)</CODE></A>, 
<A HREF="../../java/awt/Component.html#processFocusEvent(java.awt.event.FocusEvent)"><CODE>Component.processFocusEvent(java.awt.event.FocusEvent)</CODE></A>, 
<A HREF="../../java/awt/Component.html#processKeyEvent(java.awt.event.KeyEvent)"><CODE>Component.processKeyEvent(java.awt.event.KeyEvent)</CODE></A>, 
<A HREF="../../java/awt/Component.html#processMouseEvent(java.awt.event.MouseEvent)"><CODE>Component.processMouseEvent(java.awt.event.MouseEvent)</CODE></A>, 
<A HREF="../../java/awt/Component.html#processMouseMotionEvent(java.awt.event.MouseEvent)"><CODE>Component.processMouseMotionEvent(java.awt.event.MouseEvent)</CODE></A>, 
<A HREF="../../java/awt/Component.html#processInputMethodEvent(java.awt.event.InputMethodEvent)"><CODE>Component.processInputMethodEvent(java.awt.event.InputMethodEvent)</CODE></A>, 
<A HREF="../../java/awt/Component.html#processHierarchyEvent(java.awt.event.HierarchyEvent)"><CODE>Component.processHierarchyEvent(java.awt.event.HierarchyEvent)</CODE></A>, 
<A HREF="../../java/awt/Component.html#processMouseWheelEvent(java.awt.event.MouseWheelEvent)"><CODE>Component.processMouseWheelEvent(java.awt.event.MouseWheelEvent)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="processContainerEvent(java.awt.event.ContainerEvent)"><!-- --></A><H3>
processContainerEvent</H3>
<PRE>
protected void <B>processContainerEvent</B>(<A HREF="../../java/awt/event/ContainerEvent.html" title="java.awt.event 中的类">ContainerEvent</A>&nbsp;e)</PRE>
<DL>
<DD>通过将发生在此容器上的容器事件指派给所有已注册的 ContainerListener 对象来处理这些事件。注：直到为此组件启用容器事件，才调用此方法；这发生在出现以下情况之一时：
 <ul>
<li>通过 <code>addContainerListener</code> 注册 ContainerListener 对象 
<li>通过 <code>enableEvents</code> 启用容器事件
 </ul>
<p>注意，如果事件参数为 <code>null</code>，则行为是不确定的，并且可能导致异常。
<P>
<DD><DL>
<DT><B>参数：</B><DD><CODE>e</CODE> - 容器事件<DT><B>另请参见：</B><DD><A HREF="../../java/awt/Component.html#enableEvents(long)"><CODE>Component.enableEvents(long)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="deliverEvent(java.awt.Event)"><!-- --></A><H3>
deliverEvent</H3>
<PRE>
<FONT SIZE="-1"><A HREF="../../java/lang/Deprecated.html" title="java.lang 中的注释">@Deprecated</A>
</FONT>public void <B>deliverEvent</B>(<A HREF="../../java/awt/Event.html" title="java.awt 中的类">Event</A>&nbsp;e)</PRE>
<DL>
<DD><B>已过时。</B>&nbsp;<I>从 JDK version 1.1 开始，用 <code>dispatchEvent(AWTEvent e)</code> 取代</I>
<P>
<DD><DL>
<DT><B>覆盖：</B><DD>类 <CODE><A HREF="../../java/awt/Component.html" title="java.awt 中的类">Component</A></CODE> 中的 <CODE><A HREF="../../java/awt/Component.html#deliverEvent(java.awt.Event)">deliverEvent</A></CODE></DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="getComponentAt(int, int)"><!-- --></A><H3>
getComponentAt</H3>
<PRE>
public <A HREF="../../java/awt/Component.html" title="java.awt 中的类">Component</A> <B>getComponentAt</B>(int&nbsp;x,
                                int&nbsp;y)</PRE>
<DL>
<DD>对包含 x，y 位置的组件进行定位。在组件中出现重叠的情况下，返回位于最顶端的子组件。这是通过查找最接近于索引 0 并且通过 Component.contains() 要求包含给定点的组件来确定的，但拥有本机同位体的组件优先于那些没有同位体的组件（也就是轻量级组件）。
<P>
<DD><DL>
<DT><B>覆盖：</B><DD>类 <CODE><A HREF="../../java/awt/Component.html" title="java.awt 中的类">Component</A></CODE> 中的 <CODE><A HREF="../../java/awt/Component.html#getComponentAt(int, int)">getComponentAt</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>参数：</B><DD><CODE>x</CODE> - <i>x</i> 坐标<DD><CODE>y</CODE> - <i>y</i> 坐标
<DT><B>返回：</B><DD>如果组件不包含该位置上，则返回 null。如果所请求的点上没有子组件，并且这个点在容器的边界内，则返回容器自身；否则返回最顶端的子组件。<DT><B>从以下版本开始：</B></DT>
  <DD>JDK1.1</DD>
<DT><B>另请参见：</B><DD><A HREF="../../java/awt/Component.html#contains(int, int)"><CODE>Component.contains(int, int)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="locate(int, int)"><!-- --></A><H3>
locate</H3>
<PRE>
<FONT SIZE="-1"><A HREF="../../java/lang/Deprecated.html" title="java.lang 中的注释">@Deprecated</A>
</FONT>public <A HREF="../../java/awt/Component.html" title="java.awt 中的类">Component</A> <B>locate</B>(int&nbsp;x,
                                   int&nbsp;y)</PRE>
<DL>
<DD><B>已过时。</B>&nbsp;<I>从 JDK version 1.1 开始，用 <code>getComponentAt(int, int)</code> 取代。</I>
<P>
<DD><DL>
<DT><B>覆盖：</B><DD>类 <CODE><A HREF="../../java/awt/Component.html" title="java.awt 中的类">Component</A></CODE> 中的 <CODE><A HREF="../../java/awt/Component.html#locate(int, int)">locate</A></CODE></DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="getComponentAt(java.awt.Point)"><!-- --></A><H3>
getComponentAt</H3>
<PRE>
public <A HREF="../../java/awt/Component.html" title="java.awt 中的类">Component</A> <B>getComponentAt</B>(<A HREF="../../java/awt/Point.html" title="java.awt 中的类">Point</A>&nbsp;p)</PRE>
<DL>
<DD>获取包含指定点的组件。
<P>
<DD><DL>
<DT><B>覆盖：</B><DD>类 <CODE><A HREF="../../java/awt/Component.html" title="java.awt 中的类">Component</A></CODE> 中的 <CODE><A HREF="../../java/awt/Component.html#getComponentAt(java.awt.Point)">getComponentAt</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>参数：</B><DD><CODE>p</CODE> - 点。
<DT><B>返回：</B><DD>包含这个点的组件，如果组件不包含这个点，则返回 <code>null</code>。<DT><B>从以下版本开始：</B></DT>
  <DD>JDK1.1</DD>
<DT><B>另请参见：</B><DD><A HREF="../../java/awt/Component.html#contains(int, int)"><CODE>Component.contains(int, int)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="getMousePosition(boolean)"><!-- --></A><H3>
getMousePosition</H3>
<PRE>
public <A HREF="../../java/awt/Point.html" title="java.awt 中的类">Point</A> <B>getMousePosition</B>(boolean&nbsp;allowChildren)
                       throws <A HREF="../../java/awt/HeadlessException.html" title="java.awt 中的类">HeadlessException</A></PRE>
<DL>
<DD>如果 <code>Container</code> 位于鼠标指针下，则返回鼠标指针在此 <code>Container</code> 的坐标中的位置，否则返回 <code>null</code>。此方法类似于 <A HREF="../../java/awt/Component.html#getMousePosition()"><CODE>Component.getMousePosition()</CODE></A>，不过它可能还要考虑 <code>Container</code> 的子组件。如果 <code>allowChildren</code> 为 <code>false</code>，则仅当鼠标指针直接位于 <code>Container</code> 上方，而不是位于被 Container 的子组件掩盖的那部分上方时，此方法才返回一个非 null 值。如果 <code>allowChildren</code> 为 <code>true</code>，且鼠标指针位于 <code>Container</code> 或其任意子代的上方时，此方法才返回一个非 null 值。
<P>
<DD><DL>
<DT><B>参数：</B><DD><CODE>allowChildren</CODE> - 如果将子组件也考虑进去，则此参数为 true
<DT><B>返回：</B><DD>相对于 <code>Component</code> 的鼠标坐标，或者 null
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../java/awt/HeadlessException.html" title="java.awt 中的类">HeadlessException</A></CODE> - 如果 GraphicsEnvironment.isHeadless() 返回 true<DT><B>从以下版本开始：</B></DT>
  <DD>1.5</DD>
<DT><B>另请参见：</B><DD><A HREF="../../java/awt/Component.html#getMousePosition()"><CODE>Component.getMousePosition()</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="findComponentAt(int, int)"><!-- --></A><H3>
findComponentAt</H3>
<PRE>
public <A HREF="../../java/awt/Component.html" title="java.awt 中的类">Component</A> <B>findComponentAt</B>(int&nbsp;x,
                                 int&nbsp;y)</PRE>
<DL>
<DD>对包含指定位置的可视子组件进行定位。在组件中出现重叠的情况下，返回位于最顶端的子组件。如果包含的子组件是一个 Container，则此方法将继续搜索，以找到嵌套最深的子组件。在搜索期间忽略不可见的组件。<p>

findComponentAt 方法不同于 getComponentAt 方法，getComponentAt 方法只搜索 Container 的直接子组件；如果包含的组件是一个 Container，则 findComponentAt 方法将搜索子容器，以找到嵌套的组件。
<P>
<DD><DL>
<DT><B>参数：</B><DD><CODE>x</CODE> - <i>x</i> 坐标<DD><CODE>y</CODE> - <i>y</i> 坐标
<DT><B>返回：</B><DD>如果组件不包含这个位置上，则返回 null。如果所请求的点上没有子组件，并且这个点在容器的边界内，则返回容器自身。<DT><B>从以下版本开始：</B></DT>
  <DD>1.2</DD>
<DT><B>另请参见：</B><DD><A HREF="../../java/awt/Component.html#contains(int, int)"><CODE>Component.contains(int, int)</CODE></A>, 
<A HREF="../../java/awt/Container.html#getComponentAt(int, int)"><CODE>getComponentAt(int, int)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="findComponentAt(java.awt.Point)"><!-- --></A><H3>
findComponentAt</H3>
<PRE>
public <A HREF="../../java/awt/Component.html" title="java.awt 中的类">Component</A> <B>findComponentAt</B>(<A HREF="../../java/awt/Point.html" title="java.awt 中的类">Point</A>&nbsp;p)</PRE>
<DL>
<DD>对包含指定点的可视子组件进行定位。在组件中出现重叠的情况下，返回位于最顶端的子组件。如果包含的子组件是一个 Container，则此方法将继续搜索，以找到嵌套最深的子组件。在搜索期间忽略不可见的组件。<p>

findComponentAt 方法不同于 getComponentAt 方法，getComponentAt 方法只搜索 Container 的直接子组件；如果包含的组件是一个 Container，则 findComponentAt 方法将搜索子容器，以找到嵌套的组件。
<P>
<DD><DL>
<DT><B>参数：</B><DD><CODE>p</CODE> - 点。
<DT><B>返回：</B><DD>如果组件没有包含该位置，则返回 null。如果所请求的点上没有子组件，并且这个点在容器的边界内，则返回容器自身。<DT><B>从以下版本开始：</B></DT>
  <DD>1.2</DD>
<DT><B>另请参见：</B><DD><A HREF="../../java/awt/Component.html#contains(int, int)"><CODE>Component.contains(int, int)</CODE></A>, 
<A HREF="../../java/awt/Container.html#getComponentAt(int, int)"><CODE>getComponentAt(int, int)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="addNotify()"><!-- --></A><H3>
addNotify</H3>
<PRE>
public void <B>addNotify</B>()</PRE>
<DL>
<DD>通过将这个 Container 连接到本机屏幕资源，使其可以显示。使容器变得可以显示会使其所有子容器都变得可以显示。此方法是通过工具包内部调用的，不应该通过程序直接调用它。
<P>
<DD><DL>
<DT><B>覆盖：</B><DD>类 <CODE><A HREF="../../java/awt/Component.html" title="java.awt 中的类">Component</A></CODE> 中的 <CODE><A HREF="../../java/awt/Component.html#addNotify()">addNotify</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>另请参见：</B><DD><A HREF="../../java/awt/Component.html#isDisplayable()"><CODE>Component.isDisplayable()</CODE></A>, 
<A HREF="../../java/awt/Container.html#removeNotify()"><CODE>removeNotify()</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="removeNotify()"><!-- --></A><H3>
removeNotify</H3>
<PRE>
public void <B>removeNotify</B>()</PRE>
<DL>
<DD>通过移除此 Container 到其本机屏幕资源的连接，使其不可显示。使容器变得不可显示会使其所有子容器都变得不可显示。此方法是通过工具包内部调用的，不应该通过程序直接调用它。
<P>
<DD><DL>
<DT><B>覆盖：</B><DD>类 <CODE><A HREF="../../java/awt/Component.html" title="java.awt 中的类">Component</A></CODE> 中的 <CODE><A HREF="../../java/awt/Component.html#removeNotify()">removeNotify</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>另请参见：</B><DD><A HREF="../../java/awt/Component.html#isDisplayable()"><CODE>Component.isDisplayable()</CODE></A>, 
<A HREF="../../java/awt/Container.html#addNotify()"><CODE>addNotify()</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="isAncestorOf(java.awt.Component)"><!-- --></A><H3>
isAncestorOf</H3>
<PRE>
public boolean <B>isAncestorOf</B>(<A HREF="../../java/awt/Component.html" title="java.awt 中的类">Component</A>&nbsp;c)</PRE>
<DL>
<DD>检查该组件是否包含在此容器的组件层次结构中。
<P>
<DD><DL>
<DT><B>参数：</B><DD><CODE>c</CODE> - 组件
<DT><B>返回：</B><DD>如果它是一个祖先级组件，则返回 <code>true</code>；否则返回 <code>false</code>。<DT><B>从以下版本开始：</B></DT>
  <DD>JDK1.1</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="paramString()"><!-- --></A><H3>
paramString</H3>
<PRE>
protected <A HREF="../../java/lang/String.html" title="java.lang 中的类">String</A> <B>paramString</B>()</PRE>
<DL>
<DD>返回表示此 <code>Container</code> 的状态的字符串。此方法仅在进行调试的时候使用，对于各个实现，所返回字符串的内容和格式可能有所不同。返回的字符串可能为空，但不可能为 <code>null</code>。
<P>
<DD><DL>
<DT><B>覆盖：</B><DD>类 <CODE><A HREF="../../java/awt/Component.html" title="java.awt 中的类">Component</A></CODE> 中的 <CODE><A HREF="../../java/awt/Component.html#paramString()">paramString</A></CODE></DL>
</DD>
<DD><DL>

<DT><B>返回：</B><DD>此容器的参数字符串</DL>
</DD>
</DL>
<HR>

<A NAME="list(java.io.PrintStream, int)"><!-- --></A><H3>
list</H3>
<PRE>
public void <B>list</B>(<A HREF="../../java/io/PrintStream.html" title="java.io 中的类">PrintStream</A>&nbsp;out,
                 int&nbsp;indent)</PRE>
<DL>
<DD>将此容器的清单打印到指定输出流。该清单起始于指定缩排位置。
 <p>
使用 <code>indent+1</code> 的缩排来打印容器的直接子组件。这些子组件的子组件是在 <code>indent+2</code> 上打印的，依此类推。
<P>
<DD><DL>
<DT><B>覆盖：</B><DD>类 <CODE><A HREF="../../java/awt/Component.html" title="java.awt 中的类">Component</A></CODE> 中的 <CODE><A HREF="../../java/awt/Component.html#list(java.io.PrintStream, int)">list</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>参数：</B><DD><CODE>out</CODE> - 打印流<DD><CODE>indent</CODE> - 缩排的空格数<DT><B>从以下版本开始：</B></DT>
  <DD>JDK1.0</DD>
<DT><B>另请参见：</B><DD><A HREF="../../java/awt/Component.html#list(java.io.PrintStream, int)"><CODE>Component.list(java.io.PrintStream, int)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="list(java.io.PrintWriter, int)"><!-- --></A><H3>
list</H3>
<PRE>
public void <B>list</B>(<A HREF="../../java/io/PrintWriter.html" title="java.io 中的类">PrintWriter</A>&nbsp;out,
                 int&nbsp;indent)</PRE>
<DL>
<DD>将一个列表打印到指定打印编写器，从指定缩排位置开始。
 <p>
使用 <code>indent+1</code> 的缩排来打印容器的直接子组件。这些子组件的子组件是在 <code>indent+2</code> 上打印的，依此类推。
<P>
<DD><DL>
<DT><B>覆盖：</B><DD>类 <CODE><A HREF="../../java/awt/Component.html" title="java.awt 中的类">Component</A></CODE> 中的 <CODE><A HREF="../../java/awt/Component.html#list(java.io.PrintWriter, int)">list</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>参数：</B><DD><CODE>out</CODE> - 打印编写器<DD><CODE>indent</CODE> - 缩排的空格数<DT><B>从以下版本开始：</B></DT>
  <DD>JDK1.1</DD>
<DT><B>另请参见：</B><DD><A HREF="../../java/awt/Component.html#list(java.io.PrintWriter, int)"><CODE>Component.list(java.io.PrintWriter, int)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="setFocusTraversalKeys(int, java.util.Set)"><!-- --></A><H3>
setFocusTraversalKeys</H3>
<PRE>
public void <B>setFocusTraversalKeys</B>(int&nbsp;id,
                                  <A HREF="../../java/util/Set.html" title="java.util 中的接口">Set</A>&lt;? extends <A HREF="../../java/awt/AWTKeyStroke.html" title="java.awt 中的类">AWTKeyStroke</A>&gt;&nbsp;keystrokes)</PRE>
<DL>
<DD>为此 Container 的给定遍历操作设置焦点遍历键。
 <p>
Container 的焦点遍历键的默认值与实现相关。Sun 建议特定本机平台的所有实现都使用相同的默认值。对 Windows 和 Unix 的建议列出如下。这些建议用于 Sun AWT 实现中。

 <table border=1 summary="Recommended default values for a Container's focus traversal keys">
 <tr>
<th>标识符</th>
<th>含义</th>
<th>默认值</th>
 </tr>
 <tr>
    <td>KeyboardFocusManager.FORWARD_TRAVERSAL_KEYS</td>
<td>普通的转发键盘遍历</td>
<td>KEY_PRESSED 上的 TAB，KEY_PRESSED 上的 CTRL-TAB</td>
 </tr>
 <tr>
    <td>KeyboardFocusManager.BACKWARD_TRAVERSAL_KEYS</td>
<td>普通的反向键盘遍历</td>
<td>KEY_PRESSED 上的 SHIFT-TAB，KEY_PRESSED 上的 CTRL-SHIFT-TAB</td>
 </tr>
 <tr>
    <td>KeyboardFocusManager.UP_CYCLE_TRAVERSAL_KEYS</td>
<td>向上移动一个焦点遍历循环</td>
<td>无</td>
 </tr>
 <tr>
    <td>KeyboardFocusManager.DOWN_CYCLE_TRAVERSAL_KEYS<td>
<td>向下移动一个焦点遍历循环</td>
<td>无</td>
 </tr>
 </table>

要禁用一个遍历键，可以使用空 Set；建议使用 Collections.EMPTY_SET。
 <p>
使用 AWTKeyStroke API，客户机代码可以指定在两个特定 KeyEvents（KEY_PRESSED 或 KEY_RELEASED）中的哪一个上进行焦点遍历操作。不管指定的是哪一个 KeyEvent，所有与焦点遍历键相关的 KeyEvent（包括相关 KEY_TYPED 事件）都将被使用，并且不将它们指派给任何 Container。在将事件映射到焦点遍历操作，或者将同一事件映射到多个默认焦点遍历操作时，指定 KEY_TYPED 事件是一个运行时错误。
 <p>
如果为 Set 指定 null 值，则此 Container 将继承其父辈的 Set。如果此 Container 的所有祖先都为 Set 指定了 null 值，则使用当前 KeyboardFocusManager 的默认 Set。
<P>
<DD><DL>
<DT><B>覆盖：</B><DD>类 <CODE><A HREF="../../java/awt/Component.html" title="java.awt 中的类">Component</A></CODE> 中的 <CODE><A HREF="../../java/awt/Component.html#setFocusTraversalKeys(int, java.util.Set)">setFocusTraversalKeys</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>参数：</B><DD><CODE>id</CODE> - KeyboardFocusManager.FORWARD_TRAVERSAL_KEYS、KeyboardFocusManager.BACKWARD_TRAVERSAL_KEYS、KeyboardFocusManager.UP_CYCLE_TRAVERSAL_KEYS 或 KeyboardFocusManager.DOWN_CYCLE_TRAVERSAL_KEYS 之一<DD><CODE>keystrokes</CODE> - 用于指定操作的 AWTKeyStroke 的 Set
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../java/lang/IllegalArgumentException.html" title="java.lang 中的类">IllegalArgumentException</A></CODE> - 如果 id 不是 KeyboardFocusManager.FORWARD_TRAVERSAL_KEYS、KeyboardFocusManager.BACKWARD_TRAVERSAL_KEYS、KeyboardFocusManager.UP_CYCLE_TRAVERSAL_KEYS 或 KeyboardFocusManager.DOWN_CYCLE_TRAVERSAL_KEYS 之一；或者 keystroke 中包含 null；或者 keystroke 中的任何 Object 都不是 AWTKeyStroke；或者任何 keystroke 都表示一个 KEY_TYPED 事件；或者任何 keystroke 总是映射到此 Container 的另一个焦点遍历操作<DT><B>从以下版本开始：</B></DT>
  <DD>1.4</DD>
<DT><B>另请参见：</B><DD><A HREF="../../java/awt/Container.html#getFocusTraversalKeys(int)"><CODE>getFocusTraversalKeys(int)</CODE></A>, 
<A HREF="../../java/awt/KeyboardFocusManager.html#FORWARD_TRAVERSAL_KEYS"><CODE>KeyboardFocusManager.FORWARD_TRAVERSAL_KEYS</CODE></A>, 
<A HREF="../../java/awt/KeyboardFocusManager.html#BACKWARD_TRAVERSAL_KEYS"><CODE>KeyboardFocusManager.BACKWARD_TRAVERSAL_KEYS</CODE></A>, 
<A HREF="../../java/awt/KeyboardFocusManager.html#UP_CYCLE_TRAVERSAL_KEYS"><CODE>KeyboardFocusManager.UP_CYCLE_TRAVERSAL_KEYS</CODE></A>, 
<A HREF="../../java/awt/KeyboardFocusManager.html#DOWN_CYCLE_TRAVERSAL_KEYS"><CODE>KeyboardFocusManager.DOWN_CYCLE_TRAVERSAL_KEYS</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="getFocusTraversalKeys(int)"><!-- --></A><H3>
getFocusTraversalKeys</H3>
<PRE>
public <A HREF="../../java/util/Set.html" title="java.util 中的接口">Set</A>&lt;<A HREF="../../java/awt/AWTKeyStroke.html" title="java.awt 中的类">AWTKeyStroke</A>&gt; <B>getFocusTraversalKeys</B>(int&nbsp;id)</PRE>
<DL>
<DD>为此 Container 的给定遍历操作返回焦点遍历键的 Set。（有关每个键的完整描述，请参阅 <code>setFocusTraversalKeys</code>。）
 <p>
如果没有为此 Container 明确定义了遍历键的 Set，则返回此 Container 的父 Set。如果没有为此 Container 的任何祖先明确定义 Set，则返回当前 KeyboardFocusManager 的默认 Set。
<P>
<DD><DL>
<DT><B>覆盖：</B><DD>类 <CODE><A HREF="../../java/awt/Component.html" title="java.awt 中的类">Component</A></CODE> 中的 <CODE><A HREF="../../java/awt/Component.html#getFocusTraversalKeys(int)">getFocusTraversalKeys</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>参数：</B><DD><CODE>id</CODE> - KeyboardFocusManager.FORWARD_TRAVERSAL_KEYS、KeyboardFocusManager.BACKWARD_TRAVERSAL_KEYS、KeyboardFocusManager.UP_CYCLE_TRAVERSAL_KEYS 或 KeyboardFocusManager.DOWN_CYCLE_TRAVERSAL_KEYS 之一
<DT><B>返回：</B><DD>用于指定操作的 AWTKeyStrokes 的 Set。此 Set 将是不可修改的，并且可能是空的。从不返回 null。
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../java/lang/IllegalArgumentException.html" title="java.lang 中的类">IllegalArgumentException</A></CODE> - 如果 id 不是 KeyboardFocusManager.FORWARD_TRAVERSAL_KEYS、KeyboardFocusManager.BACKWARD_TRAVERSAL_KEYS、KeyboardFocusManager.UP_CYCLE_TRAVERSAL_KEYS 或 KeyboardFocusManager.DOWN_CYCLE_TRAVERSAL_KEYS 之一<DT><B>从以下版本开始：</B></DT>
  <DD>1.4</DD>
<DT><B>另请参见：</B><DD><A HREF="../../java/awt/Container.html#setFocusTraversalKeys(int, java.util.Set)"><CODE>setFocusTraversalKeys(int, java.util.Set<? extends java.awt.AWTKeyStroke>)</CODE></A>, 
<A HREF="../../java/awt/KeyboardFocusManager.html#FORWARD_TRAVERSAL_KEYS"><CODE>KeyboardFocusManager.FORWARD_TRAVERSAL_KEYS</CODE></A>, 
<A HREF="../../java/awt/KeyboardFocusManager.html#BACKWARD_TRAVERSAL_KEYS"><CODE>KeyboardFocusManager.BACKWARD_TRAVERSAL_KEYS</CODE></A>, 
<A HREF="../../java/awt/KeyboardFocusManager.html#UP_CYCLE_TRAVERSAL_KEYS"><CODE>KeyboardFocusManager.UP_CYCLE_TRAVERSAL_KEYS</CODE></A>, 
<A HREF="../../java/awt/KeyboardFocusManager.html#DOWN_CYCLE_TRAVERSAL_KEYS"><CODE>KeyboardFocusManager.DOWN_CYCLE_TRAVERSAL_KEYS</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="areFocusTraversalKeysSet(int)"><!-- --></A><H3>
areFocusTraversalKeysSet</H3>
<PRE>
public boolean <B>areFocusTraversalKeysSet</B>(int&nbsp;id)</PRE>
<DL>
<DD>返回是否已经为此 Container 明确定义了用于给定焦点遍历操作的焦点遍历键的 Set。如果此方法返回 <code>false</code>，则此 Container 从一个祖先或当前 KeyboardFocusManager 那里继承 Set。
<P>
<DD><DL>
<DT><B>覆盖：</B><DD>类 <CODE><A HREF="../../java/awt/Component.html" title="java.awt 中的类">Component</A></CODE> 中的 <CODE><A HREF="../../java/awt/Component.html#areFocusTraversalKeysSet(int)">areFocusTraversalKeysSet</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>参数：</B><DD><CODE>id</CODE> - KeyboardFocusManager.FORWARD_TRAVERSAL_KEYS、KeyboardFocusManager.BACKWARD_TRAVERSAL_KEYS、KeyboardFocusManager.UP_CYCLE_TRAVERSAL_KEYS 或 KeyboardFocusManager.DOWN_CYCLE_TRAVERSAL_KEYS 之一
<DT><B>返回：</B><DD>如果已经为此 Component 明确定义了用于给定焦点遍历操作的焦点遍历键的 Set，则返回 <code>true</code>；否则返回 <code>false</code>。
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../java/lang/IllegalArgumentException.html" title="java.lang 中的类">IllegalArgumentException</A></CODE> - 如果 id 不是 KeyboardFocusManager.FORWARD_TRAVERSAL_KEYS、KeyboardFocusManager.BACKWARD_TRAVERSAL_KEYS、KeyboardFocusManager.UP_CYCLE_TRAVERSAL_KEYS 或 KeyboardFocusManager.DOWN_CYCLE_TRAVERSAL_KEYS 之一<DT><B>从以下版本开始：</B></DT>
  <DD>1.4</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="isFocusCycleRoot(java.awt.Container)"><!-- --></A><H3>
isFocusCycleRoot</H3>
<PRE>
public boolean <B>isFocusCycleRoot</B>(<A HREF="../../java/awt/Container.html" title="java.awt 中的类">Container</A>&nbsp;container)</PRE>
<DL>
<DD>返回指定的 Container 是否是此 Container 的焦点遍历循环的焦点循环根。每个焦点遍历循环只有一个焦点循环根，并且不是焦点循环根的每个 Container 只属于一个焦点遍历循环。那些是焦点循环根的容器属于两个循环：一个根植于 Container 自身中，另一个根植于此 Container 的最近的焦点循环根祖先中。在这种情况下，对于这两种 Container，此方法都将返回 <code>true</code>。
<P>
<DD><DL>
<DT><B>覆盖：</B><DD>类 <CODE><A HREF="../../java/awt/Component.html" title="java.awt 中的类">Component</A></CODE> 中的 <CODE><A HREF="../../java/awt/Component.html#isFocusCycleRoot(java.awt.Container)">isFocusCycleRoot</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>参数：</B><DD><CODE>container</CODE> - 要测试的 Container
<DT><B>返回：</B><DD>如果指定 Container 是此 Container 的一个焦点循环根，则返回 <code>true</code>；否则返回 <code>false</code><DT><B>从以下版本开始：</B></DT>
  <DD>1.4</DD>
<DT><B>另请参见：</B><DD><A HREF="../../java/awt/Container.html#isFocusCycleRoot()"><CODE>isFocusCycleRoot()</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="transferFocusBackward()"><!-- --></A><H3>
transferFocusBackward</H3>
<PRE>
public void <B>transferFocusBackward</B>()</PRE>
<DL>
<DD><B>从类 <CODE><A HREF="../../java/awt/Component.html#transferFocusBackward()">Component</A></CODE> 复制的描述</B></DD>
<DD>将焦点转移到前一个组件，就好像此 Component 曾是焦点所有者。
<P>
<DD><DL>
<DT><B>覆盖：</B><DD>类 <CODE><A HREF="../../java/awt/Component.html" title="java.awt 中的类">Component</A></CODE> 中的 <CODE><A HREF="../../java/awt/Component.html#transferFocusBackward()">transferFocusBackward</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>另请参见：</B><DD><A HREF="../../java/awt/Component.html#requestFocus()"><CODE>Component.requestFocus()</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="setFocusTraversalPolicy(java.awt.FocusTraversalPolicy)"><!-- --></A><H3>
setFocusTraversalPolicy</H3>
<PRE>
public void <B>setFocusTraversalPolicy</B>(<A HREF="../../java/awt/FocusTraversalPolicy.html" title="java.awt 中的类">FocusTraversalPolicy</A>&nbsp;policy)</PRE>
<DL>
<DD>如果此 Container 是一个焦点循环根，则设置将管理此 Container 的子代的键盘遍历的焦点遍历策略。如果参数为 null，则此 Container 将继承其焦点循环根祖先的策略。如果参数为非 null 值，则此策略将由所有焦点循环根的子组件继承，这些子组件没有自己的键盘遍历策略（它们将以递归方式管理其焦点循环根的子组件）。
 <p>
如果此 Container 不是一个焦点循环根，要记得该策略，但直到此 Container 成为焦点循环根，此 Container 或其他任何 Container 才可以使用或继承此策略。
<P>
<DD><DL>
<DT><B>参数：</B><DD><CODE>policy</CODE> - 此 Container 的新的焦点遍历策略<DT><B>从以下版本开始：</B></DT>
  <DD>1.4</DD>
<DT><B>另请参见：</B><DD><A HREF="../../java/awt/Container.html#getFocusTraversalPolicy()"><CODE>getFocusTraversalPolicy()</CODE></A>, 
<A HREF="../../java/awt/Container.html#setFocusCycleRoot(boolean)"><CODE>setFocusCycleRoot(boolean)</CODE></A>, 
<A HREF="../../java/awt/Container.html#isFocusCycleRoot(java.awt.Container)"><CODE>isFocusCycleRoot(java.awt.Container)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="getFocusTraversalPolicy()"><!-- --></A><H3>
getFocusTraversalPolicy</H3>
<PRE>
public <A HREF="../../java/awt/FocusTraversalPolicy.html" title="java.awt 中的类">FocusTraversalPolicy</A> <B>getFocusTraversalPolicy</B>()</PRE>
<DL>
<DD>返回焦点遍历策略，用于管理此 Container 子组件的键盘遍历；如果此 Container 不是一个焦点循环根，则返回 null。如果没有明确为此 Container 设置遍历策略，则返回此 Container 的焦点循环根祖先的策略。
<P>
<DD><DL>

<DT><B>返回：</B><DD>此 Container 的焦点遍历策略，如果此 Container 不是一个焦点循环根，则返回 null。<DT><B>从以下版本开始：</B></DT>
  <DD>1.4</DD>
<DT><B>另请参见：</B><DD><A HREF="../../java/awt/Container.html#setFocusTraversalPolicy(java.awt.FocusTraversalPolicy)"><CODE>setFocusTraversalPolicy(java.awt.FocusTraversalPolicy)</CODE></A>, 
<A HREF="../../java/awt/Container.html#setFocusCycleRoot(boolean)"><CODE>setFocusCycleRoot(boolean)</CODE></A>, 
<A HREF="../../java/awt/Container.html#isFocusCycleRoot(java.awt.Container)"><CODE>isFocusCycleRoot(java.awt.Container)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="isFocusTraversalPolicySet()"><!-- --></A><H3>
isFocusTraversalPolicySet</H3>
<PRE>
public boolean <B>isFocusTraversalPolicySet</B>()</PRE>
<DL>
<DD>返回是否为此 Container 明确设置焦点遍历策略。如果此方法返回 <code>false</code>，则此 Container 将从一个祖先那里继承其焦点遍历策略。
<P>
<DD><DL>

<DT><B>返回：</B><DD>如果已经明确为此 Container 设置焦点遍历策略，则返回 <code>true</code>；否则返回 <code>false</code>。<DT><B>从以下版本开始：</B></DT>
  <DD>1.4</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="setFocusCycleRoot(boolean)"><!-- --></A><H3>
setFocusCycleRoot</H3>
<PRE>
public void <B>setFocusCycleRoot</B>(boolean&nbsp;focusCycleRoot)</PRE>
<DL>
<DD>设置此 Container 是否是某个焦点遍历循环的根。一旦焦点进入某个遍历循环，它通常无法通过焦点遍历离开，除非按下向上循环键或向下循环键之一。普通遍历被限定于此 Container，该 Container 的所有子代并不是下级焦点循环根的子代。注意，FocusTraversalPolicy 可能屈服于这些约束。例如，ContainerOrderFocusTraversalPolicy 支持隐式的向下循环遍历。
 <p>
指定此 Container 子代的遍历顺序的替代方法是<a href="doc-files/FocusSpec.html#FocusTraversalPolicyProviders">焦点遍历策略提供者</a>。
<P>
<DD><DL>
<DT><B>参数：</B><DD><CODE>focusCycleRoot</CODE> - 指示此 Container 是否是某个焦点遍历循环的根<DT><B>从以下版本开始：</B></DT>
  <DD>1.4</DD>
<DT><B>另请参见：</B><DD><A HREF="../../java/awt/Container.html#isFocusCycleRoot()"><CODE>isFocusCycleRoot()</CODE></A>, 
<A HREF="../../java/awt/Container.html#setFocusTraversalPolicy(java.awt.FocusTraversalPolicy)"><CODE>setFocusTraversalPolicy(java.awt.FocusTraversalPolicy)</CODE></A>, 
<A HREF="../../java/awt/Container.html#getFocusTraversalPolicy()"><CODE>getFocusTraversalPolicy()</CODE></A>, 
<A HREF="../../java/awt/ContainerOrderFocusTraversalPolicy.html" title="java.awt 中的类"><CODE>ContainerOrderFocusTraversalPolicy</CODE></A>, 
<A HREF="../../java/awt/Container.html#setFocusTraversalPolicyProvider(boolean)"><CODE>setFocusTraversalPolicyProvider(boolean)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="isFocusCycleRoot()"><!-- --></A><H3>
isFocusCycleRoot</H3>
<PRE>
public boolean <B>isFocusCycleRoot</B>()</PRE>
<DL>
<DD>返回此 Container 是否是某个焦点遍历循环的根。一旦焦点进入某个遍历循环，它通常无法通过焦点遍历离开，除非按下向上循环键或向下循环键之一。普通遍历被限定于此 Container，该 Container 的所有子代并不是下级焦点循环根的子代。注意，FocusTraversalPolicy 可能屈服于这些约束。例如，ContainerOrderFocusTraversalPolicy 支持隐式的向下循环遍历。
<P>
<DD><DL>

<DT><B>返回：</B><DD>此 Container 是否是某个焦点遍历循环的根<DT><B>从以下版本开始：</B></DT>
  <DD>1.4</DD>
<DT><B>另请参见：</B><DD><A HREF="../../java/awt/Container.html#setFocusCycleRoot(boolean)"><CODE>setFocusCycleRoot(boolean)</CODE></A>, 
<A HREF="../../java/awt/Container.html#setFocusTraversalPolicy(java.awt.FocusTraversalPolicy)"><CODE>setFocusTraversalPolicy(java.awt.FocusTraversalPolicy)</CODE></A>, 
<A HREF="../../java/awt/Container.html#getFocusTraversalPolicy()"><CODE>getFocusTraversalPolicy()</CODE></A>, 
<A HREF="../../java/awt/ContainerOrderFocusTraversalPolicy.html" title="java.awt 中的类"><CODE>ContainerOrderFocusTraversalPolicy</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="setFocusTraversalPolicyProvider(boolean)"><!-- --></A><H3>
setFocusTraversalPolicyProvider</H3>
<PRE>
public final void <B>setFocusTraversalPolicyProvider</B>(boolean&nbsp;provider)</PRE>
<DL>
<DD>设置是否将用此容器提供焦点遍历策略。将使用把该属性设置为 <code>true</code> 的容器来获取焦点遍历策略，而不是获取最近的焦点循环根的祖先。
<P>
<DD><DL>
<DT><B>参数：</B><DD><CODE>provider</CODE> - 指示是否将用此容器提供焦点遍历策略<DT><B>从以下版本开始：</B></DT>
  <DD>1.5</DD>
<DT><B>另请参见：</B><DD><A HREF="../../java/awt/Container.html#setFocusTraversalPolicy(java.awt.FocusTraversalPolicy)"><CODE>setFocusTraversalPolicy(java.awt.FocusTraversalPolicy)</CODE></A>, 
<A HREF="../../java/awt/Container.html#getFocusTraversalPolicy()"><CODE>getFocusTraversalPolicy()</CODE></A>, 
<A HREF="../../java/awt/Container.html#isFocusTraversalPolicyProvider()"><CODE>isFocusTraversalPolicyProvider()</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="isFocusTraversalPolicyProvider()"><!-- --></A><H3>
isFocusTraversalPolicyProvider</H3>
<PRE>
public final boolean <B>isFocusTraversalPolicyProvider</B>()</PRE>
<DL>
<DD>返回此容器是否提供焦点遍历策略。如果将此属性设置为 <code>true</code>，那么在键盘焦点管理器搜索容器层次结构来查找焦点遍历策略，且在其他任何将此属性设置为 true 的容器之前遇到此容器或焦点循环根的时候，将使用其焦点遍历策略，而不是使用焦点循环根的策略。
<P>
<DD><DL>

<DT><B>返回：</B><DD>如果此容器提供焦点遍历策略，则返回 <code>true</code>，否则返回 <code>false</code><DT><B>从以下版本开始：</B></DT>
  <DD>1.5</DD>
<DT><B>另请参见：</B><DD><A HREF="../../java/awt/Container.html#setFocusTraversalPolicy(java.awt.FocusTraversalPolicy)"><CODE>setFocusTraversalPolicy(java.awt.FocusTraversalPolicy)</CODE></A>, 
<A HREF="../../java/awt/Container.html#getFocusTraversalPolicy()"><CODE>getFocusTraversalPolicy()</CODE></A>, 
<A HREF="../../java/awt/Container.html#setFocusCycleRoot(boolean)"><CODE>setFocusCycleRoot(boolean)</CODE></A>, 
<A HREF="../../java/awt/Container.html#setFocusTraversalPolicyProvider(boolean)"><CODE>setFocusTraversalPolicyProvider(boolean)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="transferFocusDownCycle()"><!-- --></A><H3>
transferFocusDownCycle</H3>
<PRE>
public void <B>transferFocusDownCycle</B>()</PRE>
<DL>
<DD>将焦点向下传输一个焦点遍历循环。如果此 Container 是一个焦点循环根，则将焦点的所有者设置为此 Container 的将成为焦点的默认 Component，并将当前焦点循环根设置为此 Container。如果此 Container 不是一个焦点循环根，则不会发生焦点遍历操作。
<P>
<DD><DL>
<DT><B>从以下版本开始：</B></DT>
  <DD>1.4</DD>
<DT><B>另请参见：</B><DD><A HREF="../../java/awt/Component.html#requestFocus()"><CODE>Component.requestFocus()</CODE></A>, 
<A HREF="../../java/awt/Container.html#isFocusCycleRoot(java.awt.Container)"><CODE>isFocusCycleRoot(java.awt.Container)</CODE></A>, 
<A HREF="../../java/awt/Container.html#setFocusCycleRoot(boolean)"><CODE>setFocusCycleRoot(boolean)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="applyComponentOrientation(java.awt.ComponentOrientation)"><!-- --></A><H3>
applyComponentOrientation</H3>
<PRE>
public void <B>applyComponentOrientation</B>(<A HREF="../../java/awt/ComponentOrientation.html" title="java.awt 中的类">ComponentOrientation</A>&nbsp;o)</PRE>
<DL>
<DD>设置此容器和其中包含的所有组件的 <code>ComponentOrientation</code> 属性。
<P>
<DD><DL>
<DT><B>覆盖：</B><DD>类 <CODE><A HREF="../../java/awt/Component.html" title="java.awt 中的类">Component</A></CODE> 中的 <CODE><A HREF="../../java/awt/Component.html#applyComponentOrientation(java.awt.ComponentOrientation)">applyComponentOrientation</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>参数：</B><DD><CODE>o</CODE> - 此容器的新组件的方向性和其中包含组件的方向性。
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../java/lang/NullPointerException.html" title="java.lang 中的类">NullPointerException</A></CODE> - 如果 <code>orientation</code> 为 null。<DT><B>从以下版本开始：</B></DT>
  <DD>1.4</DD>
<DT><B>另请参见：</B><DD><A HREF="../../java/awt/Component.html#setComponentOrientation(java.awt.ComponentOrientation)"><CODE>Component.setComponentOrientation(java.awt.ComponentOrientation)</CODE></A>, 
<A HREF="../../java/awt/Component.html#getComponentOrientation()"><CODE>Component.getComponentOrientation()</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="addPropertyChangeListener(java.beans.PropertyChangeListener)"><!-- --></A><H3>
addPropertyChangeListener</H3>
<PRE>
public void <B>addPropertyChangeListener</B>(<A HREF="../../java/beans/PropertyChangeListener.html" title="java.beans 中的接口">PropertyChangeListener</A>&nbsp;listener)</PRE>
<DL>
<DD>将一个 PropertyChangeListener 添加到侦听器列表中。该侦听器是为此类的所有边界属性注册的，其中包括以下属性：
 <ul>
<li>此 Container 的字体 (&quot;font&quot;)</li>
<li>此 Container 的背景色 (&quot;background&quot;)</li>
<li>此 Container 的前景色 (&quot;foreground&quot;)</li>
<li>此 Container 的可聚焦性 (&quot;focusable&quot;)</li>
<li>此 Container 的焦点遍历键支持的状态 (&quot;focusTraversalKeysEnabled&quot;)</li>
<li>此 Container 的 FORWARD_TRAVERSAL_KEYS 的 Set (&quot;forwardFocusTraversalKeys&quot;)</li>
<li>此 Container 的 BACKWARD_TRAVERSAL_KEYS 的 Set (&quot;backwardFocusTraversalKeys&quot;)</li>
<li>此 Container 的 UP_CYCLE_TRAVERSAL_KEYS 的 Set (&quot;upCycleFocusTraversalKeys&quot;)</li>
<li>此 Container 的 DOWN_CYCLE_TRAVERSAL_KEYS 的 Set (&quot;downCycleFocusTraversalKeys&quot;)</li>
<li>此 Container 的焦点遍历策略 (&quot;focusTraversalPolicy&quot;)
        </li>
<li>此 Container 的焦点循环根的状态 (&quot;focusCycleRoot&quot;)</li>
 </ul>
注意，如果此 Container 正继承某个边界属性，那么不会为响应所继承属性中的更改而触发任何事件。
 <p>
如果侦听器为 null，则不会抛出异常，并且不执行任何动作。
<P>
<DD><DL>
<DT><B>覆盖：</B><DD>类 <CODE><A HREF="../../java/awt/Component.html" title="java.awt 中的类">Component</A></CODE> 中的 <CODE><A HREF="../../java/awt/Component.html#addPropertyChangeListener(java.beans.PropertyChangeListener)">addPropertyChangeListener</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>参数：</B><DD><CODE>listener</CODE> - 要添加的 PropertyChangeListener<DT><B>另请参见：</B><DD><A HREF="../../java/awt/Component.html#removePropertyChangeListener(java.beans.PropertyChangeListener)"><CODE>Component.removePropertyChangeListener(java.beans.PropertyChangeListener)</CODE></A>, 
<A HREF="../../java/awt/Container.html#addPropertyChangeListener(java.lang.String, java.beans.PropertyChangeListener)"><CODE>addPropertyChangeListener(java.lang.String,java.beans.PropertyChangeListener)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="addPropertyChangeListener(java.lang.String, java.beans.PropertyChangeListener)"><!-- --></A><H3>
addPropertyChangeListener</H3>
<PRE>
public void <B>addPropertyChangeListener</B>(<A HREF="../../java/lang/String.html" title="java.lang 中的类">String</A>&nbsp;propertyName,
                                      <A HREF="../../java/beans/PropertyChangeListener.html" title="java.beans 中的接口">PropertyChangeListener</A>&nbsp;listener)</PRE>
<DL>
<DD>将一个 PropertyChangeListener 添加到某个指定属性的侦听器列表中。指定的属性可以是用户定义的，或者是以下默认属性之一：
 <ul>
<li>此 Container 的字体 (&quot;font&quot;)</li>
<li>此 Container 的背景色 (&quot;background&quot;)</li>
<li>此 Container 的前景色 (&quot;foreground&quot;)</li>
<li>此 Container 的可聚焦性 (&quot;focusable&quot;)</li>
<li>此 Container 的焦点遍历键支持的状态 (&quot;focusTraversalKeysEnabled&quot;)</li>
<li>此 Container 的 FORWARD_TRAVERSAL_KEYS 的 Set (&quot;forwardFocusTraversalKeys&quot;)</li>
<li>此 Container 的 BACKWARD_TRAVERSAL_KEYS 的 Set (&quot;backwardFocusTraversalKeys&quot;)</li>
<li>此 Container 的 UP_CYCLE_TRAVERSAL_KEYS 的 Set (&quot;upCycleFocusTraversalKeys&quot;)</li>
<li>此 Container 的 DOWN_CYCLE_TRAVERSAL_KEYS 的 Set (&quot;downCycleFocusTraversalKeys&quot;)</li>
<li>此 Container 的焦点遍历策略 (&quot;focusTraversalPolicy&quot;)
        </li>
<li>此 Container 的焦点循环根的状态 (&quot;focusCycleRoot&quot;)</li>
<li>此 Container 的焦点遍历策略提供者的状态 (&quot;focusTraversalPolicyProvider&quot;)</li>
<li>此 Container 的焦点遍历策略提供者的状态 (&quot;focusTraversalPolicyProvider&quot;)</li>
 </ul>
注意，如果此 Container 正继承某个边界属性，那么不会为响应所继承属性中的更改而触发任何事件。
 <p>
如果侦听器为 null，则不会抛出异常，并且不执行任何动作。
<P>
<DD><DL>
<DT><B>覆盖：</B><DD>类 <CODE><A HREF="../../java/awt/Component.html" title="java.awt 中的类">Component</A></CODE> 中的 <CODE><A HREF="../../java/awt/Component.html#addPropertyChangeListener(java.lang.String, java.beans.PropertyChangeListener)">addPropertyChangeListener</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>参数：</B><DD><CODE>propertyName</CODE> - 上面列出的属性名称之一<DD><CODE>listener</CODE> - 要添加的 PropertyChangeListener<DT><B>另请参见：</B><DD><A HREF="../../java/awt/Container.html#addPropertyChangeListener(java.beans.PropertyChangeListener)"><CODE>addPropertyChangeListener(java.beans.PropertyChangeListener)</CODE></A>, 
<A HREF="../../java/awt/Component.html#removePropertyChangeListener(java.beans.PropertyChangeListener)"><CODE>Component.removePropertyChangeListener(java.beans.PropertyChangeListener)</CODE></A></DL>
</DD>
</DL>
<!-- ========= END OF CLASS DATA ========= -->
<HR>


<!-- ======= START OF BOTTOM NAVBAR ====== -->
<A NAME="navbar_bottom"><!-- --></A>
<A HREF="#skip-navbar_bottom" title="跳过导航链接"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>概述</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>软件包</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>类</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/Container.html"><FONT CLASS="NavBarFont1"><B>使用</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>树</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>已过时</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>索引</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../help-doc.html"><FONT CLASS="NavBarFont1"><B>帮助</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
<b>Java<sup><font size=-2>TM</font></sup>&nbsp;Platform<br>Standard&nbsp;Ed. 6</b></EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../java/awt/CompositeContext.html" title="java.awt 中的接口"><B>上一个类</B></A>&nbsp;
&nbsp;<A HREF="../../java/awt/Container.AccessibleAWTContainer.html" title="java.awt 中的类"><B>下一个类</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../index.html?java/awt/Container.html" target="_top"><B>框架</B></A>  &nbsp;
&nbsp;<A HREF="Container.html" target="_top"><B>无框架</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../allclasses-noframe.html"><B>所有类</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../allclasses-noframe.html"><B>所有类</B></A>
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  摘要：&nbsp;<A HREF="#nested_class_summary">嵌套</A>&nbsp;|&nbsp;<A HREF="#fields_inherited_from_class_java.awt.Component">字段</A>&nbsp;|&nbsp;<A HREF="#constructor_summary">构造方法</A>&nbsp;|&nbsp;<A HREF="#method_summary">方法</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
详细信息：&nbsp;字段&nbsp;|&nbsp;<A HREF="#constructor_detail">构造方法</A>&nbsp;|&nbsp;<A HREF="#method_detail">方法</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_bottom"></A>
<!-- ======== END OF BOTTOM NAVBAR ======= -->

<HR>
<font size="-1"><a href="http://bugs.sun.com/services/bugreport/index.jsp">提交错误或意见</a><br>有关更多的 API 参考资料和开发人员文档，请参阅 <a href="http://java.sun.com/javase/6/webnotes/devdocs-vs-specs.html">Java SE 开发人员文档</a>。该文档包含更详细的、面向开发人员的描述，以及总体概述、术语定义、使用技巧和工作代码示例。 <p>版权所有 2007 Sun Microsystems, Inc. 保留所有权利。 请遵守<a href="http://java.sun.com/javase/6/docs/legal/license.html">许可证条款</a>。另请参阅<a href="http://java.sun.com/docs/redist.html">文档重新分发政策</a>。</font>
</BODY>
</HTML>
