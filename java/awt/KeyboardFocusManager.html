<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc (build 1.6.0-beta2) on Mon Mar 19 18:18:11 CST 2007 -->
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
<TITLE>
KeyboardFocusManager (Java Platform SE 6)
</TITLE>

<META NAME="date" CONTENT="2007-03-19">

<LINK REL ="stylesheet" TYPE="text/css" HREF="../../stylesheet.css" TITLE="Style">

<SCRIPT type="text/javascript">
function windowTitle()
{
    if (location.href.indexOf('is-external=true') == -1) {
        parent.document.title="KeyboardFocusManager (Java Platform SE 6)";
    }
}
</SCRIPT>
<NOSCRIPT>
</NOSCRIPT>

</HEAD>

<BODY BGCOLOR="white" onload="windowTitle();">
<HR>


<!-- ========= START OF TOP NAVBAR ======= -->
<A NAME="navbar_top"><!-- --></A>
<A HREF="#skip-navbar_top" title="跳过导航链接"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>概述</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>软件包</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>类</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/KeyboardFocusManager.html"><FONT CLASS="NavBarFont1"><B>使用</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>树</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>已过时</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>索引</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../help-doc.html"><FONT CLASS="NavBarFont1"><B>帮助</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
<b>Java<sup><font size=-2>TM</font></sup>&nbsp;Platform<br>Standard&nbsp;Ed. 6</b></EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../java/awt/JobAttributes.SidesType.html" title="java.awt 中的类"><B>上一个类</B></A>&nbsp;
&nbsp;<A HREF="../../java/awt/KeyEventDispatcher.html" title="java.awt 中的接口"><B>下一个类</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../index.html?java/awt/KeyboardFocusManager.html" target="_top"><B>框架</B></A>  &nbsp;
&nbsp;<A HREF="KeyboardFocusManager.html" target="_top"><B>无框架</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../allclasses-noframe.html"><B>所有类</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../allclasses-noframe.html"><B>所有类</B></A>
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  摘要：&nbsp;嵌套&nbsp;|&nbsp;<A HREF="#field_summary">字段</A>&nbsp;|&nbsp;<A HREF="#constructor_summary">构造方法</A>&nbsp;|&nbsp;<A HREF="#method_summary">方法</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
详细信息：&nbsp;<A HREF="#field_detail">字段</A>&nbsp;|&nbsp;<A HREF="#constructor_detail">构造方法</A>&nbsp;|&nbsp;<A HREF="#method_detail">方法</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_top"></A>
<!-- ========= END OF TOP NAVBAR ========= -->

<HR>
<!-- ======== START OF CLASS DATA ======== -->
<H2>
<FONT SIZE="-1">
java.awt</FONT>
<BR>
类 KeyboardFocusManager</H2>
<PRE>
<A HREF="../../java/lang/Object.html" title="java.lang 中的类">java.lang.Object</A>
  <IMG SRC="../../resources/inherit.gif" ALT="继承者 "><B>java.awt.KeyboardFocusManager</B>
</PRE>
<DL>
<DT><B>所有已实现的接口：</B> <DD><A HREF="../../java/awt/KeyEventDispatcher.html" title="java.awt 中的接口">KeyEventDispatcher</A>, <A HREF="../../java/awt/KeyEventPostProcessor.html" title="java.awt 中的接口">KeyEventPostProcessor</A></DD>
</DL>
<DL>
<DT><B>直接已知子类：</B> <DD><A HREF="../../java/awt/DefaultKeyboardFocusManager.html" title="java.awt 中的类">DefaultKeyboardFocusManager</A></DD>
</DL>
<HR>
<DL>
<DT><PRE>public abstract class <B>KeyboardFocusManager</B><DT>extends <A HREF="../../java/lang/Object.html" title="java.lang 中的类">Object</A><DT>implements <A HREF="../../java/awt/KeyEventDispatcher.html" title="java.awt 中的接口">KeyEventDispatcher</A>, <A HREF="../../java/awt/KeyEventPostProcessor.html" title="java.awt 中的接口">KeyEventPostProcessor</A></DL>
</PRE>

<P>
KeyboardFocusManager 负责管理激活状态的聚焦 Window 和当前焦点所有者。焦点所有者的定义是：应用程序中的 Component，通常接收用户生成的所有 KeyEvent。聚焦 Window 指本身就是（或者包含）焦点所有者的 Window。只有 Frame 或 Dialog 才能成为活动 Window。本机的窗口操作系统可能使用特殊装饰（如高亮显示标题栏）来表示活动 Window 或其子窗口。活动 Window 要么是聚焦 Window，要么是作为聚焦 Window 所有者的第一个 Frame 或 Dialog。
 <p>
KeyboardFocusManager 既是一个用于查询焦点所有者并启动焦点更改的客户端代码的集中位置，同时又是一个用于所有 FocusEvent、与焦点相关的 WindowEvent 和 KeyEvent 的调度程序。
 <p>
有些浏览器将使用不同代码基数的 applet 划分为单独的上下文，并在这些上下文之间建墙分隔。在此方案中，每个上下文都将具有一个 KeyboardFocusManager。其他浏览器将所有 applet 置于同一个上下文中，这意味着仅存在一个用于所有 applet 的全局 KeyboardFocusManager。此行为是依赖于实现的。请参考浏览器文档以获取更多信息。然而，不管可能有多少上下文，每个 ClassLoader 的焦点所有者、聚焦 Window 或活动 Window 只能有一个。
 <p>
请参见 <a href="http://java.sun.com/docs/books/tutorial/uiswing/misc/focus.html">How to Use the Focus Subsystem</a>（<em>The Java Tutorial</em> 的一节）和 <a href="../../java/awt/doc-files/FocusSpec.html">Focus Specification</a> 以获取更多信息。
<P>

<P>
<DL>
<DT><B>从以下版本开始：</B></DT>
  <DD>1.4</DD>
<DT><B>另请参见：</B><DD><A HREF="../../java/awt/Window.html" title="java.awt 中的类"><CODE>Window</CODE></A>, 
<A HREF="../../java/awt/Frame.html" title="java.awt 中的类"><CODE>Frame</CODE></A>, 
<A HREF="../../java/awt/Dialog.html" title="java.awt 中的类"><CODE>Dialog</CODE></A>, 
<A HREF="../../java/awt/event/FocusEvent.html" title="java.awt.event 中的类"><CODE>FocusEvent</CODE></A>, 
<A HREF="../../java/awt/event/WindowEvent.html" title="java.awt.event 中的类"><CODE>WindowEvent</CODE></A>, 
<A HREF="../../java/awt/event/KeyEvent.html" title="java.awt.event 中的类"><CODE>KeyEvent</CODE></A></DL>
<HR>

<P>
<!-- =========== FIELD SUMMARY =========== -->

<A NAME="field_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>字段摘要</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/awt/KeyboardFocusManager.html#BACKWARD_TRAVERSAL_KEYS">BACKWARD_TRAVERSAL_KEYS</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Backward 焦点遍历键的标识符。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/awt/KeyboardFocusManager.html#DOWN_CYCLE_TRAVERSAL_KEYS">DOWN_CYCLE_TRAVERSAL_KEYS</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Down Cycle 焦点遍历键的标识符。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/awt/KeyboardFocusManager.html#FORWARD_TRAVERSAL_KEYS">FORWARD_TRAVERSAL_KEYS</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Forward 焦点遍历键的标识符。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/awt/KeyboardFocusManager.html#UP_CYCLE_TRAVERSAL_KEYS">UP_CYCLE_TRAVERSAL_KEYS</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Up Cycle 焦点遍历键的标识符。</TD>
</TR>
</TABLE>
&nbsp;
<!-- ======== CONSTRUCTOR SUMMARY ======== -->

<A NAME="constructor_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>构造方法摘要</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../java/awt/KeyboardFocusManager.html#KeyboardFocusManager()">KeyboardFocusManager</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;初始化 KeyboardFocusManager。</TD>
</TR>
</TABLE>
&nbsp;
<!-- ========== METHOD SUMMARY =========== -->

<A NAME="method_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>方法摘要</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/awt/KeyboardFocusManager.html#addKeyEventDispatcher(java.awt.KeyEventDispatcher)">addKeyEventDispatcher</A></B>(<A HREF="../../java/awt/KeyEventDispatcher.html" title="java.awt 中的接口">KeyEventDispatcher</A>&nbsp;dispatcher)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;将 KeyEventDispatcher 添加到此 KeyboardFocusManager 的调度程序链中。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/awt/KeyboardFocusManager.html#addKeyEventPostProcessor(java.awt.KeyEventPostProcessor)">addKeyEventPostProcessor</A></B>(<A HREF="../../java/awt/KeyEventPostProcessor.html" title="java.awt 中的接口">KeyEventPostProcessor</A>&nbsp;processor)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;将 KeyEventPostProcessor 添加到此 KeyboardFocusManager 的后处理器链中。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/awt/KeyboardFocusManager.html#addPropertyChangeListener(java.beans.PropertyChangeListener)">addPropertyChangeListener</A></B>(<A HREF="../../java/beans/PropertyChangeListener.html" title="java.beans 中的接口">PropertyChangeListener</A>&nbsp;listener)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;将 PropertyChangeListener 添加到侦听器列表。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/awt/KeyboardFocusManager.html#addPropertyChangeListener(java.lang.String, java.beans.PropertyChangeListener)">addPropertyChangeListener</A></B>(<A HREF="../../java/lang/String.html" title="java.lang 中的类">String</A>&nbsp;propertyName,
                          <A HREF="../../java/beans/PropertyChangeListener.html" title="java.beans 中的接口">PropertyChangeListener</A>&nbsp;listener)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;将 PropertyChangeListener 添加到特定属性的侦听器列表。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/awt/KeyboardFocusManager.html#addVetoableChangeListener(java.lang.String, java.beans.VetoableChangeListener)">addVetoableChangeListener</A></B>(<A HREF="../../java/lang/String.html" title="java.lang 中的类">String</A>&nbsp;propertyName,
                          <A HREF="../../java/beans/VetoableChangeListener.html" title="java.beans 中的接口">VetoableChangeListener</A>&nbsp;listener)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;将 VetoableChangeListener 添加到特定属性的侦听器列表。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/awt/KeyboardFocusManager.html#addVetoableChangeListener(java.beans.VetoableChangeListener)">addVetoableChangeListener</A></B>(<A HREF="../../java/beans/VetoableChangeListener.html" title="java.beans 中的接口">VetoableChangeListener</A>&nbsp;listener)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;将 VetoableChangeListener 添加到侦听器列表。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/awt/KeyboardFocusManager.html#clearGlobalFocusOwner()">clearGlobalFocusOwner</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在 Java 和本机级别清除全局焦点所有者。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected abstract &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/awt/KeyboardFocusManager.html#dequeueKeyEvents(long, java.awt.Component)">dequeueKeyEvents</A></B>(long&nbsp;after,
                 <A HREF="../../java/awt/Component.html" title="java.awt 中的类">Component</A>&nbsp;untilFocused)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由 AWT 调用以通知 KeyboardFocusManager 应该取消延迟指派 KeyEvent。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected abstract &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/awt/KeyboardFocusManager.html#discardKeyEvents(java.awt.Component)">discardKeyEvents</A></B>(<A HREF="../../java/awt/Component.html" title="java.awt 中的类">Component</A>&nbsp;comp)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由 AWT 调用以通知 KeyboardFocusManager 应该取消延迟指派 KeyEvent。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/awt/KeyboardFocusManager.html#dispatchEvent(java.awt.AWTEvent)">dispatchEvent</A></B>(<A HREF="../../java/awt/AWTEvent.html" title="java.awt 中的类">AWTEvent</A>&nbsp;e)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;AWT 事件调度程序可以调用此方法，请求当前的 KeyboardFocusManager 为其指派指定的事件。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/awt/KeyboardFocusManager.html#dispatchKeyEvent(java.awt.event.KeyEvent)">dispatchKeyEvent</A></B>(<A HREF="../../java/awt/event/KeyEvent.html" title="java.awt.event 中的类">KeyEvent</A>&nbsp;e)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通常情况下，如果该指派程序链中的其他 KeyEventDispatcher 没有指派 KeyEvent 或者没有注册其他 KeyEventDispatcher，则 <code>dispatchEvent</code> 将调用此方法。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/awt/KeyboardFocusManager.html#downFocusCycle()">downFocusCycle</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当且仅当当前焦点所有者是一个作为焦点循环根的 Container 时，从当前焦点所有者将焦点下移一个焦点遍历循环。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/awt/KeyboardFocusManager.html#downFocusCycle(java.awt.Container)">downFocusCycle</A></B>(<A HREF="../../java/awt/Container.html" title="java.awt 中的类">Container</A>&nbsp;aContainer)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;将焦点下移一个焦点遍历循环。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected abstract &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/awt/KeyboardFocusManager.html#enqueueKeyEvents(long, java.awt.Component)">enqueueKeyEvents</A></B>(long&nbsp;after,
                 <A HREF="../../java/awt/Component.html" title="java.awt 中的类">Component</A>&nbsp;untilFocused)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在指定的 Component 成为焦点所有者以前由 AWT 调用，以通知 KeyboardFocusManager 延迟指派 KeyEvent。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/awt/KeyboardFocusManager.html#firePropertyChange(java.lang.String, java.lang.Object, java.lang.Object)">firePropertyChange</A></B>(<A HREF="../../java/lang/String.html" title="java.lang 中的类">String</A>&nbsp;propertyName,
                   <A HREF="../../java/lang/Object.html" title="java.lang 中的类">Object</A>&nbsp;oldValue,
                   <A HREF="../../java/lang/Object.html" title="java.lang 中的类">Object</A>&nbsp;newValue)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;激发 PropertyChangeEvent 以响应绑定属性中的更改。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/awt/KeyboardFocusManager.html#fireVetoableChange(java.lang.String, java.lang.Object, java.lang.Object)">fireVetoableChange</A></B>(<A HREF="../../java/lang/String.html" title="java.lang 中的类">String</A>&nbsp;propertyName,
                   <A HREF="../../java/lang/Object.html" title="java.lang 中的类">Object</A>&nbsp;oldValue,
                   <A HREF="../../java/lang/Object.html" title="java.lang 中的类">Object</A>&nbsp;newValue)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;激发 PropertyChangeEvent 以响应可否决属性中的更改。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/awt/KeyboardFocusManager.html#focusNextComponent()">focusNextComponent</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;聚焦当前焦点所有者之后的 Component。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/awt/KeyboardFocusManager.html#focusNextComponent(java.awt.Component)">focusNextComponent</A></B>(<A HREF="../../java/awt/Component.html" title="java.awt 中的类">Component</A>&nbsp;aComponent)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;聚焦 aComponent 之后的 Component，通常基于 FocusTraversalPolicy。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/awt/KeyboardFocusManager.html#focusPreviousComponent()">focusPreviousComponent</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;聚焦当前焦点所有者之前的 Component。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/awt/KeyboardFocusManager.html#focusPreviousComponent(java.awt.Component)">focusPreviousComponent</A></B>(<A HREF="../../java/awt/Component.html" title="java.awt 中的类">Component</A>&nbsp;aComponent)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;聚焦 aComponent 之前的 Component，通常基于 FocusTraversalPolicy。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/awt/Window.html" title="java.awt 中的类">Window</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/awt/KeyboardFocusManager.html#getActiveWindow()">getActiveWindow</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果活动 Window 与调用线程位于同一个上下文中，则返回活动 Window。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/awt/Container.html" title="java.awt 中的类">Container</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/awt/KeyboardFocusManager.html#getCurrentFocusCycleRoot()">getCurrentFocusCycleRoot</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果当前焦点循环根与调用线程位于相同的上下文中，则返回当前焦点循环根。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../java/awt/KeyboardFocusManager.html" title="java.awt 中的类">KeyboardFocusManager</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/awt/KeyboardFocusManager.html#getCurrentKeyboardFocusManager()">getCurrentKeyboardFocusManager</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;返回调用线程上下文的当前 KeyboardFocusManager 实例。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/util/Set.html" title="java.util 中的接口">Set</A>&lt;<A HREF="../../java/awt/AWTKeyStroke.html" title="java.awt 中的类">AWTKeyStroke</A>&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/awt/KeyboardFocusManager.html#getDefaultFocusTraversalKeys(int)">getDefaultFocusTraversalKeys</A></B>(int&nbsp;id)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;返回给定遍历操作的默认焦点遍历键的 Set。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/awt/FocusTraversalPolicy.html" title="java.awt 中的类">FocusTraversalPolicy</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/awt/KeyboardFocusManager.html#getDefaultFocusTraversalPolicy()">getDefaultFocusTraversalPolicy</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;返回默认 FocusTraversalPolicy。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/awt/Window.html" title="java.awt 中的类">Window</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/awt/KeyboardFocusManager.html#getFocusedWindow()">getFocusedWindow</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果聚焦窗口与调用线程位于同一个上下文中，则返回聚焦窗口。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/awt/Component.html" title="java.awt 中的类">Component</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/awt/KeyboardFocusManager.html#getFocusOwner()">getFocusOwner</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果焦点所有者与调用线程位于同一个上下文中，则返回该焦点所有者。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="../../java/awt/Window.html" title="java.awt 中的类">Window</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/awt/KeyboardFocusManager.html#getGlobalActiveWindow()">getGlobalActiveWindow</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;返回活动 Window，即使调用线程处于活动 Window 之外的上下文中。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="../../java/awt/Container.html" title="java.awt 中的类">Container</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/awt/KeyboardFocusManager.html#getGlobalCurrentFocusCycleRoot()">getGlobalCurrentFocusCycleRoot</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;返回当前焦点循环根，即使调用线程处于当前焦点循环根之外的上下文中。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="../../java/awt/Window.html" title="java.awt 中的类">Window</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/awt/KeyboardFocusManager.html#getGlobalFocusedWindow()">getGlobalFocusedWindow</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;返回聚焦 Window，即使调用线程处于聚焦 Window 之外的上下文中。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="../../java/awt/Component.html" title="java.awt 中的类">Component</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/awt/KeyboardFocusManager.html#getGlobalFocusOwner()">getGlobalFocusOwner</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;返回焦点所有者，即使调用线程处于焦点所有者之外的上下文中。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="../../java/awt/Component.html" title="java.awt 中的类">Component</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/awt/KeyboardFocusManager.html#getGlobalPermanentFocusOwner()">getGlobalPermanentFocusOwner</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;返回持久焦点所有者，即使调用线程处于该持久焦点所有者之外的上下文中。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="../../java/util/List.html" title="java.util 中的接口">List</A>&lt;<A HREF="../../java/awt/KeyEventDispatcher.html" title="java.awt 中的接口">KeyEventDispatcher</A>&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/awt/KeyboardFocusManager.html#getKeyEventDispatchers()">getKeyEventDispatchers</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;作为 List 返回此 KeyboardFocusManager 的 KeyEventDispatcher 链。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="../../java/util/List.html" title="java.util 中的接口">List</A>&lt;<A HREF="../../java/awt/KeyEventPostProcessor.html" title="java.awt 中的接口">KeyEventPostProcessor</A>&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/awt/KeyboardFocusManager.html#getKeyEventPostProcessors()">getKeyEventPostProcessors</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;作为 List 返回此 KeyboardFocusManager 的 KeyEventPostProcessor 链。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/awt/Component.html" title="java.awt 中的类">Component</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/awt/KeyboardFocusManager.html#getPermanentFocusOwner()">getPermanentFocusOwner</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果持久焦点所有者与调用线程位于同一个上下文中，则返回持久焦点所有者。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/beans/PropertyChangeListener.html" title="java.beans 中的接口">PropertyChangeListener</A>[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/awt/KeyboardFocusManager.html#getPropertyChangeListeners()">getPropertyChangeListeners</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;返回在此键盘焦点管理器上注册的所有属性更改侦听器组成的数组。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/beans/PropertyChangeListener.html" title="java.beans 中的接口">PropertyChangeListener</A>[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/awt/KeyboardFocusManager.html#getPropertyChangeListeners(java.lang.String)">getPropertyChangeListeners</A></B>(<A HREF="../../java/lang/String.html" title="java.lang 中的类">String</A>&nbsp;propertyName)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;返回与指定属性相关联的所有 <code>PropertyChangeListener</code> 组成的数组。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/beans/VetoableChangeListener.html" title="java.beans 中的接口">VetoableChangeListener</A>[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/awt/KeyboardFocusManager.html#getVetoableChangeListeners()">getVetoableChangeListeners</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;返回在此键盘焦点管理器上注册的所有可否决更改侦听器组成的数组。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/beans/VetoableChangeListener.html" title="java.beans 中的接口">VetoableChangeListener</A>[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/awt/KeyboardFocusManager.html#getVetoableChangeListeners(java.lang.String)">getVetoableChangeListeners</A></B>(<A HREF="../../java/lang/String.html" title="java.lang 中的类">String</A>&nbsp;propertyName)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;返回与指定属性相关联的所有 <code>VetoableChangeListener</code> 组成的数组。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/awt/KeyboardFocusManager.html#postProcessKeyEvent(java.awt.event.KeyEvent)">postProcessKeyEvent</A></B>(<A HREF="../../java/awt/event/KeyEvent.html" title="java.awt.event 中的类">KeyEvent</A>&nbsp;e)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>dispatchKeyEvent</code> 将调用此方法。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/awt/KeyboardFocusManager.html#processKeyEvent(java.awt.Component, java.awt.event.KeyEvent)">processKeyEvent</A></B>(<A HREF="../../java/awt/Component.html" title="java.awt 中的类">Component</A>&nbsp;focusedComponent,
                <A HREF="../../java/awt/event/KeyEvent.html" title="java.awt.event 中的类">KeyEvent</A>&nbsp;e)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当且仅当该 KeyEvent 表示指定 focusedComponent 的焦点遍历键时，此方法启动焦点遍历操作。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/awt/KeyboardFocusManager.html#redispatchEvent(java.awt.Component, java.awt.AWTEvent)">redispatchEvent</A></B>(<A HREF="../../java/awt/Component.html" title="java.awt 中的类">Component</A>&nbsp;target,
                <A HREF="../../java/awt/AWTEvent.html" title="java.awt 中的类">AWTEvent</A>&nbsp;e)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;重新指派 AWTEvent 的方式是，AWT 事件调度程序不会递归式请求 KeyboardFocusManager 或任何已安装的 KeyEventDispatcher 再次指派该事件。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/awt/KeyboardFocusManager.html#removeKeyEventDispatcher(java.awt.KeyEventDispatcher)">removeKeyEventDispatcher</A></B>(<A HREF="../../java/awt/KeyEventDispatcher.html" title="java.awt 中的接口">KeyEventDispatcher</A>&nbsp;dispatcher)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;移除以前添加到此 KeyboardFocusManager 调度程序链中的 KeyEventDispatcher。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/awt/KeyboardFocusManager.html#removeKeyEventPostProcessor(java.awt.KeyEventPostProcessor)">removeKeyEventPostProcessor</A></B>(<A HREF="../../java/awt/KeyEventPostProcessor.html" title="java.awt 中的接口">KeyEventPostProcessor</A>&nbsp;processor)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;从此 KeyboardFocusManager 的后处理器链中移除以前添加的 KeyEventPostProcessor。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/awt/KeyboardFocusManager.html#removePropertyChangeListener(java.beans.PropertyChangeListener)">removePropertyChangeListener</A></B>(<A HREF="../../java/beans/PropertyChangeListener.html" title="java.beans 中的接口">PropertyChangeListener</A>&nbsp;listener)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;从侦听器列表移除 PropertyChangeListener。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/awt/KeyboardFocusManager.html#removePropertyChangeListener(java.lang.String, java.beans.PropertyChangeListener)">removePropertyChangeListener</A></B>(<A HREF="../../java/lang/String.html" title="java.lang 中的类">String</A>&nbsp;propertyName,
                             <A HREF="../../java/beans/PropertyChangeListener.html" title="java.beans 中的接口">PropertyChangeListener</A>&nbsp;listener)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;从特定属性的侦听器列表移除 PropertyChangeListener。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/awt/KeyboardFocusManager.html#removeVetoableChangeListener(java.lang.String, java.beans.VetoableChangeListener)">removeVetoableChangeListener</A></B>(<A HREF="../../java/lang/String.html" title="java.lang 中的类">String</A>&nbsp;propertyName,
                             <A HREF="../../java/beans/VetoableChangeListener.html" title="java.beans 中的接口">VetoableChangeListener</A>&nbsp;listener)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;从特定属性的侦听器列表移除 VetoableChangeListener。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/awt/KeyboardFocusManager.html#removeVetoableChangeListener(java.beans.VetoableChangeListener)">removeVetoableChangeListener</A></B>(<A HREF="../../java/beans/VetoableChangeListener.html" title="java.beans 中的接口">VetoableChangeListener</A>&nbsp;listener)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;从侦听器列表移除 VetoableChangeListener。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/awt/KeyboardFocusManager.html#setCurrentKeyboardFocusManager(java.awt.KeyboardFocusManager)">setCurrentKeyboardFocusManager</A></B>(<A HREF="../../java/awt/KeyboardFocusManager.html" title="java.awt 中的类">KeyboardFocusManager</A>&nbsp;newManager)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;设置调用线程上下文的当前 KeyboardFocusManager 实例。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/awt/KeyboardFocusManager.html#setDefaultFocusTraversalKeys(int, java.util.Set)">setDefaultFocusTraversalKeys</A></B>(int&nbsp;id,
                             <A HREF="../../java/util/Set.html" title="java.util 中的接口">Set</A>&lt;? extends <A HREF="../../java/awt/AWTKeyStroke.html" title="java.awt 中的类">AWTKeyStroke</A>&gt;&nbsp;keystrokes)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;设置给定遍历操作的默认焦点遍历键。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/awt/KeyboardFocusManager.html#setDefaultFocusTraversalPolicy(java.awt.FocusTraversalPolicy)">setDefaultFocusTraversalPolicy</A></B>(<A HREF="../../java/awt/FocusTraversalPolicy.html" title="java.awt 中的类">FocusTraversalPolicy</A>&nbsp;defaultPolicy)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;设置默认 FocusTraversalPolicy。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/awt/KeyboardFocusManager.html#setGlobalActiveWindow(java.awt.Window)">setGlobalActiveWindow</A></B>(<A HREF="../../java/awt/Window.html" title="java.awt 中的类">Window</A>&nbsp;activeWindow)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;设置活动 Window。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/awt/KeyboardFocusManager.html#setGlobalCurrentFocusCycleRoot(java.awt.Container)">setGlobalCurrentFocusCycleRoot</A></B>(<A HREF="../../java/awt/Container.html" title="java.awt 中的类">Container</A>&nbsp;newFocusCycleRoot)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;设置当前焦点循环根。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/awt/KeyboardFocusManager.html#setGlobalFocusedWindow(java.awt.Window)">setGlobalFocusedWindow</A></B>(<A HREF="../../java/awt/Window.html" title="java.awt 中的类">Window</A>&nbsp;focusedWindow)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;设置聚焦 Window。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/awt/KeyboardFocusManager.html#setGlobalFocusOwner(java.awt.Component)">setGlobalFocusOwner</A></B>(<A HREF="../../java/awt/Component.html" title="java.awt 中的类">Component</A>&nbsp;focusOwner)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;设置焦点所有者。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/awt/KeyboardFocusManager.html#setGlobalPermanentFocusOwner(java.awt.Component)">setGlobalPermanentFocusOwner</A></B>(<A HREF="../../java/awt/Component.html" title="java.awt 中的类">Component</A>&nbsp;permanentFocusOwner)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;设置持久焦点所有者。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/awt/KeyboardFocusManager.html#upFocusCycle()">upFocusCycle</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;从当前焦点所有者将焦点上移一个焦点遍历循环。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/awt/KeyboardFocusManager.html#upFocusCycle(java.awt.Component)">upFocusCycle</A></B>(<A HREF="../../java/awt/Component.html" title="java.awt 中的类">Component</A>&nbsp;aComponent)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;将焦点上移一个焦点遍历循环。</TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_java.lang.Object"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>从类 java.lang.<A HREF="../../java/lang/Object.html" title="java.lang 中的类">Object</A> 继承的方法</B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><A HREF="../../java/lang/Object.html#clone()">clone</A>, <A HREF="../../java/lang/Object.html#equals(java.lang.Object)">equals</A>, <A HREF="../../java/lang/Object.html#finalize()">finalize</A>, <A HREF="../../java/lang/Object.html#getClass()">getClass</A>, <A HREF="../../java/lang/Object.html#hashCode()">hashCode</A>, <A HREF="../../java/lang/Object.html#notify()">notify</A>, <A HREF="../../java/lang/Object.html#notifyAll()">notifyAll</A>, <A HREF="../../java/lang/Object.html#toString()">toString</A>, <A HREF="../../java/lang/Object.html#wait()">wait</A>, <A HREF="../../java/lang/Object.html#wait(long)">wait</A>, <A HREF="../../java/lang/Object.html#wait(long, int)">wait</A></CODE></TD>
</TR>
</TABLE>
&nbsp;
<P>

<!-- ============ FIELD DETAIL =========== -->

<A NAME="field_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>字段详细信息</B></FONT></TH>
</TR>
</TABLE>

<A NAME="FORWARD_TRAVERSAL_KEYS"><!-- --></A><H3>
FORWARD_TRAVERSAL_KEYS</H3>
<PRE>
public static final int <B>FORWARD_TRAVERSAL_KEYS</B></PRE>
<DL>
<DD>Forward 焦点遍历键的标识符。
<P>
<DL>
<DT><B>另请参见：</B><DD><A HREF="../../java/awt/KeyboardFocusManager.html#setDefaultFocusTraversalKeys(int, java.util.Set)"><CODE>setDefaultFocusTraversalKeys(int, java.util.Set<? extends java.awt.AWTKeyStroke>)</CODE></A>, 
<A HREF="../../java/awt/KeyboardFocusManager.html#getDefaultFocusTraversalKeys(int)"><CODE>getDefaultFocusTraversalKeys(int)</CODE></A>, 
<A HREF="../../java/awt/Component.html#setFocusTraversalKeys(int, java.util.Set)"><CODE>Component.setFocusTraversalKeys(int, java.util.Set<? extends java.awt.AWTKeyStroke>)</CODE></A>, 
<A HREF="../../java/awt/Component.html#getFocusTraversalKeys(int)"><CODE>Component.getFocusTraversalKeys(int)</CODE></A>, 
<A HREF="../../constant-values.html#java.awt.KeyboardFocusManager.FORWARD_TRAVERSAL_KEYS">常量字段值</A></DL>
</DL>
<HR>

<A NAME="BACKWARD_TRAVERSAL_KEYS"><!-- --></A><H3>
BACKWARD_TRAVERSAL_KEYS</H3>
<PRE>
public static final int <B>BACKWARD_TRAVERSAL_KEYS</B></PRE>
<DL>
<DD>Backward 焦点遍历键的标识符。
<P>
<DL>
<DT><B>另请参见：</B><DD><A HREF="../../java/awt/KeyboardFocusManager.html#setDefaultFocusTraversalKeys(int, java.util.Set)"><CODE>setDefaultFocusTraversalKeys(int, java.util.Set<? extends java.awt.AWTKeyStroke>)</CODE></A>, 
<A HREF="../../java/awt/KeyboardFocusManager.html#getDefaultFocusTraversalKeys(int)"><CODE>getDefaultFocusTraversalKeys(int)</CODE></A>, 
<A HREF="../../java/awt/Component.html#setFocusTraversalKeys(int, java.util.Set)"><CODE>Component.setFocusTraversalKeys(int, java.util.Set<? extends java.awt.AWTKeyStroke>)</CODE></A>, 
<A HREF="../../java/awt/Component.html#getFocusTraversalKeys(int)"><CODE>Component.getFocusTraversalKeys(int)</CODE></A>, 
<A HREF="../../constant-values.html#java.awt.KeyboardFocusManager.BACKWARD_TRAVERSAL_KEYS">常量字段值</A></DL>
</DL>
<HR>

<A NAME="UP_CYCLE_TRAVERSAL_KEYS"><!-- --></A><H3>
UP_CYCLE_TRAVERSAL_KEYS</H3>
<PRE>
public static final int <B>UP_CYCLE_TRAVERSAL_KEYS</B></PRE>
<DL>
<DD>Up Cycle 焦点遍历键的标识符。
<P>
<DL>
<DT><B>另请参见：</B><DD><A HREF="../../java/awt/KeyboardFocusManager.html#setDefaultFocusTraversalKeys(int, java.util.Set)"><CODE>setDefaultFocusTraversalKeys(int, java.util.Set<? extends java.awt.AWTKeyStroke>)</CODE></A>, 
<A HREF="../../java/awt/KeyboardFocusManager.html#getDefaultFocusTraversalKeys(int)"><CODE>getDefaultFocusTraversalKeys(int)</CODE></A>, 
<A HREF="../../java/awt/Component.html#setFocusTraversalKeys(int, java.util.Set)"><CODE>Component.setFocusTraversalKeys(int, java.util.Set<? extends java.awt.AWTKeyStroke>)</CODE></A>, 
<A HREF="../../java/awt/Component.html#getFocusTraversalKeys(int)"><CODE>Component.getFocusTraversalKeys(int)</CODE></A>, 
<A HREF="../../constant-values.html#java.awt.KeyboardFocusManager.UP_CYCLE_TRAVERSAL_KEYS">常量字段值</A></DL>
</DL>
<HR>

<A NAME="DOWN_CYCLE_TRAVERSAL_KEYS"><!-- --></A><H3>
DOWN_CYCLE_TRAVERSAL_KEYS</H3>
<PRE>
public static final int <B>DOWN_CYCLE_TRAVERSAL_KEYS</B></PRE>
<DL>
<DD>Down Cycle 焦点遍历键的标识符。
<P>
<DL>
<DT><B>另请参见：</B><DD><A HREF="../../java/awt/KeyboardFocusManager.html#setDefaultFocusTraversalKeys(int, java.util.Set)"><CODE>setDefaultFocusTraversalKeys(int, java.util.Set<? extends java.awt.AWTKeyStroke>)</CODE></A>, 
<A HREF="../../java/awt/KeyboardFocusManager.html#getDefaultFocusTraversalKeys(int)"><CODE>getDefaultFocusTraversalKeys(int)</CODE></A>, 
<A HREF="../../java/awt/Component.html#setFocusTraversalKeys(int, java.util.Set)"><CODE>Component.setFocusTraversalKeys(int, java.util.Set<? extends java.awt.AWTKeyStroke>)</CODE></A>, 
<A HREF="../../java/awt/Component.html#getFocusTraversalKeys(int)"><CODE>Component.getFocusTraversalKeys(int)</CODE></A>, 
<A HREF="../../constant-values.html#java.awt.KeyboardFocusManager.DOWN_CYCLE_TRAVERSAL_KEYS">常量字段值</A></DL>
</DL>

<!-- ========= CONSTRUCTOR DETAIL ======== -->

<A NAME="constructor_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>构造方法详细信息</B></FONT></TH>
</TR>
</TABLE>

<A NAME="KeyboardFocusManager()"><!-- --></A><H3>
KeyboardFocusManager</H3>
<PRE>
public <B>KeyboardFocusManager</B>()</PRE>
<DL>
<DD>初始化 KeyboardFocusManager。
<P>
</DL>

<!-- ============ METHOD DETAIL ========== -->

<A NAME="method_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>方法详细信息</B></FONT></TH>
</TR>
</TABLE>

<A NAME="getCurrentKeyboardFocusManager()"><!-- --></A><H3>
getCurrentKeyboardFocusManager</H3>
<PRE>
public static <A HREF="../../java/awt/KeyboardFocusManager.html" title="java.awt 中的类">KeyboardFocusManager</A> <B>getCurrentKeyboardFocusManager</B>()</PRE>
<DL>
<DD>返回调用线程上下文的当前 KeyboardFocusManager 实例。
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>返回：</B><DD>此线程上下文的 KeyboardFocusManager<DT><B>另请参见：</B><DD><A HREF="../../java/awt/KeyboardFocusManager.html#setCurrentKeyboardFocusManager(java.awt.KeyboardFocusManager)"><CODE>setCurrentKeyboardFocusManager(java.awt.KeyboardFocusManager)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="setCurrentKeyboardFocusManager(java.awt.KeyboardFocusManager)"><!-- --></A><H3>
setCurrentKeyboardFocusManager</H3>
<PRE>
public static void <B>setCurrentKeyboardFocusManager</B>(<A HREF="../../java/awt/KeyboardFocusManager.html" title="java.awt 中的类">KeyboardFocusManager</A>&nbsp;newManager)
                                           throws <A HREF="../../java/lang/SecurityException.html" title="java.lang 中的类">SecurityException</A></PRE>
<DL>
<DD>设置调用线程上下文的当前 KeyboardFocusManager 实例。如果指定了 null，则使用 DefaultKeyboardFocusManager 的新实例替换当前 KeyboardFocusManager。
 <p>
如果安装了 SecurityManager，则必须授予调用线程 AWTPermission &quot;replaceKeyboardFocusManager&quot; 才能替换当前 KeyboardFocusManager。如果未授予该权限，则此方法将抛出 SecurityException，而当前的 KeyboardFocusManager 不会改变。
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>参数：</B><DD><CODE>newManager</CODE> - 此线程上下文的新 KeyboardFocusManager
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../java/lang/SecurityException.html" title="java.lang 中的类">SecurityException</A></CODE> - 如果调用线程不具有替换当前 KeyboardFocusManager 的权限<DT><B>另请参见：</B><DD><A HREF="../../java/awt/KeyboardFocusManager.html#getCurrentKeyboardFocusManager()"><CODE>getCurrentKeyboardFocusManager()</CODE></A>, 
<A HREF="../../java/awt/DefaultKeyboardFocusManager.html" title="java.awt 中的类"><CODE>DefaultKeyboardFocusManager</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="getFocusOwner()"><!-- --></A><H3>
getFocusOwner</H3>
<PRE>
public <A HREF="../../java/awt/Component.html" title="java.awt 中的类">Component</A> <B>getFocusOwner</B>()</PRE>
<DL>
<DD>如果焦点所有者与调用线程位于同一个上下文中，则返回该焦点所有者。焦点所有者的定义是：应用程序中的 Component，通常用户生成的所有 KeyEvent 都被接收。如果为焦点所有者启用了焦点遍历键，则不会传递映射到焦点所有者的焦点遍历键的 KeyEvent。此外，KeyEventDispatcher 在到达焦点所有者之前可能重定向或使用 KeyEvent。
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>返回：</B><DD>焦点所有者；如果焦点所有者调用的不是线程上下文的成员，则返回 null<DT><B>另请参见：</B><DD><A HREF="../../java/awt/KeyboardFocusManager.html#getGlobalFocusOwner()"><CODE>getGlobalFocusOwner()</CODE></A>, 
<A HREF="../../java/awt/KeyboardFocusManager.html#setGlobalFocusOwner(java.awt.Component)"><CODE>setGlobalFocusOwner(java.awt.Component)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="getGlobalFocusOwner()"><!-- --></A><H3>
getGlobalFocusOwner</H3>
<PRE>
protected <A HREF="../../java/awt/Component.html" title="java.awt 中的类">Component</A> <B>getGlobalFocusOwner</B>()
                                 throws <A HREF="../../java/lang/SecurityException.html" title="java.lang 中的类">SecurityException</A></PRE>
<DL>
<DD>返回焦点所有者，即使调用线程处于焦点所有者之外的上下文中。焦点所有者的定义是：应用程序中的 Component，通常接收用户生成的所有 KeyEvent。如果为焦点所有者启用了焦点遍历键，则不会传递映射到焦点所有者的焦点遍历键的 KeyEvent。此外，KeyEventDispatcher 在到达焦点所有者之前可能重定向或使用 KeyEvent。
 <p>
如果此 KeyboardFocusManager 调用的不是线程上下文的当前 KeyboardFocusManager，则此方法将抛出 SecurityException。
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>返回：</B><DD>焦点所有者
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../java/lang/SecurityException.html" title="java.lang 中的类">SecurityException</A></CODE> - 如果此 KeyboardFocusManager 调用的不是线程上下文的当前 KeyboardFocusManager<DT><B>另请参见：</B><DD><A HREF="../../java/awt/KeyboardFocusManager.html#getFocusOwner()"><CODE>getFocusOwner()</CODE></A>, 
<A HREF="../../java/awt/KeyboardFocusManager.html#setGlobalFocusOwner(java.awt.Component)"><CODE>setGlobalFocusOwner(java.awt.Component)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="setGlobalFocusOwner(java.awt.Component)"><!-- --></A><H3>
setGlobalFocusOwner</H3>
<PRE>
protected void <B>setGlobalFocusOwner</B>(<A HREF="../../java/awt/Component.html" title="java.awt 中的类">Component</A>&nbsp;focusOwner)</PRE>
<DL>
<DD>设置焦点所有者。如果该 Component 不可以作为焦点，则取消操作。焦点所有者的定义是：应用程序中的 Component，通常接收用户生成的所有 KeyEvent。如果为焦点所有者启用了焦点遍历键，则不会传递映射到焦点所有者的焦点遍历键的 KeyEvent。此外，KeyEventDispatcher 在到达焦点所有者之前可能重定向或使用 KeyEvent。 
 <p>
此方法实际上没有将焦点设置为指定的 Component。它只存储该值，以便以后由 <code>getFocusOwner()</code> 返回它。更改焦点所有者需要使用 <code>Component.requestFocus()</code> 或 <code>Component.requestFocusInWindow()</code>，具体的使用因平台而异。
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>参数：</B><DD><CODE>focusOwner</CODE> - 焦点所有者<DT><B>另请参见：</B><DD><A HREF="../../java/awt/KeyboardFocusManager.html#getFocusOwner()"><CODE>getFocusOwner()</CODE></A>, 
<A HREF="../../java/awt/KeyboardFocusManager.html#getGlobalFocusOwner()"><CODE>getGlobalFocusOwner()</CODE></A>, 
<A HREF="../../java/awt/Component.html#requestFocus()"><CODE>Component.requestFocus()</CODE></A>, 
<A HREF="../../java/awt/Component.html#requestFocusInWindow()"><CODE>Component.requestFocusInWindow()</CODE></A>, 
<A HREF="../../java/awt/Component.html#isFocusable()"><CODE>Component.isFocusable()</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="clearGlobalFocusOwner()"><!-- --></A><H3>
clearGlobalFocusOwner</H3>
<PRE>
public void <B>clearGlobalFocusOwner</B>()</PRE>
<DL>
<DD>在 Java 和本机级别清除全局焦点所有者。如果存在焦点所有者，则该 Component 将接收持久 FOCUS_LOST 事件。完成此操作后，在用户选择接收焦点的新 Component 或通过调用 <code>requestFocus()</code> 为 Component 显式分配焦点之前，本机窗口操作系统将放弃所有用户生成的 KeyEvent。此操作不改变聚焦或激活状态的 Window。
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>另请参见：</B><DD><A HREF="../../java/awt/Component.html#requestFocus()"><CODE>Component.requestFocus()</CODE></A>, 
<A HREF="../../java/awt/event/FocusEvent.html#FOCUS_LOST"><CODE>FocusEvent.FOCUS_LOST</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="getPermanentFocusOwner()"><!-- --></A><H3>
getPermanentFocusOwner</H3>
<PRE>
public <A HREF="../../java/awt/Component.html" title="java.awt 中的类">Component</A> <B>getPermanentFocusOwner</B>()</PRE>
<DL>
<DD>如果持久焦点所有者与调用线程位于同一个上下文中，则返回持久焦点所有者。持久焦点所有者的定义是：应用程序中的最后一个 Component，它可以接收持久 FOCUS_GAINED 事件。如果不发生临时焦点更改，则焦点所有者和持久焦点所有者是等效的。在发生临时焦点更改的情形下，临时焦点更改结束后，持久焦点所有者又会变成焦点所有者。
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>返回：</B><DD>持久焦点所有者；如果持久焦点所有者调用的不是线程上下文的成员，则返回 null<DT><B>另请参见：</B><DD><A HREF="../../java/awt/KeyboardFocusManager.html#getGlobalPermanentFocusOwner()"><CODE>getGlobalPermanentFocusOwner()</CODE></A>, 
<A HREF="../../java/awt/KeyboardFocusManager.html#setGlobalPermanentFocusOwner(java.awt.Component)"><CODE>setGlobalPermanentFocusOwner(java.awt.Component)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="getGlobalPermanentFocusOwner()"><!-- --></A><H3>
getGlobalPermanentFocusOwner</H3>
<PRE>
protected <A HREF="../../java/awt/Component.html" title="java.awt 中的类">Component</A> <B>getGlobalPermanentFocusOwner</B>()
                                          throws <A HREF="../../java/lang/SecurityException.html" title="java.lang 中的类">SecurityException</A></PRE>
<DL>
<DD>返回持久焦点所有者，即使调用线程处于该持久焦点所有者之外的上下文中。持久焦点所有者的定义是：应用程序中的最后一个 Component，它可以接收持久 FOCUS_GAINED 事件。如果不发生临时焦点更改，则焦点所有者和持久焦点所有者是等效的。在发生临时焦点更改的情形下，临时焦点更改结束后，持久焦点所有者又会变成焦点所有者。
 <p>
如果此 KeyboardFocusManager 调用的不是线程上下文的当前 KeyboardFocusManager，则此方法将抛出 SecurityException。
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>返回：</B><DD>持久焦点所有者
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../java/lang/SecurityException.html" title="java.lang 中的类">SecurityException</A></CODE> - 如果此 KeyboardFocusManager 调用的不是线程上下文的当前 KeyboardFocusManager<DT><B>另请参见：</B><DD><A HREF="../../java/awt/KeyboardFocusManager.html#getPermanentFocusOwner()"><CODE>getPermanentFocusOwner()</CODE></A>, 
<A HREF="../../java/awt/KeyboardFocusManager.html#setGlobalPermanentFocusOwner(java.awt.Component)"><CODE>setGlobalPermanentFocusOwner(java.awt.Component)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="setGlobalPermanentFocusOwner(java.awt.Component)"><!-- --></A><H3>
setGlobalPermanentFocusOwner</H3>
<PRE>
protected void <B>setGlobalPermanentFocusOwner</B>(<A HREF="../../java/awt/Component.html" title="java.awt 中的类">Component</A>&nbsp;permanentFocusOwner)</PRE>
<DL>
<DD>设置持久焦点所有者。如果该 Component 不可以作为焦点，则取消该操作。持久焦点所有者的定义是：应用程序中的最后一个 Component，它可以接收持久 FOCUS_GAINED 事件。如果不发生临时焦点更改，则焦点所有者和持久焦点所有者是等效的。在发生临时焦点更改的情形下，临时焦点更改结束后，持久焦点所有者又会变成焦点所有者。
 <p>
此方法实际上没有将焦点设置为指定的 Component。它只存储该值，以便以后由 <code>getPermanentFocusOwner()</code> 返回它。更改焦点所有者需要使用 <code>Component.requestFocus()</code> 或 <code>Component.requestFocusInWindow()</code>，因平台而异。
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>参数：</B><DD><CODE>permanentFocusOwner</CODE> - 持久焦点所有者<DT><B>另请参见：</B><DD><A HREF="../../java/awt/KeyboardFocusManager.html#getPermanentFocusOwner()"><CODE>getPermanentFocusOwner()</CODE></A>, 
<A HREF="../../java/awt/KeyboardFocusManager.html#getGlobalPermanentFocusOwner()"><CODE>getGlobalPermanentFocusOwner()</CODE></A>, 
<A HREF="../../java/awt/Component.html#requestFocus()"><CODE>Component.requestFocus()</CODE></A>, 
<A HREF="../../java/awt/Component.html#requestFocusInWindow()"><CODE>Component.requestFocusInWindow()</CODE></A>, 
<A HREF="../../java/awt/Component.html#isFocusable()"><CODE>Component.isFocusable()</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="getFocusedWindow()"><!-- --></A><H3>
getFocusedWindow</H3>
<PRE>
public <A HREF="../../java/awt/Window.html" title="java.awt 中的类">Window</A> <B>getFocusedWindow</B>()</PRE>
<DL>
<DD>如果聚焦窗口与调用线程位于同一个上下文中，则返回聚焦窗口。聚焦 Window 指本身就是（或者包含）焦点所有者的 Window。
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>返回：</B><DD>聚焦 Window；如果聚焦 Window 调用的不是线程上下文的成员，则返回 null<DT><B>另请参见：</B><DD><A HREF="../../java/awt/KeyboardFocusManager.html#getGlobalFocusedWindow()"><CODE>getGlobalFocusedWindow()</CODE></A>, 
<A HREF="../../java/awt/KeyboardFocusManager.html#setGlobalFocusedWindow(java.awt.Window)"><CODE>setGlobalFocusedWindow(java.awt.Window)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="getGlobalFocusedWindow()"><!-- --></A><H3>
getGlobalFocusedWindow</H3>
<PRE>
protected <A HREF="../../java/awt/Window.html" title="java.awt 中的类">Window</A> <B>getGlobalFocusedWindow</B>()
                                 throws <A HREF="../../java/lang/SecurityException.html" title="java.lang 中的类">SecurityException</A></PRE>
<DL>
<DD>返回聚焦 Window，即使调用线程处于聚焦 Window 之外的上下文中。聚焦 Window 指本身就是（或者包含）焦点所有者的 Window。
 <p>
如果此 KeyboardFocusManager 调用的不是线程上下文的当前 KeyboardFocusManager，则此方法将抛出 SecurityException。
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>返回：</B><DD>聚焦 Window
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../java/lang/SecurityException.html" title="java.lang 中的类">SecurityException</A></CODE> - 如果此 KeyboardFocusManager 调用的不是线程上下文的当前 KeyboardFocusManager<DT><B>另请参见：</B><DD><A HREF="../../java/awt/KeyboardFocusManager.html#getFocusedWindow()"><CODE>getFocusedWindow()</CODE></A>, 
<A HREF="../../java/awt/KeyboardFocusManager.html#setGlobalFocusedWindow(java.awt.Window)"><CODE>setGlobalFocusedWindow(java.awt.Window)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="setGlobalFocusedWindow(java.awt.Window)"><!-- --></A><H3>
setGlobalFocusedWindow</H3>
<PRE>
protected void <B>setGlobalFocusedWindow</B>(<A HREF="../../java/awt/Window.html" title="java.awt 中的类">Window</A>&nbsp;focusedWindow)</PRE>
<DL>
<DD>设置聚焦 Window。聚焦 Window 指本身就是（或者包含）焦点所有者的 Window。如果要聚焦的指定 Window 不是可以作为焦点的 Window，则取消该操作。
 <p>
此方法不能实际更改与本机窗口操作系统相关的聚焦 Window。它只存储该值，以便以后由 <code>getFocusedWindow()</code> 返回它。更改聚焦 Window 需要使用 <code>Component.requestFocus()</code> 或 <code>Component.requestFocusInWindow()</code>，因平台而异。
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>参数：</B><DD><CODE>focusedWindow</CODE> - 聚焦 Window<DT><B>另请参见：</B><DD><A HREF="../../java/awt/KeyboardFocusManager.html#getFocusedWindow()"><CODE>getFocusedWindow()</CODE></A>, 
<A HREF="../../java/awt/KeyboardFocusManager.html#getGlobalFocusedWindow()"><CODE>getGlobalFocusedWindow()</CODE></A>, 
<A HREF="../../java/awt/Component.html#requestFocus()"><CODE>Component.requestFocus()</CODE></A>, 
<A HREF="../../java/awt/Component.html#requestFocusInWindow()"><CODE>Component.requestFocusInWindow()</CODE></A>, 
<A HREF="../../java/awt/Window.html#isFocusableWindow()"><CODE>Window.isFocusableWindow()</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="getActiveWindow()"><!-- --></A><H3>
getActiveWindow</H3>
<PRE>
public <A HREF="../../java/awt/Window.html" title="java.awt 中的类">Window</A> <B>getActiveWindow</B>()</PRE>
<DL>
<DD>如果活动 Window 与调用线程位于同一个上下文中，则返回活动 Window。只有 Frame 或 Dialog 才能成为活动 Window。本机的窗口操作系统可能使用特殊装饰（如高亮显示标题栏）来表示活动 Window 或其子窗口。活动 Window 要么是聚焦 Window，要么是作为聚焦 Window 所有者的第一个 Frame 或 Dialog。
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>返回：</B><DD>活动 Window；如果活动 Window 调用的不是线程上下文的成员，则返回 null<DT><B>另请参见：</B><DD><A HREF="../../java/awt/KeyboardFocusManager.html#getGlobalActiveWindow()"><CODE>getGlobalActiveWindow()</CODE></A>, 
<A HREF="../../java/awt/KeyboardFocusManager.html#setGlobalActiveWindow(java.awt.Window)"><CODE>setGlobalActiveWindow(java.awt.Window)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="getGlobalActiveWindow()"><!-- --></A><H3>
getGlobalActiveWindow</H3>
<PRE>
protected <A HREF="../../java/awt/Window.html" title="java.awt 中的类">Window</A> <B>getGlobalActiveWindow</B>()
                                throws <A HREF="../../java/lang/SecurityException.html" title="java.lang 中的类">SecurityException</A></PRE>
<DL>
<DD>返回活动 Window，即使调用线程处于活动 Window 之外的上下文中。只有 Frame 或 Dialog 才能成为活动 Window。本机的窗口操作系统可能使用特殊装饰（如高亮显示标题栏）来表示活动 Window。活动 Window 要么是聚焦 Window，要么是作为聚焦 Window 所有者的第一个 Frame 或 Dialog。
 <p>
如果此 KeyboardFocusManager 调用的不是线程上下文的当前 KeyboardFocusManager，则此方法将抛出 SecurityException。
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>返回：</B><DD>活动 Window
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../java/lang/SecurityException.html" title="java.lang 中的类">SecurityException</A></CODE> - 如果此 KeyboardFocusManager 调用的不是线程上下文的当前 KeyboardFocusManager<DT><B>另请参见：</B><DD><A HREF="../../java/awt/KeyboardFocusManager.html#getActiveWindow()"><CODE>getActiveWindow()</CODE></A>, 
<A HREF="../../java/awt/KeyboardFocusManager.html#setGlobalActiveWindow(java.awt.Window)"><CODE>setGlobalActiveWindow(java.awt.Window)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="setGlobalActiveWindow(java.awt.Window)"><!-- --></A><H3>
setGlobalActiveWindow</H3>
<PRE>
protected void <B>setGlobalActiveWindow</B>(<A HREF="../../java/awt/Window.html" title="java.awt 中的类">Window</A>&nbsp;activeWindow)</PRE>
<DL>
<DD>设置活动 Window。只有 Frame 或 Dialog 才能成为活动 Window。本机的窗口操作系统可能使用特殊装饰（如高亮显示标题栏）来表示活动 Window 或其子窗口。活动 Window 要么是聚焦 Window，要么是作为聚焦 Window 所有者的第一个 Frame 或 Dialog。
 <p>
此方法不能实际更改与本机窗口操作系统相关的活动 Window。它只存储该值，以便以后由 <code>getActiveWindow()</code> 返回它。更改活动 Window 需要使用 <code>Component.requestFocus()</code> 或 <code>Component.requestFocusInWindow()</code>，因平台而异。
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>参数：</B><DD><CODE>activeWindow</CODE> - 活动 Window<DT><B>另请参见：</B><DD><A HREF="../../java/awt/KeyboardFocusManager.html#getActiveWindow()"><CODE>getActiveWindow()</CODE></A>, 
<A HREF="../../java/awt/KeyboardFocusManager.html#getGlobalActiveWindow()"><CODE>getGlobalActiveWindow()</CODE></A>, 
<A HREF="../../java/awt/Component.html#requestFocus()"><CODE>Component.requestFocus()</CODE></A>, 
<A HREF="../../java/awt/Component.html#requestFocusInWindow()"><CODE>Component.requestFocusInWindow()</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="getDefaultFocusTraversalPolicy()"><!-- --></A><H3>
getDefaultFocusTraversalPolicy</H3>
<PRE>
public <A HREF="../../java/awt/FocusTraversalPolicy.html" title="java.awt 中的类">FocusTraversalPolicy</A> <B>getDefaultFocusTraversalPolicy</B>()</PRE>
<DL>
<DD>返回默认 FocusTraversalPolicy。通过显式调用 Container.setFocusTraversalPolicy 初始化自己的焦点遍历策略时，顶层组件会使用该值。
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>返回：</B><DD>默认 FocusTraversalPolicy。永远不会返回 null。<DT><B>另请参见：</B><DD><A HREF="../../java/awt/KeyboardFocusManager.html#setDefaultFocusTraversalPolicy(java.awt.FocusTraversalPolicy)"><CODE>setDefaultFocusTraversalPolicy(java.awt.FocusTraversalPolicy)</CODE></A>, 
<A HREF="../../java/awt/Container.html#setFocusTraversalPolicy(java.awt.FocusTraversalPolicy)"><CODE>Container.setFocusTraversalPolicy(java.awt.FocusTraversalPolicy)</CODE></A>, 
<A HREF="../../java/awt/Container.html#getFocusTraversalPolicy()"><CODE>Container.getFocusTraversalPolicy()</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="setDefaultFocusTraversalPolicy(java.awt.FocusTraversalPolicy)"><!-- --></A><H3>
setDefaultFocusTraversalPolicy</H3>
<PRE>
public void <B>setDefaultFocusTraversalPolicy</B>(<A HREF="../../java/awt/FocusTraversalPolicy.html" title="java.awt 中的类">FocusTraversalPolicy</A>&nbsp;defaultPolicy)</PRE>
<DL>
<DD>设置默认 FocusTraversalPolicy。通过显式调用 Container.setFocusTraversalPolicy 初始化自己的焦点遍历策略时，顶层组件会使用此值。注：此调用不影响已经创建的组件，因为它们的策略已经初始化了。只有新组件才会将此策略用作默认策略。
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>参数：</B><DD><CODE>defaultPolicy</CODE> - 新的默认 FocusTraversalPolicy
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../java/lang/IllegalArgumentException.html" title="java.lang 中的类">IllegalArgumentException</A></CODE> - 如果 defaultPolicy 为 null<DT><B>另请参见：</B><DD><A HREF="../../java/awt/KeyboardFocusManager.html#getDefaultFocusTraversalPolicy()"><CODE>getDefaultFocusTraversalPolicy()</CODE></A>, 
<A HREF="../../java/awt/Container.html#setFocusTraversalPolicy(java.awt.FocusTraversalPolicy)"><CODE>Container.setFocusTraversalPolicy(java.awt.FocusTraversalPolicy)</CODE></A>, 
<A HREF="../../java/awt/Container.html#getFocusTraversalPolicy()"><CODE>Container.getFocusTraversalPolicy()</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="setDefaultFocusTraversalKeys(int, java.util.Set)"><!-- --></A><H3>
setDefaultFocusTraversalKeys</H3>
<PRE>
public void <B>setDefaultFocusTraversalKeys</B>(int&nbsp;id,
                                         <A HREF="../../java/util/Set.html" title="java.util 中的接口">Set</A>&lt;? extends <A HREF="../../java/awt/AWTKeyStroke.html" title="java.awt 中的类">AWTKeyStroke</A>&gt;&nbsp;keystrokes)</PRE>
<DL>
<DD>设置给定遍历操作的默认焦点遍历键。此遍历键 <code>Set</code> 对没有显式定义自己的这种 <code>Set</code> 的所有 <code>Window</code> 均有效。对于没有显式定义自己的这种 <code>Set</code> 的 <code>Windows</code> 而言，此 <code>Set</code> 还可以由其子 <code>Component</code> 递归式继承。
 <p>
默认焦点遍历键的默认值是依赖于实现的。Sun 建议特定本机平台的所有实现都使用相同的默认值。下面列出了对 Windows 和 Unix 的建议。这些建议用于 Sun AWT 实现中。

<table border=1 summary="Recommended default values for focus traversal keys">
<tr>
  <th>标识符</th>
  <th>意义</th>
  <th>默认值</th>
</tr>
<tr>
  <td><code>KeyboardFocusManager.FORWARD_TRAVERSAL_KEYS</code></td>
  <td>正常向前键盘遍历</td>
  <td><code>TAB</code> on <code>KEY_PRESSED</code>, <code>CTRL-TAB</code> on <code>KEY_PRESSED</code></td>
</tr>
<tr>
  <td><code>KeyboardFocusManager.BACKWARD_TRAVERSAL_KEYS</code></td>
  <td>正常反向键盘遍历</td>
  <td><code>SHIFT-TAB</code> on <code>KEY_PRESSED</code>, <code>CTRL-SHIFT-TAB</code> on <code>KEY_PRESSED</code></td>
</tr>
<tr>
  <td><code>KeyboardFocusManager.UP_CYCLE_TRAVERSAL_KEYS</code></td>
  <td>向上一个焦点遍历循环</td>
  <td>none</td>
</tr>
<tr>
  <td><code>KeyboardFocusManager.DOWN_CYCLE_TRAVERSAL_KEYS</code></td>
  <td>向下一个焦点遍历循环</td>
  <td>none</td>
</tr>
</table>

要禁用遍历键，需要使用空 <code>Set</code>；建议使用 <code>Collections.EMPTY_SET</code>。
 <p>
使用 <code>AWTKeyStroke</code> API，客户端代码可以指定在两个特定 <code>KeyEvent</code> 的哪一个上进行焦点遍历，<code>KEY_PRESSED</code> 还是 <code>KEY_RELEASED</code>。不管指定哪一个 <code>KeyEvent</code>，所有与焦点遍历键相关的 <code>KeyEvent</code>（包括关联的 <code>KEY_TYPED</code> 事件）都将被使用，不会将其指派给任何 <code>Component</code>。将 <code>KEY_TYPED</code> 事件指定为映射为焦点遍历操作或将同一事件映射为多个默认焦点遍历操作都是运行时错误。
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>参数：</B><DD><CODE>id</CODE> - <code>KeyboardFocusManager.FORWARD_TRAVERSAL_KEYS</code>、<code>KeyboardFocusManager.BACKWARD_TRAVERSAL_KEYS</code>、<code>KeyboardFocusManager.UP_CYCLE_TRAVERSAL_KEYS</code> 和 <code>KeyboardFocusManager.DOWN_CYCLE_TRAVERSAL_KEYS</code> 其中之一<DD><CODE>keystrokes</CODE> - 指定操作的 <code>AWTKeyStroke</code> Set
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../java/lang/IllegalArgumentException.html" title="java.lang 中的类">IllegalArgumentException</A></CODE> - 如果 id 不是 <code>KeyboardFocusManager.FORWARD_TRAVERSAL_KEYS</code>、<code>KeyboardFocusManager.BACKWARD_TRAVERSAL_KEYS</code>、<code>KeyboardFocusManager.UP_CYCLE_TRAVERSAL_KEYS</code> 和 <code>KeyboardFocusManager.DOWN_CYCLE_TRAVERSAL_KEYS</code> 其中之一，或者击键为 <code>null</code>，或者击键包含 <code>null</code>，或者击键中的任何 <code>Object</code> 不是 <code>AWTKeyStroke</code>，或者击键表示 <code>KEY_TYPED</code> 事件，或者击键已映射为别的默认焦点遍历操作<DT><B>另请参见：</B><DD><A HREF="../../java/awt/KeyboardFocusManager.html#getDefaultFocusTraversalKeys(int)"><CODE>getDefaultFocusTraversalKeys(int)</CODE></A>, 
<A HREF="../../java/awt/Component.html#setFocusTraversalKeys(int, java.util.Set)"><CODE>Component.setFocusTraversalKeys(int, java.util.Set<? extends java.awt.AWTKeyStroke>)</CODE></A>, 
<A HREF="../../java/awt/Component.html#getFocusTraversalKeys(int)"><CODE>Component.getFocusTraversalKeys(int)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="getDefaultFocusTraversalKeys(int)"><!-- --></A><H3>
getDefaultFocusTraversalKeys</H3>
<PRE>
public <A HREF="../../java/util/Set.html" title="java.util 中的接口">Set</A>&lt;<A HREF="../../java/awt/AWTKeyStroke.html" title="java.awt 中的类">AWTKeyStroke</A>&gt; <B>getDefaultFocusTraversalKeys</B>(int&nbsp;id)</PRE>
<DL>
<DD>返回给定遍历操作的默认焦点遍历键的 Set。此遍历键 Set 对没有显式定义自己的这种 Set 的所有 Window 均有效。对于没有显式定义自己的这种 Set 的 Window 而言，此 Set 还可以由其子 Component 递归式继承。（请参见 <code>setDefaultFocusTraversalKeys</code> 以获取每个操作的完整描述。）
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>参数：</B><DD><CODE>id</CODE> - KeyboardFocusManager.FORWARD_TRAVERSAL_KEYS、KeyboardFocusManager.BACKWARD_TRAVERSAL_KEYS、KeyboardFocusManager.UP_CYCLE_TRAVERSAL_KEYS 和 KeyboardFocusManager.DOWN_CYCLE_TRAVERSAL_KEYS 其中之一
<DT><B>返回：</B><DD>指定操作的 <code>AWTKeyStroke</code> <code>Set</code>；该 <code>Set</code> 不可修改，并且可以为空；永远不会返回 <code>null</code>
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../java/lang/IllegalArgumentException.html" title="java.lang 中的类">IllegalArgumentException</A></CODE> - 如果 id 不是 KeyboardFocusManager.FORWARD_TRAVERSAL_KEYS、KeyboardFocusManager.BACKWARD_TRAVERSAL_KEYS、KeyboardFocusManager.UP_CYCLE_TRAVERSAL_KEYS 和 KeyboardFocusManager.DOWN_CYCLE_TRAVERSAL_KEYS 其中之一<DT><B>另请参见：</B><DD><A HREF="../../java/awt/KeyboardFocusManager.html#setDefaultFocusTraversalKeys(int, java.util.Set)"><CODE>setDefaultFocusTraversalKeys(int, java.util.Set<? extends java.awt.AWTKeyStroke>)</CODE></A>, 
<A HREF="../../java/awt/Component.html#setFocusTraversalKeys(int, java.util.Set)"><CODE>Component.setFocusTraversalKeys(int, java.util.Set<? extends java.awt.AWTKeyStroke>)</CODE></A>, 
<A HREF="../../java/awt/Component.html#getFocusTraversalKeys(int)"><CODE>Component.getFocusTraversalKeys(int)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="getCurrentFocusCycleRoot()"><!-- --></A><H3>
getCurrentFocusCycleRoot</H3>
<PRE>
public <A HREF="../../java/awt/Container.html" title="java.awt 中的类">Container</A> <B>getCurrentFocusCycleRoot</B>()</PRE>
<DL>
<DD>如果当前焦点循环根与调用线程位于相同的上下文中，则返回当前焦点循环根。如果焦点所有者本身是一个焦点循环根，则在正常焦点遍历期间，哪些 Component 表示焦点的上一个和下一个 Component 可能不明确。在这种情况下，需要使用当前焦点循环根来区分各种可能性。
 <p>
此方法仅供 KeyboardFocusManager 和焦点实现使用。一般客户端不能使用。
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>返回：</B><DD>当前焦点循环根；如果当前焦点循环根调用的不是线程上下文的成员，则返回 null<DT><B>另请参见：</B><DD><A HREF="../../java/awt/KeyboardFocusManager.html#getGlobalCurrentFocusCycleRoot()"><CODE>getGlobalCurrentFocusCycleRoot()</CODE></A>, 
<A HREF="../../java/awt/KeyboardFocusManager.html#setGlobalCurrentFocusCycleRoot(java.awt.Container)"><CODE>setGlobalCurrentFocusCycleRoot(java.awt.Container)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="getGlobalCurrentFocusCycleRoot()"><!-- --></A><H3>
getGlobalCurrentFocusCycleRoot</H3>
<PRE>
protected <A HREF="../../java/awt/Container.html" title="java.awt 中的类">Container</A> <B>getGlobalCurrentFocusCycleRoot</B>()
                                            throws <A HREF="../../java/lang/SecurityException.html" title="java.lang 中的类">SecurityException</A></PRE>
<DL>
<DD>返回当前焦点循环根，即使调用线程处于当前焦点循环根之外的上下文中。如果焦点所有者本身是一个焦点循环根，则在正常焦点遍历期间，哪些 Component 表示焦点的上一个和下一个 Component 可能不明确。在这种情况下，需要使用当前焦点循环根来区分各种可能性。
 <p>
如果此 KeyboardFocusManager 调用的不是线程上下文的当前 KeyboardFocusManager，则此方法将抛出 SecurityException。
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>返回：</B><DD>当前焦点循环根；如果当前焦点循环根调用的不是线程上下文的成员，则返回 null
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../java/lang/SecurityException.html" title="java.lang 中的类">SecurityException</A></CODE> - 如果此 KeyboardFocusManager 调用的不是线程上下文的当前 KeyboardFocusManager<DT><B>另请参见：</B><DD><A HREF="../../java/awt/KeyboardFocusManager.html#getCurrentFocusCycleRoot()"><CODE>getCurrentFocusCycleRoot()</CODE></A>, 
<A HREF="../../java/awt/KeyboardFocusManager.html#setGlobalCurrentFocusCycleRoot(java.awt.Container)"><CODE>setGlobalCurrentFocusCycleRoot(java.awt.Container)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="setGlobalCurrentFocusCycleRoot(java.awt.Container)"><!-- --></A><H3>
setGlobalCurrentFocusCycleRoot</H3>
<PRE>
public void <B>setGlobalCurrentFocusCycleRoot</B>(<A HREF="../../java/awt/Container.html" title="java.awt 中的类">Container</A>&nbsp;newFocusCycleRoot)</PRE>
<DL>
<DD>设置当前焦点循环根。如果焦点所有者本身是一个焦点循环根，则在正常焦点遍历期间，哪些 Component 表示焦点的上一个和下一个 Component 可能不明确。在这种情况下，需要使用当前焦点循环根来区分各种可能性。
 <p>
此方法仅供 KeyboardFocusManager 和焦点实现使用。一般客户端不能使用。
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>参数：</B><DD><CODE>newFocusCycleRoot</CODE> - 新焦点循环根<DT><B>另请参见：</B><DD><A HREF="../../java/awt/KeyboardFocusManager.html#getCurrentFocusCycleRoot()"><CODE>getCurrentFocusCycleRoot()</CODE></A>, 
<A HREF="../../java/awt/KeyboardFocusManager.html#getGlobalCurrentFocusCycleRoot()"><CODE>getGlobalCurrentFocusCycleRoot()</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="addPropertyChangeListener(java.beans.PropertyChangeListener)"><!-- --></A><H3>
addPropertyChangeListener</H3>
<PRE>
public void <B>addPropertyChangeListener</B>(<A HREF="../../java/beans/PropertyChangeListener.html" title="java.beans 中的接口">PropertyChangeListener</A>&nbsp;listener)</PRE>
<DL>
<DD>将 PropertyChangeListener 添加到侦听器列表。为此类的所有绑定属性注册侦听器，这些属性包括：
 <ul>
<li>KeyboardFocusManager 目前是否管理此应用程序或 applet 浏览器上下文的焦点 (&quot;managingFocus&quot;)</li> 
<li>焦点所有者 (&quot;focusOwner&quot;)</li>
<li>持久焦点所有者 (&quot;permanentFocusOwner&quot;)</li>
<li>聚焦 Window (&quot;focusedWindow&quot;)</li>
<li>活动 Window (&quot;activeWindow&quot;)</li>
<li>默认焦点遍历策略 (&quot;defaultFocusTraversalPolicy&quot;)</li>
<li>默认 FORWARD_TRAVERSAL_KEYS 的 Set (&quot;forwardDefaultFocusTraversalKeys&quot;)</li>
<li>默认 BACKWARD_TRAVERSAL_KEYS 的 Set (&quot;backwardDefaultFocusTraversalKeys&quot;)</li>
<li>默认 UP_CYCLE_TRAVERSAL_KEYS 的 Set (&quot;upCycleDefaultFocusTraversalKeys&quot;)</li>
<li>默认 DOWN_CYCLE_TRAVERSAL_KEYS 的 Set (&quot;downCycleDefaultFocusTraversalKeys&quot;)</li>
<li>当前焦点循环根 (&quot;currentFocusCycleRoot&quot;)</li>
 </ul>
如果侦听器为 null，则不抛出异常，也不执行任何动作。
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>参数：</B><DD><CODE>listener</CODE> - 要添加的 PropertyChangeListener<DT><B>另请参见：</B><DD><A HREF="../../java/awt/KeyboardFocusManager.html#removePropertyChangeListener(java.beans.PropertyChangeListener)"><CODE>removePropertyChangeListener(java.beans.PropertyChangeListener)</CODE></A>, 
<A HREF="../../java/awt/KeyboardFocusManager.html#getPropertyChangeListeners()"><CODE>getPropertyChangeListeners()</CODE></A>, 
<A HREF="../../java/awt/KeyboardFocusManager.html#addPropertyChangeListener(java.lang.String, java.beans.PropertyChangeListener)"><CODE>addPropertyChangeListener(java.lang.String,java.beans.PropertyChangeListener)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="removePropertyChangeListener(java.beans.PropertyChangeListener)"><!-- --></A><H3>
removePropertyChangeListener</H3>
<PRE>
public void <B>removePropertyChangeListener</B>(<A HREF="../../java/beans/PropertyChangeListener.html" title="java.beans 中的接口">PropertyChangeListener</A>&nbsp;listener)</PRE>
<DL>
<DD>从侦听器列表移除 PropertyChangeListener。可以使用此方法移除曾为此类的所有绑定属性注册的 PropertyChangeListener。
 <p>
如果侦听器为 null，则不抛出异常，也不执行任何动作。
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>参数：</B><DD><CODE>listener</CODE> - 要移除的 PropertyChangeListener<DT><B>另请参见：</B><DD><A HREF="../../java/awt/KeyboardFocusManager.html#addPropertyChangeListener(java.beans.PropertyChangeListener)"><CODE>addPropertyChangeListener(java.beans.PropertyChangeListener)</CODE></A>, 
<A HREF="../../java/awt/KeyboardFocusManager.html#getPropertyChangeListeners()"><CODE>getPropertyChangeListeners()</CODE></A>, 
<A HREF="../../java/awt/KeyboardFocusManager.html#removePropertyChangeListener(java.lang.String, java.beans.PropertyChangeListener)"><CODE>removePropertyChangeListener(java.lang.String,java.beans.PropertyChangeListener)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="getPropertyChangeListeners()"><!-- --></A><H3>
getPropertyChangeListeners</H3>
<PRE>
public <A HREF="../../java/beans/PropertyChangeListener.html" title="java.beans 中的接口">PropertyChangeListener</A>[] <B>getPropertyChangeListeners</B>()</PRE>
<DL>
<DD>返回在此键盘焦点管理器上注册的所有属性更改侦听器组成的数组。
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>返回：</B><DD>返回此键盘焦点管理器的所有 <code>PropertyChangeListener</code>；如果目前没有注册任何属性更改侦听器，则返回空数组<DT><B>从以下版本开始：</B></DT>
  <DD>1.4</DD>
<DT><B>另请参见：</B><DD><A HREF="../../java/awt/KeyboardFocusManager.html#addPropertyChangeListener(java.beans.PropertyChangeListener)"><CODE>addPropertyChangeListener(java.beans.PropertyChangeListener)</CODE></A>, 
<A HREF="../../java/awt/KeyboardFocusManager.html#removePropertyChangeListener(java.beans.PropertyChangeListener)"><CODE>removePropertyChangeListener(java.beans.PropertyChangeListener)</CODE></A>, 
<A HREF="../../java/awt/KeyboardFocusManager.html#getPropertyChangeListeners(java.lang.String)"><CODE>getPropertyChangeListeners(java.lang.String)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="addPropertyChangeListener(java.lang.String, java.beans.PropertyChangeListener)"><!-- --></A><H3>
addPropertyChangeListener</H3>
<PRE>
public void <B>addPropertyChangeListener</B>(<A HREF="../../java/lang/String.html" title="java.lang 中的类">String</A>&nbsp;propertyName,
                                      <A HREF="../../java/beans/PropertyChangeListener.html" title="java.beans 中的接口">PropertyChangeListener</A>&nbsp;listener)</PRE>
<DL>
<DD>将 PropertyChangeListener 添加到特定属性的侦听器列表。指定属性可能是用户定义的，也可能是以下属性之一：
 <ul>
<li>KeyboardFocusManager 目前是否管理此应用程序或 applet 浏览器上下文的焦点 (&quot;managingFocus&quot;)</li> 
<li>焦点所有者 (&quot;focusOwner&quot;)</li>
<li>持久焦点所有者 (&quot;permanentFocusOwner&quot;)</li>
<li>聚焦 Window (&quot;focusedWindow&quot;)</li>
<li>活动 Window (&quot;activeWindow&quot;)</li>
<li>默认焦点遍历策略 (&quot;defaultFocusTraversalPolicy&quot;)</li>
<li>默认 FORWARD_TRAVERSAL_KEYS 的 Set (&quot;forwardDefaultFocusTraversalKeys&quot;)</li>
<li>默认 BACKWARD_TRAVERSAL_KEYS 的 Set (&quot;backwardDefaultFocusTraversalKeys&quot;)</li>
<li>默认 UP_CYCLE_TRAVERSAL_KEYS 的 Set (&quot;upCycleDefaultFocusTraversalKeys&quot;)</li>
<li>默认 DOWN_CYCLE_TRAVERSAL_KEYS 的 Set (&quot;downCycleDefaultFocusTraversalKeys&quot;)</li>
<li>当前焦点循环根 (&quot;currentFocusCycleRoot&quot;)</li>
 </ul>
如果侦听器为 null，则不抛出异常，也不执行任何动作。
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>参数：</B><DD><CODE>propertyName</CODE> - 上面列出的属性名之一<DD><CODE>listener</CODE> - 要添加的 PropertyChangeListener<DT><B>另请参见：</B><DD><A HREF="../../java/awt/KeyboardFocusManager.html#addPropertyChangeListener(java.beans.PropertyChangeListener)"><CODE>addPropertyChangeListener(java.beans.PropertyChangeListener)</CODE></A>, 
<A HREF="../../java/awt/KeyboardFocusManager.html#removePropertyChangeListener(java.lang.String, java.beans.PropertyChangeListener)"><CODE>removePropertyChangeListener(java.lang.String,java.beans.PropertyChangeListener)</CODE></A>, 
<A HREF="../../java/awt/KeyboardFocusManager.html#getPropertyChangeListeners(java.lang.String)"><CODE>getPropertyChangeListeners(java.lang.String)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="removePropertyChangeListener(java.lang.String, java.beans.PropertyChangeListener)"><!-- --></A><H3>
removePropertyChangeListener</H3>
<PRE>
public void <B>removePropertyChangeListener</B>(<A HREF="../../java/lang/String.html" title="java.lang 中的类">String</A>&nbsp;propertyName,
                                         <A HREF="../../java/beans/PropertyChangeListener.html" title="java.beans 中的接口">PropertyChangeListener</A>&nbsp;listener)</PRE>
<DL>
<DD>从特定属性的侦听器列表移除 PropertyChangeListener。可以使用此方法移除为特定绑定属性注册的 PropertyChangeListener。
 <p>
如果侦听器为 null，则不抛出异常，也不执行任何动作。
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>参数：</B><DD><CODE>propertyName</CODE> - 有效属性名<DD><CODE>listener</CODE> - 要移除的 PropertyChangeListener<DT><B>另请参见：</B><DD><A HREF="../../java/awt/KeyboardFocusManager.html#addPropertyChangeListener(java.lang.String, java.beans.PropertyChangeListener)"><CODE>addPropertyChangeListener(java.lang.String,java.beans.PropertyChangeListener)</CODE></A>, 
<A HREF="../../java/awt/KeyboardFocusManager.html#getPropertyChangeListeners(java.lang.String)"><CODE>getPropertyChangeListeners(java.lang.String)</CODE></A>, 
<A HREF="../../java/awt/KeyboardFocusManager.html#removePropertyChangeListener(java.beans.PropertyChangeListener)"><CODE>removePropertyChangeListener(java.beans.PropertyChangeListener)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="getPropertyChangeListeners(java.lang.String)"><!-- --></A><H3>
getPropertyChangeListeners</H3>
<PRE>
public <A HREF="../../java/beans/PropertyChangeListener.html" title="java.beans 中的接口">PropertyChangeListener</A>[] <B>getPropertyChangeListeners</B>(<A HREF="../../java/lang/String.html" title="java.lang 中的类">String</A>&nbsp;propertyName)</PRE>
<DL>
<DD>返回与指定属性相关联的所有 <code>PropertyChangeListener</code> 组成的数组。
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>返回：</B><DD>与指定属性相关联的所有 <code>PropertyChangeListener</code>；如果没有添加过这样的侦听器，则返回空数组。<DT><B>从以下版本开始：</B></DT>
  <DD>1.4</DD>
<DT><B>另请参见：</B><DD><A HREF="../../java/awt/KeyboardFocusManager.html#addPropertyChangeListener(java.lang.String, java.beans.PropertyChangeListener)"><CODE>addPropertyChangeListener(java.lang.String,java.beans.PropertyChangeListener)</CODE></A>, 
<A HREF="../../java/awt/KeyboardFocusManager.html#removePropertyChangeListener(java.lang.String, java.beans.PropertyChangeListener)"><CODE>removePropertyChangeListener(java.lang.String,java.beans.PropertyChangeListener)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="firePropertyChange(java.lang.String, java.lang.Object, java.lang.Object)"><!-- --></A><H3>
firePropertyChange</H3>
<PRE>
protected void <B>firePropertyChange</B>(<A HREF="../../java/lang/String.html" title="java.lang 中的类">String</A>&nbsp;propertyName,
                                  <A HREF="../../java/lang/Object.html" title="java.lang 中的类">Object</A>&nbsp;oldValue,
                                  <A HREF="../../java/lang/Object.html" title="java.lang 中的类">Object</A>&nbsp;newValue)</PRE>
<DL>
<DD>激发 PropertyChangeEvent 以响应绑定属性中的更改。该事件将被传递到所有已注册的 PropertyChangeListener 中。如果 oldValue 和 newValue 相同，则不会传递事件。
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>参数：</B><DD><CODE>propertyName</CODE> - 已更改的属性名<DD><CODE>oldValue</CODE> - 属性的上一个值<DD><CODE>newValue</CODE> - 属性的新值</DL>
</DD>
</DL>
<HR>

<A NAME="addVetoableChangeListener(java.beans.VetoableChangeListener)"><!-- --></A><H3>
addVetoableChangeListener</H3>
<PRE>
public void <B>addVetoableChangeListener</B>(<A HREF="../../java/beans/VetoableChangeListener.html" title="java.beans 中的接口">VetoableChangeListener</A>&nbsp;listener)</PRE>
<DL>
<DD>将 VetoableChangeListener 添加到侦听器列表。为此类的所有可否决属性注册侦听器，这些属性包括：
 <ul>
<li>焦点所有者 (&quot;focusOwner&quot;)</li>
<li>持久焦点所有者 (&quot;permanentFocusOwner&quot;)</li>
<li>聚焦 Window (&quot;focusedWindow&quot;)</li>
<li>活动 Window (&quot;activeWindow&quot;)</li>
 </ul>
如果侦听器为 null，则不抛出异常，也不执行任何动作。
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>参数：</B><DD><CODE>listener</CODE> - 要添加的 VetoableChangeListener<DT><B>另请参见：</B><DD><A HREF="../../java/awt/KeyboardFocusManager.html#removeVetoableChangeListener(java.beans.VetoableChangeListener)"><CODE>removeVetoableChangeListener(java.beans.VetoableChangeListener)</CODE></A>, 
<A HREF="../../java/awt/KeyboardFocusManager.html#getVetoableChangeListeners()"><CODE>getVetoableChangeListeners()</CODE></A>, 
<A HREF="../../java/awt/KeyboardFocusManager.html#addVetoableChangeListener(java.lang.String, java.beans.VetoableChangeListener)"><CODE>addVetoableChangeListener(java.lang.String,java.beans.VetoableChangeListener)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="removeVetoableChangeListener(java.beans.VetoableChangeListener)"><!-- --></A><H3>
removeVetoableChangeListener</H3>
<PRE>
public void <B>removeVetoableChangeListener</B>(<A HREF="../../java/beans/VetoableChangeListener.html" title="java.beans 中的接口">VetoableChangeListener</A>&nbsp;listener)</PRE>
<DL>
<DD>从侦听器列表移除 VetoableChangeListener。使用此方法可以移除曾为此类的所有可否决属性注册的 VetoableChangeListener。
 <p>
如果侦听器为 null，则不抛出异常，也不执行任何动作。
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>参数：</B><DD><CODE>listener</CODE> - 要移除的 VetoableChangeListener<DT><B>另请参见：</B><DD><A HREF="../../java/awt/KeyboardFocusManager.html#addVetoableChangeListener(java.beans.VetoableChangeListener)"><CODE>addVetoableChangeListener(java.beans.VetoableChangeListener)</CODE></A>, 
<A HREF="../../java/awt/KeyboardFocusManager.html#getVetoableChangeListeners()"><CODE>getVetoableChangeListeners()</CODE></A>, 
<A HREF="../../java/awt/KeyboardFocusManager.html#removeVetoableChangeListener(java.lang.String, java.beans.VetoableChangeListener)"><CODE>removeVetoableChangeListener(java.lang.String,java.beans.VetoableChangeListener)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="getVetoableChangeListeners()"><!-- --></A><H3>
getVetoableChangeListeners</H3>
<PRE>
public <A HREF="../../java/beans/VetoableChangeListener.html" title="java.beans 中的接口">VetoableChangeListener</A>[] <B>getVetoableChangeListeners</B>()</PRE>
<DL>
<DD>返回在此键盘焦点管理器上注册的所有可否决更改侦听器组成的数组。
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>返回：</B><DD>此键盘焦点管理器的所有 <code>VetoableChangeListener</code>；如果目前没有注册任何可否决更改侦听器，则返回空数组<DT><B>从以下版本开始：</B></DT>
  <DD>1.4</DD>
<DT><B>另请参见：</B><DD><A HREF="../../java/awt/KeyboardFocusManager.html#addVetoableChangeListener(java.beans.VetoableChangeListener)"><CODE>addVetoableChangeListener(java.beans.VetoableChangeListener)</CODE></A>, 
<A HREF="../../java/awt/KeyboardFocusManager.html#removeVetoableChangeListener(java.beans.VetoableChangeListener)"><CODE>removeVetoableChangeListener(java.beans.VetoableChangeListener)</CODE></A>, 
<A HREF="../../java/awt/KeyboardFocusManager.html#getVetoableChangeListeners(java.lang.String)"><CODE>getVetoableChangeListeners(java.lang.String)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="addVetoableChangeListener(java.lang.String, java.beans.VetoableChangeListener)"><!-- --></A><H3>
addVetoableChangeListener</H3>
<PRE>
public void <B>addVetoableChangeListener</B>(<A HREF="../../java/lang/String.html" title="java.lang 中的类">String</A>&nbsp;propertyName,
                                      <A HREF="../../java/beans/VetoableChangeListener.html" title="java.beans 中的接口">VetoableChangeListener</A>&nbsp;listener)</PRE>
<DL>
<DD>将 VetoableChangeListener 添加到特定属性的侦听器列表。指定属性可能是用户定义的，也可能是以下属性之一：
 <ul>
<li>焦点所有者 (&quot;focusOwner&quot;)</li>
<li>持久焦点所有者 (&quot;permanentFocusOwner&quot;)</li>
<li>聚焦 Window (&quot;focusedWindow&quot;)</li>
<li>活动 Window (&quot;activeWindow&quot;)</li>
 </ul>
如果侦听器为 null，则不抛出异常，也不执行任何动作。
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>参数：</B><DD><CODE>propertyName</CODE> - 上面列出的属性名之一<DD><CODE>listener</CODE> - 要添加的 VetoableChangeListener<DT><B>另请参见：</B><DD><A HREF="../../java/awt/KeyboardFocusManager.html#addVetoableChangeListener(java.beans.VetoableChangeListener)"><CODE>addVetoableChangeListener(java.beans.VetoableChangeListener)</CODE></A>, 
<A HREF="../../java/awt/KeyboardFocusManager.html#removeVetoableChangeListener(java.beans.VetoableChangeListener)"><CODE>removeVetoableChangeListener(java.beans.VetoableChangeListener)</CODE></A>, 
<A HREF="../../java/awt/KeyboardFocusManager.html#getVetoableChangeListeners()"><CODE>getVetoableChangeListeners()</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="removeVetoableChangeListener(java.lang.String, java.beans.VetoableChangeListener)"><!-- --></A><H3>
removeVetoableChangeListener</H3>
<PRE>
public void <B>removeVetoableChangeListener</B>(<A HREF="../../java/lang/String.html" title="java.lang 中的类">String</A>&nbsp;propertyName,
                                         <A HREF="../../java/beans/VetoableChangeListener.html" title="java.beans 中的接口">VetoableChangeListener</A>&nbsp;listener)</PRE>
<DL>
<DD>从特定属性的侦听器列表移除 VetoableChangeListener。可以使用此方法移除为特定绑定属性注册的 VetoableChangeListener。
 <p>
如果侦听器为 null，则不抛出异常，也不执行任何动作。
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>参数：</B><DD><CODE>propertyName</CODE> - 有效属性名<DD><CODE>listener</CODE> - 要移除的 VetoableChangeListener<DT><B>另请参见：</B><DD><A HREF="../../java/awt/KeyboardFocusManager.html#addVetoableChangeListener(java.beans.VetoableChangeListener)"><CODE>addVetoableChangeListener(java.beans.VetoableChangeListener)</CODE></A>, 
<A HREF="../../java/awt/KeyboardFocusManager.html#getVetoableChangeListeners()"><CODE>getVetoableChangeListeners()</CODE></A>, 
<A HREF="../../java/awt/KeyboardFocusManager.html#removeVetoableChangeListener(java.beans.VetoableChangeListener)"><CODE>removeVetoableChangeListener(java.beans.VetoableChangeListener)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="getVetoableChangeListeners(java.lang.String)"><!-- --></A><H3>
getVetoableChangeListeners</H3>
<PRE>
public <A HREF="../../java/beans/VetoableChangeListener.html" title="java.beans 中的接口">VetoableChangeListener</A>[] <B>getVetoableChangeListeners</B>(<A HREF="../../java/lang/String.html" title="java.lang 中的类">String</A>&nbsp;propertyName)</PRE>
<DL>
<DD>返回与指定属性相关联的所有 <code>VetoableChangeListener</code> 组成的数组。
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>返回：</B><DD>与指定属性相关联的所有 <code>VetoableChangeListener</code>；如果没有添加过这样的侦听器，则返回空数组。<DT><B>从以下版本开始：</B></DT>
  <DD>1.4</DD>
<DT><B>另请参见：</B><DD><A HREF="../../java/awt/KeyboardFocusManager.html#addVetoableChangeListener(java.lang.String, java.beans.VetoableChangeListener)"><CODE>addVetoableChangeListener(java.lang.String,java.beans.VetoableChangeListener)</CODE></A>, 
<A HREF="../../java/awt/KeyboardFocusManager.html#removeVetoableChangeListener(java.lang.String, java.beans.VetoableChangeListener)"><CODE>removeVetoableChangeListener(java.lang.String,java.beans.VetoableChangeListener)</CODE></A>, 
<A HREF="../../java/awt/KeyboardFocusManager.html#getVetoableChangeListeners()"><CODE>getVetoableChangeListeners()</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="fireVetoableChange(java.lang.String, java.lang.Object, java.lang.Object)"><!-- --></A><H3>
fireVetoableChange</H3>
<PRE>
protected void <B>fireVetoableChange</B>(<A HREF="../../java/lang/String.html" title="java.lang 中的类">String</A>&nbsp;propertyName,
                                  <A HREF="../../java/lang/Object.html" title="java.lang 中的类">Object</A>&nbsp;oldValue,
                                  <A HREF="../../java/lang/Object.html" title="java.lang 中的类">Object</A>&nbsp;newValue)
                           throws <A HREF="../../java/beans/PropertyVetoException.html" title="java.beans 中的类">PropertyVetoException</A></PRE>
<DL>
<DD>激发 PropertyChangeEvent 以响应可否决属性中的更改。该事件将被传递到所有已注册的 VetoableChangeListener 中。如果 VetoableChangeListener 抛出 PropertyVetoException，则激发将所有 VetoableChangeListener 还原为旧值的新事件，并再次抛出异常。如果 oldValue 和 newValue 相同，则不会传递事件。
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>参数：</B><DD><CODE>propertyName</CODE> - 已更改的属性名<DD><CODE>oldValue</CODE> - 属性以前的值<DD><CODE>newValue</CODE> - 属性的新值
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../java/beans/PropertyVetoException.html" title="java.beans 中的类">PropertyVetoException</A></CODE> - 如果 <code>VetoableChangeListener</code> 抛出了 <code>PropertyVetoException</code></DL>
</DD>
</DL>
<HR>

<A NAME="addKeyEventDispatcher(java.awt.KeyEventDispatcher)"><!-- --></A><H3>
addKeyEventDispatcher</H3>
<PRE>
public void <B>addKeyEventDispatcher</B>(<A HREF="../../java/awt/KeyEventDispatcher.html" title="java.awt 中的接口">KeyEventDispatcher</A>&nbsp;dispatcher)</PRE>
<DL>
<DD>将 KeyEventDispatcher 添加到此 KeyboardFocusManager 的调度程序链中。此 KeyboardFocusManager 将请求每个 KeyEventDispatcher 在最终指派 KeyEvent 本身之前，首先指派由用户生成的 KeyEvent。KeyEventDispatcher 将按其添加顺序得到通知。一旦一个 KeyEventDispatcher 从其 <code>dispatchKeyEvent</code> 方法返回 <code>true</code>，通知就会暂停。可以添加的 KeyEventDispatcher 的总数没有限制，添加特定 KeyEventDispatcher 实例的次数也没有限制。
 <p>
如果指定了 null 指派程序，则不执行动作也不抛出异常。
 <p>
在多线程应用程序中，<A HREF="../../java/awt/KeyEventDispatcher.html" title="java.awt 中的接口"><CODE>KeyEventDispatcher</CODE></A> 的行为与其他 AWT 侦听器相同。有关更多详细信息，请参阅 <a href="doc-files/AWTThreadIssues.html#ListenersThreads"  >AWT 线程问题</a>。
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>参数：</B><DD><CODE>dispatcher</CODE> - 要添加到指派程序链的 KeyEventDispatcher<DT><B>另请参见：</B><DD><A HREF="../../java/awt/KeyboardFocusManager.html#removeKeyEventDispatcher(java.awt.KeyEventDispatcher)"><CODE>removeKeyEventDispatcher(java.awt.KeyEventDispatcher)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="removeKeyEventDispatcher(java.awt.KeyEventDispatcher)"><!-- --></A><H3>
removeKeyEventDispatcher</H3>
<PRE>
public void <B>removeKeyEventDispatcher</B>(<A HREF="../../java/awt/KeyEventDispatcher.html" title="java.awt 中的接口">KeyEventDispatcher</A>&nbsp;dispatcher)</PRE>
<DL>
<DD>移除以前添加到此 KeyboardFocusManager 调度程序链中的 KeyEventDispatcher。此 KeyboardFocusManager 本身不能被移除，除非它是通过调用 <code>addKeyEventDispatcher</code> 显式重新注册的。
 <p>
如果指定了 null 调度程序，指定的调度程序没有位于调度程序链中，或者此 KeyboardFocusManager 不是通过显式重新注册指定的，则不执行动作也不抛出异常。
 <p>
在多线程应用程序中，<A HREF="../../java/awt/KeyEventDispatcher.html" title="java.awt 中的接口"><CODE>KeyEventDispatcher</CODE></A> 的行为与其他 AWT 侦听器相同。有关更多详细信息，请参阅 <a href="doc-files/AWTThreadIssues.html#ListenersThreads"  >AWT 线程问题</a>。
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>参数：</B><DD><CODE>dispatcher</CODE> - 要从调度程序链中移除的 KeyEventDispatcher<DT><B>另请参见：</B><DD><A HREF="../../java/awt/KeyboardFocusManager.html#addKeyEventDispatcher(java.awt.KeyEventDispatcher)"><CODE>addKeyEventDispatcher(java.awt.KeyEventDispatcher)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="getKeyEventDispatchers()"><!-- --></A><H3>
getKeyEventDispatchers</H3>
<PRE>
protected <A HREF="../../java/util/List.html" title="java.util 中的接口">List</A>&lt;<A HREF="../../java/awt/KeyEventDispatcher.html" title="java.awt 中的接口">KeyEventDispatcher</A>&gt; <B>getKeyEventDispatchers</B>()</PRE>
<DL>
<DD>作为 List 返回此 KeyboardFocusManager 的 KeyEventDispatcher 链。该 List 不包括此 KeyboardFocusManager，除非它是通过调用 <code>addKeyEventDispatcher</code> 显式重新注册的。如果没有注册其他 KeyEventDispatcher，则实现随意返回 null 或长度为 0 的 List。客户端代码不应假定某种行为多于其他行为，也不应假定建立行为后不能更改。
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>返回：</B><DD>可能返回 null，也可能返回 KeyEventDispatcher 的空 List<DT><B>另请参见：</B><DD><A HREF="../../java/awt/KeyboardFocusManager.html#addKeyEventDispatcher(java.awt.KeyEventDispatcher)"><CODE>addKeyEventDispatcher(java.awt.KeyEventDispatcher)</CODE></A>, 
<A HREF="../../java/awt/KeyboardFocusManager.html#removeKeyEventDispatcher(java.awt.KeyEventDispatcher)"><CODE>removeKeyEventDispatcher(java.awt.KeyEventDispatcher)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="addKeyEventPostProcessor(java.awt.KeyEventPostProcessor)"><!-- --></A><H3>
addKeyEventPostProcessor</H3>
<PRE>
public void <B>addKeyEventPostProcessor</B>(<A HREF="../../java/awt/KeyEventPostProcessor.html" title="java.awt 中的接口">KeyEventPostProcessor</A>&nbsp;processor)</PRE>
<DL>
<DD>将 KeyEventPostProcessor 添加到此 KeyboardFocusManager 的后处理器链中。将 KeyEvent 指派给目标并由目标处理后，KeyboardFocusManager 将请求每个 KeyEventPostProcessor 作为 KeyEvent 的最终解析的一部分执行所有必要的后处理操作。KeyEventPostProcessor 将按其添加顺序得到通知；当前 KeyboardFocusManager 将排在最后。一旦一个 KeyEventPostProcessor 从其 <code>postProcessKeyEvent</code> 方法返回 <code>true</code>，通知就会暂停。可以添加的 KeyEventPostProcessors 的总数没有限制，添加特定 KeyEventPostProcessor 实例的次数也没有限制。
 <p>
如果指定了 null 后处理器，则不执行动作也不抛出异常。
 <p>
在多线程应用程序中，<A HREF="../../java/awt/KeyEventPostProcessor.html" title="java.awt 中的接口"><CODE>KeyEventPostProcessor</CODE></A> 的行为与其他 AWT 侦听器相同。有关更多详细信息，请参阅 <a href="doc-files/AWTThreadIssues.html#ListenersThreads"  >AWT 线程问题</a>。
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>参数：</B><DD><CODE>processor</CODE> - 要添加到后处理器链的 KeyEventPostProcessor<DT><B>另请参见：</B><DD><A HREF="../../java/awt/KeyboardFocusManager.html#removeKeyEventPostProcessor(java.awt.KeyEventPostProcessor)"><CODE>removeKeyEventPostProcessor(java.awt.KeyEventPostProcessor)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="removeKeyEventPostProcessor(java.awt.KeyEventPostProcessor)"><!-- --></A><H3>
removeKeyEventPostProcessor</H3>
<PRE>
public void <B>removeKeyEventPostProcessor</B>(<A HREF="../../java/awt/KeyEventPostProcessor.html" title="java.awt 中的接口">KeyEventPostProcessor</A>&nbsp;processor)</PRE>
<DL>
<DD>从此 KeyboardFocusManager 的后处理器链中移除以前添加的 KeyEventPostProcessor。从该链中无法将 KeyboardFocusManager 本身完全移除。只能移除通过 <code>addKeyEventPostProcessor</code> 添加的其他引用。
 <p>
如果指定了 null 后处理器，指定的后处理器没有位于后处理器链中，或者此 KeyboardFocusManager 不是通过显式添加指定的，则不执行动作也不抛出异常。
 <p>
在多线程应用程序中，<A HREF="../../java/awt/KeyEventPostProcessor.html" title="java.awt 中的接口"><CODE>KeyEventPostProcessor</CODE></A> 的行为与其他 AWT 侦听器相同。有关更多详细信息，请参阅 <a href="doc-files/AWTThreadIssues.html#ListenersThreads"  >AWT 线程问题</a>。
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>参数：</B><DD><CODE>processor</CODE> - 要从后处理器链中移除的 KeyEventPostProcessor<DT><B>另请参见：</B><DD><A HREF="../../java/awt/KeyboardFocusManager.html#addKeyEventPostProcessor(java.awt.KeyEventPostProcessor)"><CODE>addKeyEventPostProcessor(java.awt.KeyEventPostProcessor)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="getKeyEventPostProcessors()"><!-- --></A><H3>
getKeyEventPostProcessors</H3>
<PRE>
protected <A HREF="../../java/util/List.html" title="java.util 中的接口">List</A>&lt;<A HREF="../../java/awt/KeyEventPostProcessor.html" title="java.awt 中的接口">KeyEventPostProcessor</A>&gt; <B>getKeyEventPostProcessors</B>()</PRE>
<DL>
<DD>作为 List 返回此 KeyboardFocusManager 的 KeyEventPostProcessor 链。该 List 不包括此 KeyboardFocusManager，除非它是通过调用 <code>addKeyEventPostProcessor</code> 显式添加的。如果没有注册任何 KeyEventDispatcher，则实现随意返回 null 或长度为 0 的 List。客户端代码不应假定某种行为多于其他行为，也不应假定建立行为后不能更改。
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>返回：</B><DD>可能返回 null 也可能返回 KeyEventPostProcessor 的空 List<DT><B>另请参见：</B><DD><A HREF="../../java/awt/KeyboardFocusManager.html#addKeyEventPostProcessor(java.awt.KeyEventPostProcessor)"><CODE>addKeyEventPostProcessor(java.awt.KeyEventPostProcessor)</CODE></A>, 
<A HREF="../../java/awt/KeyboardFocusManager.html#removeKeyEventPostProcessor(java.awt.KeyEventPostProcessor)"><CODE>removeKeyEventPostProcessor(java.awt.KeyEventPostProcessor)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="dispatchEvent(java.awt.AWTEvent)"><!-- --></A><H3>
dispatchEvent</H3>
<PRE>
public abstract boolean <B>dispatchEvent</B>(<A HREF="../../java/awt/AWTEvent.html" title="java.awt 中的类">AWTEvent</A>&nbsp;e)</PRE>
<DL>
<DD>AWT 事件调度程序可以调用此方法，请求当前的 KeyboardFocusManager 为其指派指定的事件。所有 KeyboardFocusManager 需要指派所有 FocusEvent、所有与焦点相关的 WindowEvent 和所有 KeyEvent。这些事件应该基于 KeyboardFocusManager 的焦点所有者和聚焦及活动 Window 概念指派，有时会重写指定的 AWTEvent 的源代码。必须使用 <code>redispatchEvent</code> 完成指派操作，以防 AWT 事件调度程序递归式请求 KeyboardFocusManager 再次指派该事件。如果此方法返回 <code>false</code>，则 AWT 事件调度程序将尝试指派该事件本身。
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>参数：</B><DD><CODE>e</CODE> - 要指派的 AWTEvent
<DT><B>返回：</B><DD>如果此方法指派了该事件，则返回 <code>true</code>；否则返回 <code>false</code><DT><B>另请参见：</B><DD><A HREF="../../java/awt/KeyboardFocusManager.html#redispatchEvent(java.awt.Component, java.awt.AWTEvent)"><CODE>redispatchEvent(java.awt.Component, java.awt.AWTEvent)</CODE></A>, 
<A HREF="../../java/awt/KeyboardFocusManager.html#dispatchKeyEvent(java.awt.event.KeyEvent)"><CODE>dispatchKeyEvent(java.awt.event.KeyEvent)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="redispatchEvent(java.awt.Component, java.awt.AWTEvent)"><!-- --></A><H3>
redispatchEvent</H3>
<PRE>
public final void <B>redispatchEvent</B>(<A HREF="../../java/awt/Component.html" title="java.awt 中的类">Component</A>&nbsp;target,
                                  <A HREF="../../java/awt/AWTEvent.html" title="java.awt 中的类">AWTEvent</A>&nbsp;e)</PRE>
<DL>
<DD>重新指派 AWTEvent 的方式是，AWT 事件调度程序不会递归式请求 KeyboardFocusManager 或任何已安装的 KeyEventDispatcher 再次指派该事件。<code>dispatchEvent</code> 的客户端实现和客户端定义的 KeyEventDispatcher 必须调用 <code>redispatchEvent(target, e)</code> 而不是调用 <code>target.dispatchEvent(e)</code> 来指派事件。
 <p>
此方法仅供 KeyboardFocusManager 和 KeyEventDispatcher 使用。一般客户端不能使用。
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>参数：</B><DD><CODE>target</CODE> - 应将事件指派到的 Component<DD><CODE>e</CODE> - 要指派的事件<DT><B>另请参见：</B><DD><A HREF="../../java/awt/KeyboardFocusManager.html#dispatchEvent(java.awt.AWTEvent)"><CODE>dispatchEvent(java.awt.AWTEvent)</CODE></A>, 
<A HREF="../../java/awt/KeyEventDispatcher.html" title="java.awt 中的接口"><CODE>KeyEventDispatcher</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="dispatchKeyEvent(java.awt.event.KeyEvent)"><!-- --></A><H3>
dispatchKeyEvent</H3>
<PRE>
public abstract boolean <B>dispatchKeyEvent</B>(<A HREF="../../java/awt/event/KeyEvent.html" title="java.awt.event 中的类">KeyEvent</A>&nbsp;e)</PRE>
<DL>
<DD>通常情况下，如果该指派程序链中的其他 KeyEventDispatcher 没有指派 KeyEvent 或者没有注册其他 KeyEventDispatcher，则 <code>dispatchEvent</code> 将调用此方法。如果此方法的实现返回 <code>false</code>，则 <code>dispatchEvent</code> 可能试图指派 KeyEvent 本身，或者可能简单地返回 <code>false</code>。如果返回 <code>true</code>，则 <code>dispatchEvent</code> 也应该返回 <code>true</code>。
<P>
<DD><DL>
<DT><B>指定者：</B><DD>接口 <CODE><A HREF="../../java/awt/KeyEventDispatcher.html" title="java.awt 中的接口">KeyEventDispatcher</A></CODE> 中的 <CODE><A HREF="../../java/awt/KeyEventDispatcher.html#dispatchKeyEvent(java.awt.event.KeyEvent)">dispatchKeyEvent</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>参数：</B><DD><CODE>e</CODE> - 当前 KeyboardFocusManager 已经请求此 KeyEventDispatcher 指派的 KeyEvent
<DT><B>返回：</B><DD>如果指派了 KeyEvent，则返回 <code>true</code>；否则，返回 <code>false</code><DT><B>另请参见：</B><DD><A HREF="../../java/awt/KeyboardFocusManager.html#dispatchEvent(java.awt.AWTEvent)"><CODE>dispatchEvent(java.awt.AWTEvent)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="postProcessKeyEvent(java.awt.event.KeyEvent)"><!-- --></A><H3>
postProcessKeyEvent</H3>
<PRE>
public abstract boolean <B>postProcessKeyEvent</B>(<A HREF="../../java/awt/event/KeyEvent.html" title="java.awt.event 中的类">KeyEvent</A>&nbsp;e)</PRE>
<DL>
<DD><code>dispatchKeyEvent</code> 将调用此方法。默认情况下，此方法将通过使用该事件并激活快捷方式来处理映射到 AWT <code>MenuShortcut</code> 的所有未使用的 KeyEvent。
<P>
<DD><DL>
<DT><B>指定者：</B><DD>接口 <CODE><A HREF="../../java/awt/KeyEventPostProcessor.html" title="java.awt 中的接口">KeyEventPostProcessor</A></CODE> 中的 <CODE><A HREF="../../java/awt/KeyEventPostProcessor.html#postProcessKeyEvent(java.awt.event.KeyEvent)">postProcessKeyEvent</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>参数：</B><DD><CODE>e</CODE> - 要后处理的 KeyEvent
<DT><B>返回：</B><DD><code>true</code>，指示任何其他 KeyEventPostProcessor 都将得不到该 KeyEvent 的通知。<DT><B>另请参见：</B><DD><A HREF="../../java/awt/KeyboardFocusManager.html#dispatchKeyEvent(java.awt.event.KeyEvent)"><CODE>dispatchKeyEvent(java.awt.event.KeyEvent)</CODE></A>, 
<A HREF="../../java/awt/MenuShortcut.html" title="java.awt 中的类"><CODE>MenuShortcut</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="processKeyEvent(java.awt.Component, java.awt.event.KeyEvent)"><!-- --></A><H3>
processKeyEvent</H3>
<PRE>
public abstract void <B>processKeyEvent</B>(<A HREF="../../java/awt/Component.html" title="java.awt 中的类">Component</A>&nbsp;focusedComponent,
                                     <A HREF="../../java/awt/event/KeyEvent.html" title="java.awt.event 中的类">KeyEvent</A>&nbsp;e)</PRE>
<DL>
<DD>当且仅当该 KeyEvent 表示指定 focusedComponent 的焦点遍历键时，此方法启动焦点遍历操作。focusedComponent 应该是当前的焦点所有者，尽管这一点不是必需的。如果它不是，焦点遍历仍把 focusedComponent 当作是当前焦点所有者而继续执行操作。
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>参数：</B><DD><CODE>focusedComponent</CODE> - 指定的事件表示其焦点遍历键时，将成为焦点遍历操作基础的 Component<DD><CODE>e</CODE> - 可能表示焦点遍历键的事件</DL>
</DD>
</DL>
<HR>

<A NAME="enqueueKeyEvents(long, java.awt.Component)"><!-- --></A><H3>
enqueueKeyEvents</H3>
<PRE>
protected abstract void <B>enqueueKeyEvents</B>(long&nbsp;after,
                                         <A HREF="../../java/awt/Component.html" title="java.awt 中的类">Component</A>&nbsp;untilFocused)</PRE>
<DL>
<DD>在指定的 Component 成为焦点所有者以前由 AWT 调用，以通知 KeyboardFocusManager 延迟指派 KeyEvent。如果客户端代码请求焦点更改，则 AWT 将确定本机窗口操作系统是否批准此请求，然后由 AWT 调用此方法。在指定的 Component 接收 FOCUS_GAINED 事件或 AWT 通过调用 <code>dequeueKeyEvents</code> 或 <code>discardKeyEvents</code> 取消延迟请求以前，KeyboardFocusManager 负责延迟指派时间戳晚于指定时间戳的 KeyEvent。
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>参数：</B><DD><CODE>after</CODE> - 当前事件的时间戳，如果当前事件没有时间戳或者 AWT 无法确定目前正在处理哪个事件，则为当前系统时间<DD><CODE>untilFocused</CODE> - 挂起 KeyEvent 之前应该接收 FOCUS_GAINED 事件的 Component<DT><B>另请参见：</B><DD><A HREF="../../java/awt/KeyboardFocusManager.html#dequeueKeyEvents(long, java.awt.Component)"><CODE>dequeueKeyEvents(long, java.awt.Component)</CODE></A>, 
<A HREF="../../java/awt/KeyboardFocusManager.html#discardKeyEvents(java.awt.Component)"><CODE>discardKeyEvents(java.awt.Component)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="dequeueKeyEvents(long, java.awt.Component)"><!-- --></A><H3>
dequeueKeyEvents</H3>
<PRE>
protected abstract void <B>dequeueKeyEvents</B>(long&nbsp;after,
                                         <A HREF="../../java/awt/Component.html" title="java.awt 中的类">Component</A>&nbsp;untilFocused)</PRE>
<DL>
<DD>由 AWT 调用以通知 KeyboardFocusManager 应该取消延迟指派 KeyEvent。应该释放由于使用相同时间戳和 Component 调用 <code>enqueueKeyEvents</code> 而加入队列的 KeyEvent，以将它们正常指派给当前焦点所有者。如果给定的时间戳小于零，则应该取消具有 <b>oldest</b> 时间戳的给定 Component 的未处理排队请求（如果有）。
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>参数：</B><DD><CODE>after</CODE> - 在对 <code>enqueueKeyEvents</code> 的调用中指定的时间戳，或者任何小于 0 的值<DD><CODE>untilFocused</CODE> - 在对 <code>enqueueKeyEvents</code> 的调用中指定的 Component<DT><B>另请参见：</B><DD><A HREF="../../java/awt/KeyboardFocusManager.html#enqueueKeyEvents(long, java.awt.Component)"><CODE>enqueueKeyEvents(long, java.awt.Component)</CODE></A>, 
<A HREF="../../java/awt/KeyboardFocusManager.html#discardKeyEvents(java.awt.Component)"><CODE>discardKeyEvents(java.awt.Component)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="discardKeyEvents(java.awt.Component)"><!-- --></A><H3>
discardKeyEvents</H3>
<PRE>
protected abstract void <B>discardKeyEvents</B>(<A HREF="../../java/awt/Component.html" title="java.awt 中的类">Component</A>&nbsp;comp)</PRE>
<DL>
<DD>由 AWT 调用以通知 KeyboardFocusManager 应该取消延迟指派 KeyEvent。应该丢弃由于使用相同 Component 一次或多次调用 <code>enqueueKeyEvents</code> 而加入队列 KeyEvent。
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>参数：</B><DD><CODE>comp</CODE> - 对 <code>enqueueKeyEvents</code> 的一次或多次调用中指定的 Component<DT><B>另请参见：</B><DD><A HREF="../../java/awt/KeyboardFocusManager.html#enqueueKeyEvents(long, java.awt.Component)"><CODE>enqueueKeyEvents(long, java.awt.Component)</CODE></A>, 
<A HREF="../../java/awt/KeyboardFocusManager.html#dequeueKeyEvents(long, java.awt.Component)"><CODE>dequeueKeyEvents(long, java.awt.Component)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="focusNextComponent(java.awt.Component)"><!-- --></A><H3>
focusNextComponent</H3>
<PRE>
public abstract void <B>focusNextComponent</B>(<A HREF="../../java/awt/Component.html" title="java.awt 中的类">Component</A>&nbsp;aComponent)</PRE>
<DL>
<DD>聚焦 aComponent 之后的 Component，通常基于 FocusTraversalPolicy。
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>参数：</B><DD><CODE>aComponent</CODE> - 作为焦点遍历操作基础的 Component<DT><B>另请参见：</B><DD><A HREF="../../java/awt/FocusTraversalPolicy.html" title="java.awt 中的类"><CODE>FocusTraversalPolicy</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="focusPreviousComponent(java.awt.Component)"><!-- --></A><H3>
focusPreviousComponent</H3>
<PRE>
public abstract void <B>focusPreviousComponent</B>(<A HREF="../../java/awt/Component.html" title="java.awt 中的类">Component</A>&nbsp;aComponent)</PRE>
<DL>
<DD>聚焦 aComponent 之前的 Component，通常基于 FocusTraversalPolicy。
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>参数：</B><DD><CODE>aComponent</CODE> - 作为焦点遍历操作基础的 Component<DT><B>另请参见：</B><DD><A HREF="../../java/awt/FocusTraversalPolicy.html" title="java.awt 中的类"><CODE>FocusTraversalPolicy</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="upFocusCycle(java.awt.Component)"><!-- --></A><H3>
upFocusCycle</H3>
<PRE>
public abstract void <B>upFocusCycle</B>(<A HREF="../../java/awt/Component.html" title="java.awt 中的类">Component</A>&nbsp;aComponent)</PRE>
<DL>
<DD>将焦点上移一个焦点遍历循环。通常情况下，将焦点所有者设置为 aComponent 的焦点循环根，而将当前焦点循环根设置为新的焦点所有者的焦点循环根。但是，如果 aComponent 的焦点循环根是一个 Window，则通常将焦点所有者设置为要聚焦的 Window 的默认 Component，当前焦点循环根保持不变。
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>参数：</B><DD><CODE>aComponent</CODE> - 作为焦点遍历操作基础的 Component</DL>
</DD>
</DL>
<HR>

<A NAME="downFocusCycle(java.awt.Container)"><!-- --></A><H3>
downFocusCycle</H3>
<PRE>
public abstract void <B>downFocusCycle</B>(<A HREF="../../java/awt/Container.html" title="java.awt 中的类">Container</A>&nbsp;aContainer)</PRE>
<DL>
<DD>将焦点下移一个焦点遍历循环。通常情况下，如果 aContainer 是焦点循环根，则将焦点所有者设置为要聚焦的 aContainer 的默认 Component，而将当前焦点循环根设置为 aContainer。如果 aContainer 不是焦点循环根，则不进行焦点遍历操作。
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>参数：</B><DD><CODE>aContainer</CODE> - 作为焦点遍历操作基础的 Container</DL>
</DD>
</DL>
<HR>

<A NAME="focusNextComponent()"><!-- --></A><H3>
focusNextComponent</H3>
<PRE>
public final void <B>focusNextComponent</B>()</PRE>
<DL>
<DD>聚焦当前焦点所有者之后的 Component。
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="focusPreviousComponent()"><!-- --></A><H3>
focusPreviousComponent</H3>
<PRE>
public final void <B>focusPreviousComponent</B>()</PRE>
<DL>
<DD>聚焦当前焦点所有者之前的 Component。
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="upFocusCycle()"><!-- --></A><H3>
upFocusCycle</H3>
<PRE>
public final void <B>upFocusCycle</B>()</PRE>
<DL>
<DD>从当前焦点所有者将焦点上移一个焦点遍历循环。通常情况下，将新焦点所有者设置为当前焦点所有者的焦点循环根，而将当前焦点循环根设置为新焦点所有者的焦点循环根。但是，如果当前焦点所有者的焦点循环根是一个 Window，则通常将焦点所有者设置为要聚焦的焦点循环根的默认 Component，而当前焦点循环根保持不变。
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="downFocusCycle()"><!-- --></A><H3>
downFocusCycle</H3>
<PRE>
public final void <B>downFocusCycle</B>()</PRE>
<DL>
<DD>当且仅当当前焦点所有者是一个作为焦点循环根的 Container 时，从当前焦点所有者将焦点下移一个焦点遍历循环。通常情况下，将焦点所有者设置为要聚焦的当前焦点所有者的默认 Component，而将当前焦点循环根设置为当前焦点所有者。如果当前焦点所有者不是作为焦点循环根的 Container，则不进行任何焦点遍历操作。
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<!-- ========= END OF CLASS DATA ========= -->
<HR>


<!-- ======= START OF BOTTOM NAVBAR ====== -->
<A NAME="navbar_bottom"><!-- --></A>
<A HREF="#skip-navbar_bottom" title="跳过导航链接"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>概述</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>软件包</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>类</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/KeyboardFocusManager.html"><FONT CLASS="NavBarFont1"><B>使用</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>树</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>已过时</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>索引</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../help-doc.html"><FONT CLASS="NavBarFont1"><B>帮助</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
<b>Java<sup><font size=-2>TM</font></sup>&nbsp;Platform<br>Standard&nbsp;Ed. 6</b></EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../java/awt/JobAttributes.SidesType.html" title="java.awt 中的类"><B>上一个类</B></A>&nbsp;
&nbsp;<A HREF="../../java/awt/KeyEventDispatcher.html" title="java.awt 中的接口"><B>下一个类</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../index.html?java/awt/KeyboardFocusManager.html" target="_top"><B>框架</B></A>  &nbsp;
&nbsp;<A HREF="KeyboardFocusManager.html" target="_top"><B>无框架</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../allclasses-noframe.html"><B>所有类</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../allclasses-noframe.html"><B>所有类</B></A>
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  摘要：&nbsp;嵌套&nbsp;|&nbsp;<A HREF="#field_summary">字段</A>&nbsp;|&nbsp;<A HREF="#constructor_summary">构造方法</A>&nbsp;|&nbsp;<A HREF="#method_summary">方法</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
详细信息：&nbsp;<A HREF="#field_detail">字段</A>&nbsp;|&nbsp;<A HREF="#constructor_detail">构造方法</A>&nbsp;|&nbsp;<A HREF="#method_detail">方法</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_bottom"></A>
<!-- ======== END OF BOTTOM NAVBAR ======= -->

<HR>
<font size="-1"><a href="http://bugs.sun.com/services/bugreport/index.jsp">提交错误或意见</a><br>有关更多的 API 参考资料和开发人员文档，请参阅 <a href="http://java.sun.com/javase/6/webnotes/devdocs-vs-specs.html">Java SE 开发人员文档</a>。该文档包含更详细的、面向开发人员的描述，以及总体概述、术语定义、使用技巧和工作代码示例。 <p>版权所有 2007 Sun Microsystems, Inc. 保留所有权利。 请遵守<a href="http://java.sun.com/javase/6/docs/legal/license.html">许可证条款</a>。另请参阅<a href="http://java.sun.com/docs/redist.html">文档重新分发政策</a>。</font>
</BODY>
</HTML>
